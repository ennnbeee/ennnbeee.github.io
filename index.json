[{"content":"Introduction # So this isn\u0026rsquo;t the first time we\u0026rsquo;ve looked at improving the management of updates using Microsoft Intune, and probably won\u0026rsquo;t be the last time either, especially with declarative device management looming, for Apple and hopefully Windows devices, covering configuration of software updates.\nBut with the introduction of the Windows Autopatch service, and getting hands on with it recently, it prompted me to revisit my previous approach to phased update delivery, so I thought I\u0026rsquo;d share my findings, this time across not just Windows Updates.\nDeployment Approach # Previously, we configured a set of four Update Rings, but now we\u0026rsquo;ll include an early adopters ring as a pre-production release, kind of a fail safe prior to your production deployment of updates; that final catch before you target the entire device estate.\nTest - This should be devices that are dedicated for testing, ~1% of your device estate. Pilot - This should be a stratified sample of either users or devices, ~5% of your device estate. Pre-Production - The early adopters deployment, ~15% of your device estate. Initial Production - The first production deployment, ~30% of your device estate. Final Production - The final production deployment, the remaining ~50% of the device estate. The aim is tht the above groupings are reusable and can be used across not just Windows Updates, but Office Updates, and Driver updates too. Let\u0026rsquo;s look at the membership of these groups.\nDeployment Groups # Despite Microsoft recommending to stop using the match operators in favour of startsWith there are times when you might have to ignore them, this could be one of those times when we look at how we split a device estate into the phased breakdowns we\u0026rsquo;re looking to achieve.\nAfter testing this in the real world, with reset Autopilot Hybrid join devices, you end up with a little bit of conflict on group membership due to there being two computer objects in Entra.\nTo avoid this, I\u0026rsquo;ve added in (device.deviceManagementAppId -ne null) to the group rules, only capturing those devices that are actually enrolled in Microsoft Intune.\nInefficient Dynamic Groups # For the members of Test and Pilot groups, these should be targeted members, not just any old device, so ensure you populate these groups with true test devices, and suitable pilot devices for update testing.\nYou\u0026rsquo;ll notice that this time we\u0026rsquo;re using Dynamic Groups across all the pre-production and production groups, and using a new attribute of deviceId, which is a wonderful UUID associated with all Entra computer objects, and it being a UUID gives us a nice split of devices based on the queries used.\nGroup Type Membership Test Assigned TBC Pilot Assigned TBC Pre-Production Dynamic Device (device.deviceManagementAppId -ne null) and (device.deviceOSType -eq \u0026quot;Windows\u0026quot;) and (device.deviceOwnership -eq \u0026quot;Company\u0026quot;) and (device.deviceId -match \u0026quot;^[0-1,a]\u0026quot;) Initial Production Dynamic Device (device.deviceManagementAppId -ne null) and (device.deviceOSType -eq \u0026quot;Windows\u0026quot;) and (device.deviceOwnership -eq \u0026quot;Company\u0026quot;) and (device.deviceId -match \u0026quot;^[2-4,b-c]\u0026quot;) Final Production Dynamic Device (device.deviceManagementAppId -ne null) and (device.deviceOSType -eq \u0026quot;Windows\u0026quot;) and (device.deviceOwnership -eq \u0026quot;Company\u0026quot;) and (device.deviceId -match \u0026quot;^[5-9,d-f]\u0026quot;) With the start of the deviceId only ever being in the range of 0-9 or a-f we\u0026rsquo;ve an easy way to split our devices across the three production level groups, and ensure that we are capturing all devices, using the match operator, and the regular expression similar to ^[0-9,a-f] to detect whether the deviceId starts with one of the values in the ranges provided.\nYou may want to tweak the rules used here, to alter the size of each of the production groups, by changing the range of the ^[0-9,a-f] query. Efficient Dynamic Groups # If you want to please Microsoft Daddy, then you could use these alternative queries for the groups, Test and Pilot are still assigned, so don\u0026rsquo;t forget to populate those members.\nGroup Type Membership Test Assigned TBC Pilot Assigned TBC Pre-Production Dynamic Device (device.deviceManagementAppId -ne null) and (device.deviceOSType -eq \u0026quot;Windows\u0026quot;) and (device.deviceOwnership -eq \u0026quot;Company\u0026quot;) and ((device.deviceId -startsWith \u0026quot;0\u0026quot;) or (device.deviceId -startsWith \u0026quot;1\u0026quot;) or (device.deviceId -startsWith \u0026quot;a\u0026quot;)) Initial Production Dynamic Device (device.deviceManagementAppId -ne null) and (device.deviceOSType -eq \u0026quot;Windows\u0026quot;) and (device.deviceOwnership -eq \u0026quot;Company\u0026quot;) and ((device.deviceId -startsWith \u0026quot;2\u0026quot;) or (device.deviceId -startsWith \u0026quot;3\u0026quot;) or (device.deviceId -startsWith \u0026quot;4\u0026quot;) or (device.deviceId -startsWith \u0026quot;b\u0026quot;) or (device.deviceId -startsWith \u0026quot;c\u0026quot;)) Final Production Dynamic Device (device.deviceManagementAppId -ne null) and (device.deviceOSType -eq \u0026quot;Windows\u0026quot;) and (device.deviceOwnership -eq \u0026quot;Company\u0026quot;) and ((device.deviceId -startsWith \u0026quot;5\u0026quot;) or (device.deviceId -startsWith \u0026quot;6\u0026quot;) or (device.deviceId -startsWith \u0026quot;7\u0026quot;) or (device.deviceId -startsWith \u0026quot;8\u0026quot;) or (device.deviceId -startsWith \u0026quot;9\u0026quot;) or (device.deviceId -startsWith \u0026quot;d\u0026quot;) or (device.deviceId -startsWith \u0026quot;e\u0026quot;) or (device.deviceId -startsWith \u0026quot;f\u0026quot;)) Much more efficient.\nVIP Groups # What about those people who complain about when they\u0026rsquo;re getting updates, I mean you could tell them to jog on that you can\u0026rsquo;t change the behaviour, or you could cater for the more VIP user, and allow for their device to sit in a different update group.\nSo more assigned groups are required for each potential exception or change to production level deployment options.\nGroup Type Membership VIP Pre-Production Assigned TBC VIP Initial Production Assigned TBC VIP Final Production Assigned TBC See, we can please the senior members of the company with IT solutions.\nWindows Update Rings # Now with suitable groups at our disposal, we can create our Windows Update Rings in Microsoft Intune for each of the five phases, and after reviewing and experiencing Windows Update Rings personally instead of just recommending them, I\u0026rsquo;ve decided to set zero-day installation deadlines, in favour of longer grace periods, still working within the National Cyber Security Centre 14-day window.\nUpdate Ring Deferral Deadline Grace Period Updates Installed Test 0 days 0 days 1 day After 1 day, Wednesday Pilot 2 days 0 days 1 day After 3 days, Friday Pre-Production 5 days 0 days 2 days After 7 days, Tuesday Initial Production 8 days 0 days 2 days After 10 days, Friday Final Production 11 days 0 days 3 days After 14 days, Tuesday You see something else new? Yes, I\u0026rsquo;ve avoided device restarts on weekends following a chat with fellow lover of Microsoft Intune, Jonathan Fallis, meaning that for a weekday based \u0026lsquo;working week\u0026rsquo;, updates get installed and devices restarted when the device is actually on, not over a weekend when realistically the device is still in the office and powered off, or being used to watch Netflix in bed.\nThis also allows for our VIP users to pick which day they actually want their device to restart, based on whatever day they\u0026rsquo;re not playing golf üèåÔ∏è‚Äç‚ôÄÔ∏è.\nOffice Update Rings # Oooooh this one is new, and straight up robbed from Windows Autopatch, and although doesn\u0026rsquo;t exist as a dedicated blade in Microsoft Intune, we can use the glorious Settings Catalog profiles to configure Office Update Channels, deferral, and deadline settings for Microsoft 365 App updates.\nTo start, we need to configure some baseline settings. So go create yourself a new Settings Catalog profile, and throw the below settings into it, the settings exist under Microsoft Office 2016 (Machine) \u0026gt; Updates.\nSetting Detail Location for updates: (Device) http://officecdn.microsoft.com/pr/55336b82-a18d-4dd6-b5f6-9e5095c314a6 Enable Automatic Updates Enabled Hide option to enable or disable updates Enabled Hide Update Notifications Disabled Update Channel Enabled Channel Name (Device) Monthly Enterprise Channel Update Path Enabled With the update channel configured to Monthly Enterprise, and a bit of a change to the user experience, let\u0026rsquo;s see what else we can borrow.\nMake sure you assign this to all your devices in scope of updates, using either an existing group, or the built in \u0026lsquo;All Devices\u0026rsquo; group and a suitable Device Filter. Phased Office Updates # With a similar approach to the Windows Update Rings, we can create corresponding Settings Catalog profiles for our five deployment phases, aligning as best we can the end result, which is installed updates, to the restart of the updates delivered as part of the Windows Update ring configuration.\nAll settings exist under Microsoft Office 2016 (Machine) \u0026gt; Updates.\nUpdate Ring Delay downloading and installing updates for Office Days: (Device) Update Deadline Deadline: (Device) Updates Installed Test Enabled 0 Enabled 1 After 1 day, Wednesday Pilot Enabled 2 Enabled 1 After 3 days, Friday Pre-Production Enabled 5 Enabled 2 After 7 days, Tuesday Initial Production Enabled 8 Enabled 2 After 10 days, Friday Final Production Enabled 11 Enabled 3 After 14 days, Tuesday As Office Updates are released with the same update cadence as our normal updates on a \u0026lsquo;Patch Tuesday\u0026rsquo;, then the installation time falls on the same days, meaning that all updates should be installed and the device restarted on the same day, reducing overall disruption to the users.\nUpdate Ring Assignment # After creating the Windows Update Rings, and our faux Office Update Rings using the above settings, we cover how we assign our phased deployment groups to each suitable Update Ring.\nFeel free to alter the deferral, deadline, and grace periods where applicable to your device estate, but please if you want the experience to be as expected, use the below assignment targets. Update Ring Included Groups Excluded Groups Test Test n/a Pilot Pilot Test Pre-Production Pre-Production Test, Pilot Initial Production Initial Production Test, Pilot Final Production Final Production Test, Pilot I\u0026rsquo;m assuming here that you aren\u0026rsquo;t putting VIP user devices in Test and Pilot, because you don\u0026rsquo;t want to anger them, maybe do it on your last day üòÖ.\nThis is an improvement on our previous version of Update Ring assignment, as we\u0026rsquo;re not relying on excludes and dynamic groups to update to ensure there are no conflicts. VIP Ring Assignment # To get the expected behaviour for our VIP groups, we need to consider what happens when we want to ensure a VIP device is in the correct Update Ring, which includes making sure there are no conflicts across the rings.\nChanging the assignments of our Update Rings to the below, will allow for the manual assignment based on a devices VIP group membership.\nUpdate Ring Included Groups Excluded Groups Test Test n/a Pilot Pilot Test Pre-Production Pre-Production, VIP Pre-Production Test, Pilot, VIP Initial Production, VIP Final Production Initial Production Initial-Production, VIP Initial-Production Test, Pilot, VIP Pre-Production, VIP Final Production Final Production Final Production, VIP Final Production Test, Pilot, VIP Pre-Production, VIP Initial Production For example if device name VIP-7wa7f4c35, with deviceId ec759183-4492-44f4-a2ec-dbc33470bf48 (which will captured by the \u0026lsquo;Final Production\u0026rsquo; dynamic group), is added to group VIP Initial Production, it will exclude the device from the \u0026lsquo;Final Production\u0026rsquo; Update Ring, and assign the Update Ring for \u0026lsquo;Initial Production\u0026rsquo;, with the device restarting after updates on a Friday.\nAdding in not only new include assignments, but exclude assignments, will ensure that devices in these groups are assigned to the correct Update Ring.\nSummary # All of this should give you the option to not only suitably phase Windows, Microsoft, and Office Updates, with each subsequent Update Ring starting only after the next, but also allow the shift of devices around without conflict, whether this is for VIP users or otherwise.\nIt also provides your end users with clear details of the days of when their device will not only get updated, but also restart, without too much of a headache, or interruption to their casual personal use of their corporate owned device.\n","date":"19 February 2024","permalink":"/posts/flexible-update-deployments/","section":"Blog","summary":"It\u0026rsquo;s been a while since we\u0026rsquo;ve looked at deploying Microsoft and Windows Updates using Microsoft Intune, this time we look at different ways to phase our deployments across a device estate.","title":"A Flexible Approach to Microsoft Update Deployments"},{"content":"","date":"19 February 2024","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"19 February 2024","permalink":"/posts/","section":"Blog","summary":"","title":"Blog"},{"content":"","date":"19 February 2024","permalink":"/authors/ennbee/","section":"Authors","summary":"","title":"ennbee"},{"content":"","date":"19 February 2024","permalink":"/tags/groups/","section":"Tags","summary":"","title":"Groups"},{"content":"","date":"19 February 2024","permalink":"/tags/intune/","section":"Tags","summary":"","title":"Intune"},{"content":"","date":"19 February 2024","permalink":"/","section":"MEM v ENNBEE: Battles with Modern Device Management","summary":"","title":"MEM v ENNBEE: Battles with Modern Device Management"},{"content":"","date":"19 February 2024","permalink":"/tags/security/","section":"Tags","summary":"","title":"Security"},{"content":"","date":"19 February 2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"19 February 2024","permalink":"/tags/updates/","section":"Tags","summary":"","title":"Updates"},{"content":"","date":"19 February 2024","permalink":"/tags/windows/","section":"Tags","summary":"","title":"Windows 10 and later"},{"content":"","date":"14 February 2024","permalink":"/tags/apple/","section":"Tags","summary":"","title":"Apple"},{"content":"","date":"14 February 2024","permalink":"/tags/apps/","section":"Tags","summary":"","title":"Apps"},{"content":"Introduction # This isn\u0026rsquo;t the first time we\u0026rsquo;ve looked at deploying backgrounds for Microsoft Teams on macOS, but it\u0026rsquo;s been a while since we answered an internet strangers question, and hopefully my scripting has come on a little way since then (spoiler: it hasn\u0026rsquo;t).\nNow that the \u0026lsquo;New\u0026rsquo; Microsoft Teams app is the de facto version available to download from Microsoft replacing the \u0026lsquo;Classic\u0026rsquo; one, we should at least look at how it handles uploaded backgrounds and if required update our existing script to support not only the \u0026lsquo;Classic\u0026rsquo; version, but the \u0026lsquo;New\u0026rsquo; version too.\nApplication Differences # Before we go digging into the existing script to work out what has broken with the new version of app, we should check to see what, if any differences there are across both version for the purpose of our script.\nUploaded Background Locations # Digging around the internet, and on a macOS device with both apps installed, we can see that uploaded backgrounds from the client itself are stored in the below locations.\nClassic App - $HOME/Library/Application Support/Microsoft/Teams/Backgrounds/Uploads New App - $HOME/Library/Containers/com.microsoft.teams2/Data/Library/Application Support/Microsoft/MSTeams/Backgrounds/Uploads So this is similar to the change in uploaded background location for the Windows version that Florian Salzmann found in their post about updating backgrounds for the new Windows Teams client.\nApplication Name # Another thing to note, is how we were detecting whether the Teams app was installed, referencing the app name, which has also changed, only slightly though but it is still a change.\nClassic App - Microsoft Teams classic.app New App - Microsoft Teams (work or school).app Great, so we need to take into account the file path change, and the app name change. Anything else Microsoft?\nBackground File Names # Yes, obviously. When testing the upload of a background in the \u0026lsquo;New\u0026rsquo; app, I noticed that the background files are renamed to a UUID and created a thumbnail file of the same background, so something similar to the below.\n898ffbba-4997-4911-b2ab-b5d8ef4998d2.png and 898ffbba-4997-4911-b2ab-b5d8ef4998d2_thumb.png\nOK, so we\u0026rsquo;ll need a way to generate a UUID whilst we\u0026rsquo;re at it. The \u0026lsquo;Classic\u0026rsquo; app doesn\u0026rsquo;t care what the files are called, which might be useful.\nBackground Deployment Script # Let\u0026rsquo;s start at least with the existing script and amend or update it to take into consideration the following.\nDetection of whether a Teams app is installed. Detection of which of the \u0026lsquo;Classic\u0026rsquo; or \u0026lsquo;New\u0026rsquo; apps is installed. Managing which directory is used for the uploaded backgrounds. Managing the use of a UUID for the background files for the \u0026lsquo;New\u0026rsquo; app. Not a lot to consider, and with our new found exposure to Shell scripts, we should be more than capable üòê.\nVariables and Logs # As the uploaded backgrounds will reside within the context of the user signed in to the macOS device, we need to ensure that the script, when running from Microsoft Intune is also running under the user context.\nThis means that the log file stored in path set by the logAndMetaDir variable, must be accessible to the user, hence the choice and use of the built-in variable $HOME.\nYou should update the backGroundUrls array variable with the URLs for the backgrounds you want to use in Microsoft Teams, otherwise everything will look like I branded it.\nbackGroundUrls=(\u0026#34;https://raw.githubusercontent.com/ennnbeee/ennnbeee.github.io/main/assets/img/wp.png\u0026#34; \u0026#34;https://raw.githubusercontent.com/ennnbeee/ennnbeee.github.io/main/assets/img/wp-lt.png\u0026#34;) scriptName=\u0026#34;SetNewTeamsBackgrounds\u0026#34; logAndMetaDir=\u0026#34;$HOME/Library/Logs/Microsoft/Intune/Scripts/$scriptName\u0026#34; # Running under the user context log=\u0026#34;$logAndMetaDir/$scriptName.log\u0026#34; if [ -d $logAndMetaDir ]; then echo \u0026#34;# $(date) | Log directory already exists - $logAndMetaDir\u0026#34; else echo \u0026#34;# $(date) | Creating log directory - $logAndMetaDir\u0026#34; mkdir -p \u0026#34;$logAndMetaDir\u0026#34; fi We\u0026rsquo;re covering off the logic to create the log file directory whilst we\u0026rsquo;re at it, so we can at least write the output of the script to a file log in this location.\nChecking versions of the Teams App # Having spent a lot of time browsing the shell-intune-samples GitHub repo, and testing a number of these scripts, the Dock script caught my eye, as it was updated to detect which version of Teams is installed when attempting to add it to a Dock configuration.\nSo I\u0026rsquo;ve taken the existing function, and updated it for our purpose, to not only set the teamsApp variable of the app, but also the teamsUpload variable for the path to the uploaded background folders.\nfunction checkAndSetInstalledMSTeamsPath () { if [[ -a \u0026#34;/Applications/Microsoft Teams.app\u0026#34; ]];then teamsApp=\u0026#34;/Applications/Microsoft Teams.app\u0026#34; teamsUpload=\u0026#34;$HOME/Library/Application Support/Microsoft/Teams/Backgrounds/Uploads\u0026#34; elif [[ -a \u0026#34;/Applications/Microsoft Teams classic.app\u0026#34; ]];then teamsApp=\u0026#34;/Applications/Microsoft Teams classic.app\u0026#34; teamsUpload=\u0026#34;$HOME/Library/Application Support/Microsoft/Teams/Backgrounds/Uploads\u0026#34; elif [[ -a \u0026#34;/Applications/Microsoft Teams (work or school).app\u0026#34; ]]; then teamsApp=\u0026#34;/Applications/Microsoft Teams (work or school).app\u0026#34; teamsUpload=\u0026#34;$HOME/Library/Containers/com.microsoft.teams2/Data/Library/Application Support/Microsoft/MSTeams/Backgrounds/Uploads\u0026#34; elif [[ -a \u0026#34;/Applications/Microsoft Teams (work preview).app\u0026#34; ]]; then teamsApp=\u0026#34;/Applications/Microsoft Teams (work preview).app\u0026#34; teamsUpload=\u0026#34;$HOME/Library/Containers/com.microsoft.teams2/Data/Library/Application Support/Microsoft/MSTeams/Backgrounds/Uploads\u0026#34; fi } We can now call this function to populate the two defined variables, and also detect whether the variable is empty to detect whether Teams is actually installed or not.\nDetecting if Teams is Installed # We\u0026rsquo;ve configured two variables here, ready and teamsMissing, this allows us to continue the running of the script until Teams is actually detected, and in the event that it is installed, will allow the script to continue.\nready=0 while [[ $ready -ne 1 ]];do teamsMissing=0 checkAndSetInstalledMSTeamsPath if [[ -z \u0026#34;$teamsApp\u0026#34; ]]; then let teamsMissing=$teamsMissing+1 echo \u0026#34;$(date) | Microsoft Teams application is missing.\u0026#34; else echo \u0026#34;$(date) | Microsoft Teams application is installed.\u0026#34; fi if [[ $teamsMissing -eq 0 ]]; then ready=1 echo \u0026#34;$(date) | Microsoft Teams App $teamsApp found, lets download the backgrounds.\u0026#34; else echo \u0026#34;$(date) | Waiting for 10 seconds before trying again.\u0026#34; sleep 10 fi done Ensure that you are deploying one of the app versions to your macOS devices using Microsoft Intune, before deploying the script, otherwise it\u0026rsquo;s going to sit there and run in the background.\nCreating the Uploads Directory # Now that we\u0026rsquo;re on the move the download of the files to the correct background upload directory, we should detect whether the directory exists, and if not create it.\nif [[ -d ${teamsUpload} ]] then echo \u0026#34;$(date) | Microsoft Teams Background Upload directory [$teamsUpload] already exists\u0026#34; else echo \u0026#34;$(date) | Creating directory [$teamsUpload]\u0026#34; mkdir -p \u0026#34;$teamsUpload\u0026#34; fi For the \u0026lsquo;Classic\u0026rsquo; app, unless you have actually uploaded a background through the client yourself, this directory doesn\u0026rsquo;t exist.\nDownloading the Backgrounds # As mentioned, the \u0026lsquo;New\u0026rsquo; app needs the files stored with UUID filenames, and the \u0026lsquo;Classic\u0026rsquo; app doesn\u0026rsquo;t care, as this is the case, we can just use a UUID file name for both scenarios.\nGenerating a UUID on macOS we can use uuidgen, and we\u0026rsquo;ve converted the output of this command to lowercase, assigning two new variables backgroundFile and backgroundThumb to use the uuid variable in their file name.\nSo looping through each backGroundUrl in the backGroundUrls array, we can go and download the file to the relevant directory, saved with the UUID file name.\nfor backGroundUrl in \u0026#34;${backGroundUrls[@]}\u0026#34;; do uuid=$(uuidgen | tr \u0026#34;[:upper:]\u0026#34; \u0026#34;[:lower:]\u0026#34;) backgroundFile=$uuid.png backgroundThumb=${uuid}_thumb.png curl -L -o \u0026#34;$teamsUpload/$backgroundFile\u0026#34; $backGroundUrl if [[ $teamsUpload = *Containers* ]];then curl -L -o \u0026#34;$teamsUpload/$backgroundThumb\u0026#34; $backGroundUrl fi done We\u0026rsquo;ve added in logic to detect whether the teamsUpload path variable is for the \u0026lsquo;New\u0026rsquo; app, and if it is, to download the background file but save it with the require _thumb in the filename.\nDeploying the Script # With the script to hand, we can now use Microsoft Intune Shell Scripts to deploy the script to our device estate with the below settings, having uploaded the downloaded file.\nItem Setting Description Run script as signed-in user Yes The background upload directory is a user directory. Hide script notifications on devices Yes Don\u0026rsquo;t tell users things are happening. Script frequency Not Configured We don\u0026rsquo;t want the script to run multiple times. Max number of times to retry if script fails 3 times If Teams isn\u0026rsquo;t installed and the device is restarted, we need a way to re-run the script. Assign this to a test group of macOS devices that has one of the Microsoft Teams apps installed, otherwise you\u0026rsquo;ll be waiting a long time to see the results.\nShell Script Results # Once a device has checked in to Microsoft Intune, and a user is signed in to the device, the script should run, storing the log file in the location defined in the variable.\nSo for this device it\u0026rsquo;s Users/ennbee/Library/Logs/Microsoft/Intune/Scripts/SetNewTeamsBackgrounds\nWe can now check our test devices, one running the \u0026lsquo;Classic\u0026rsquo; app, and one the \u0026lsquo;New\u0026rsquo; app to see what has actually happened.\n\u0026lsquo;Classic\u0026rsquo; Teams Results # Opening the log file, we can see the results of the script running on a device with the \u0026lsquo;Classic\u0026rsquo; app.\nWith the files downloaded to the Users/ennbee/Library/Application Support/Microsoft/Teams/Backgrounds/Uploads directory.\nHaving a look in the directory location, we can see that two new files exist, both with UUID based filenames.\nOpening \u0026lsquo;Classic\u0026rsquo; Teams, we can now see and use these uploaded backgrounds.\n\u0026lsquo;New\u0026rsquo; Teams Results # It\u0026rsquo;s a similar story with the \u0026lsquo;New\u0026rsquo; apps, with the log showing successful download of the backgrounds to Users/ennbee//Library/Containers/com.microsoft.teams2/Data/Library/Application Support/Microsoft/MSTeams/Backgrounds/Uploads.\nThis time we also have the creation of the thumbnail files in the same directory.\nWhen opening the \u0026lsquo;New\u0026rsquo; Teams app (notice the icon in the top left), we have the uploaded backgrounds available as well.\nIf the Teams app is already open when the script runs to download the new backgrounds, they won\u0026rsquo;t be available until the app is closed and re-opened. Summary # It\u0026rsquo;s been a while since I\u0026rsquo;ve had to put together a new Shell script for macOS, but with Microsoft investing more functionality for macOS devices in Microsoft Intune, and with recent updates to the shell-intune-samples GitHub repo, now is a great time to look at how to better manage your macOS device estate using the new tooling and capabilities.\nBeing a personal macOS user, but a professional Windows 11 user, it\u0026rsquo;s a pretty exciting time that Microsoft Intune is providing more and more support for macOS devices at an enterprise level.\nHowever until there is native ability to deploy backgrounds (for free) to your macOS Teams clients, you\u0026rsquo;ll have to rely on people like me spending their spare time writing hacky looking Shell scripts üòÖ.\n","date":"14 February 2024","permalink":"/posts/macos-teams-new-backgrounds/","section":"Blog","summary":"With the availability of the new Microsoft Teams client for macOS, we should build upon an existing script to deploy backgrounds, and update it to support not just the new version but the classic version as well.","title":"Custom Backgrounds for macOS New and Classic Microsoft Teams Apps"},{"content":"","date":"14 February 2024","permalink":"/tags/macos/","section":"Tags","summary":"","title":"macOS"},{"content":"","date":"14 February 2024","permalink":"/tags/teams/","section":"Tags","summary":"","title":"Microsoft Teams"},{"content":"","date":"14 February 2024","permalink":"/tags/shellscript/","section":"Tags","summary":"","title":"Shell Script"},{"content":"Introduction # So we\u0026rsquo;re all onboard with the New Microsoft Store, and deploying both UWP and Win32 apps from Microsoft Intune is an absolute breeze, and reduces the effort of deploying applications to a click click next OK exercise. What about the UWP apps that are already installed on a Windows Autopilot device, shouldn\u0026rsquo;t we give them a bit of love? If you care at all about users and security you should.\nAllowing App Updates # Regardless of how you are blocking or allowing the Microsoft Store, remembering that the store needs to be available to allow for apps from Microsoft Intune to be deployed, we should at least configure devices to allow for updates.\nA simple Settings Catalog profile will do the job here, with the below settings configured.\nArea Item Setting Microsoft App Store Allow apps from the Microsoft app store to auto update Allowed Assign this profile to your devices, all of them obviously, no testing needed here.\nForcing App Updates # There\u0026rsquo;s a lot of chatter about how to force store apps to update, but essentially we can kick off an update using the below Get-CimInstance query.\nGet-CimInstance -Namespace \u0026#34;Root\\cimv2\\mdm\\dmmap\u0026#34; -ClassName \u0026#34;MDM_EnterpriseModernAppManagement_AppManagement01\u0026#34; | Invoke-CimMethod -MethodName UpdateScanMethod Now as we\u0026rsquo;re calling areas that require elevation, standard users are bang out of luck from running this, and even running this elevated as Administrator does absolutely nothing for the apps themselves, something about install context.\nSo what are our options? Well for testing it\u0026rsquo;s PsExec.\nRunning the above from PowerShell running as system using PsExec.exe -s -i powershell.exe, we can kick off the app update query.\nNothing much to look at here, but if you\u0026rsquo;ve got the store open, you should now see updates in the Downloads and Updates section, if you\u0026rsquo;re lazy run start ms-windows-store://downloadsandupdates as a standard user to open the correct area of the store.\nBrilliant, apps are now trying their hardest to update. Now we\u0026rsquo;ve got a method to update the apps, no one is going to run this manually on a regular basis, and we love a Microsoft Intune Remediation.\nRemediation Settings # So now we\u0026rsquo;ve got a way to start the update of the apps, let\u0026rsquo;s find a way to work out if we need to kick off an update. Back to the initial query we created, and if we run the below section of the command, we\u0026rsquo;ll get an output that we might be able to work with.\nGet-CimInstance -Namespace \u0026#34;Root\\cimv2\\mdm\\dmmap\u0026#34; -ClassName \u0026#34;MDM_EnterpriseModernAppManagement_AppManagement01\u0026#34; Guess what, we do, that LastScanError is looking mighty interesting, and it being Microsoft I bet that an exit code of zero means success, but we should have a look at the reference document just in case.\nReports the last error code returned by the update scan.\nThis is a required node.\nOK, so it isn\u0026rsquo;t that clear, but we\u0026rsquo;ve got a way to detect whether the last update of apps was successful, and with the Settings Catalog policy created earlier we should be keeping apps up to date from then on.\nDetection Script # We can use the above, and a little logic to detect whether the result of the LastScanError is a zero or not, and if it\u0026rsquo;s not a zero throw an Exit 1 to allow a remediation to run.\ntry { $wmiObj = Get-CimInstance -Namespace \u0026#34;Root\\cimv2\\mdm\\dmmap\u0026#34; -ClassName \u0026#34;MDM_EnterpriseModernAppManagement_AppManagement01\u0026#34; if ($wmiObj.LastScanError -ne \u0026#39;0\u0026#39;) { Write-Output \u0026#34;Windows Store Apps not updated.\u0026#34; Exit 1 } else { Write-Output \u0026#34;Windows Store Apps updated.\u0026#34; Exit 0 } } catch { Write-Output \u0026#34;Unable to query Store App Update status.\u0026#34; Exit 2000 } On to the remediation portion.\nRemediation Script # We\u0026rsquo;ve already done the ground work with the previous queries to test the update of apps, so this one is very straightforward.\nTry { Get-CimInstance -Namespace \u0026#34;Root\\cimv2\\mdm\\dmmap\u0026#34; -ClassName \u0026#34;MDM_EnterpriseModernAppManagement_AppManagement01\u0026#34; | Invoke-CimMethod -MethodName UpdateScanMethod Write-Output \u0026#34;Windows Store Apps updated.\u0026#34; Exit 0 } Catch { Write-Output \u0026#34;Windows Store Apps not updated.\u0026#34; Exit 2000 } Just make sure we\u0026rsquo;re exiting with the correct codes, and giving an explanation, as per the detection script, of the result of the remediation.\nDeploying the Remediation # We\u0026rsquo;ve seen remediations a handful of times now in this blog, so go ahead and create a new Remediation Script in Microsoft Intune mirroring the below settings. Be aware that we definitely do not want to be running this as the user, we need that glorious system context.\nI\u0026rsquo;ve assigned this to All Devices with my beloved Device Filters on a daily schedule, but if you\u0026rsquo;re more cautious than I am, assign this to a smaller proof-of-concept group.\nAfter a while, you should start seeing the results of the Remediation, and hopefully positive ones to boot.\nIf all goes well, your devices will start actually updating the \u0026lsquo;Built In\u0026rsquo; apps you haven\u0026rsquo;t ripped out with a PowerShell script, and Microsoft Intune UWP store apps you\u0026rsquo;ve deployed, though your users may start complaining about the apps looking like they\u0026rsquo;re loading in the Start Menu üòÇ.\nSummary # All in all a quick and dirty solution to a very simple problem with new Windows Autopilot devices and existing Microsoft Intune managed Windows devices, at least this way they\u0026rsquo;ll do what they should have done in the first place and just keep themselves updated.\nIf only all the issues I encounter during my days could be solved with a simple Remediation script.\nThe detection and remediation scripts are available, as always in my Github Repo. ","date":"6 February 2024","permalink":"/posts/updating-windows-store-apps/","section":"Blog","summary":"Now we all love the new Windows Store, especially for deploying applications from Microsoft Intune, but we should find a way to keep these UWP applications up to date without additional license cost.","title":"Keeping Windows Store Apps Updated with Microsoft Intune"},{"content":"","date":"6 February 2024","permalink":"/tags/powershell/","section":"Tags","summary":"","title":"PowerShell"},{"content":"","date":"6 February 2024","permalink":"/tags/remediation/","section":"Tags","summary":"","title":"Remediation"},{"content":"","date":"6 February 2024","permalink":"/tags/autopilot/","section":"Tags","summary":"","title":"Windows Autopilot"},{"content":"Introduction # If you\u0026rsquo;ve been under a rock, or like me, don\u0026rsquo;t have to manage updates on a Windows device estate any more, chances are you might not have seen the issues with the size of the Windows Recovery Environment or WinRE, partition when applying Windows Updates like KB5034441, luckily Microsoft released a \u0026lsquo;fix\u0026rsquo; for this in KB5028997 to resize the partition to allow for updates to install.\nNow if this were me, I\u0026rsquo;d be looking for a way to push out this fix to the impacted devices, and thanks to u/InternetStranger4You, they created a PowerShell script to do just that, so all credit goes their way.\nSo why I am writing this? Well, let\u0026rsquo;s find a way to use Microsoft Intune Remediations, to detect and fix devices that are falling short of the partition size requirement.\nDetection Methods # To get ourselves in a good position, we should look at a way to detect that the existing Windows Recovery Environment partition is of a suitable size, from this we can either leave it well alone, or hack at it to increase it\u0026rsquo;s size, once, and only once.\nFirst We Detect # Working with the remediation format and capture of information, we can quite simply loop through all physical disks with Get-PhysicalDisk, detecting where one of these disks contains partitions with a \u0026lsquo;C\u0026rsquo; drive (Yes I am assuming here that the disk holding the C drive is holding the Recovery Partition, prove me wrong though), using Get-Partition, and then comparing the size of the disk to our variable in bytes, $partitionSize. and then get the amount of free space available in the volume with Get-Volume, comparing this to our variable for required space $freePartitionSpace.\nThe detection method has been updated to detect free space in the Recovery Partition, instead of blindly increasing it by 250MB. #Recovery Partition free size required for KB5028997 $freePartitionSpace = \u0026#39;250000000\u0026#39; #bytes Try { $computerDisks = Get-PhysicalDisk foreach ($computerDisk in $computerDisks) { $diskPartitions = Get-Partition -DiskNumber $computerDisk.DeviceId -ErrorAction Ignore if ($diskPartitions.DriveLetter -contains \u0026#39;C\u0026#39; -and $null -ne $diskPartitions) { $systemDrive = $computerDisk } } $recPartition = Get-Partition -DiskNumber $systemDrive.DeviceId | Where-Object { $_.Type -eq \u0026#39;Recovery\u0026#39; } $recVolume = Get-Volume -Partition $recPartition if ($recVolume.SizeRemaining -le $freePartitionSpace) { Write-Output \u0026#34;Recovery Partition Free Space $($($recVolume.SizeRemaining) / 1000000) MB is smaller than required $($freePartitionSpace / 1000000) MB\u0026#34; Exit 1 } else { Write-Output \u0026#34;Recovery Partition Free Space $($($recVolume.SizeRemaining) / 1000000) MB is larger than required $($freePartitionSpace / 1000000) MB\u0026#34; Exit 0 } } Catch { Write-Output \u0026#39;Recovery Partition not found.\u0026#39; Exit 2000 } If the result of the comparison is that the size of the partition is smaller than the 750MB configured in $partitionSize free space of the partition is smaller than the 250MB configured in $freePartitionSpace, then we\u0026rsquo;ll report the status with Write-Output and Exit 1, otherwise, all is OK so we Exit 0 still reporting something.\nThen We Report # So, we should see how many devices are effected by a small partition size, so for fun, we can push out just the detection script using a Remediation, but with a non-functioning remediation script. This will at least give you some idea of the devices that would be impacted by the true remediation script.\nI\u0026rsquo;ve assigned this to the All Devices group, but with a Device Filter for only corporate owned devices, set to run once, as we\u0026rsquo;re just reporting on this issue for now.\nAfter waiting a little while, or if you\u0026rsquo;re impatient use the on-demand feature, we can then review the results; we can see several devices that are now complaining that their WinRE partition is too small.\nLuckily for us, there are at least some devices where they are happy with the size of their partition.\nRemediation Methods # As we have a good understanding following the implementation of the report only style Remediation, we can now investigate how best to actually fix the issue. For this, we can take the existing script by u/InternetStranger4You and modifying it to support the required exit codes for Microsoft Intune.\nScript Breakdown # The script itself is taking the manual steps detailed by Microsoft in KB5028997, and wrapping them nicely in PowerShell, but I\u0026rsquo;ll walk through the settings so we\u0026rsquo;re all on the same page.\nEnsures that the script can read the contents of the reagentc.exe command by capture the output of the process using New-Object System.Diagnostics.ProcessStartInfo as the output data is used throughout the script. Checks if there is anything wrong with WinRE with if (($stdout.IndexOf('harddisk') -ne -1) -and ($stdout.IndexOf('partition') -ne -1)), and if so exits. Disables the recovery environment Start-Process 'reagentc.exe' -ArgumentList '/disable' -Wait -NoNewWindow to allow for modification to the partition. Captures information about the Disk the Recovery partition sits on, and the partition itself. Resizes the partition beneath the Recovery partition by 250MB Get-Disk $diskNum | Resize-Partition -PartitionNumber ($recPartNum - 1) -Size ($size - 250MB) Removes the existing Recovery partition aggressively Get-Disk $diskNum | Remove-Partition -PartitionNumber $recPartNum -Confirm:$false Passes the required arguments for DiskPart to a text file \u0026lsquo;ResizeREScript.txt\u0026rsquo; located in $env:TEMP that can be called on later that: Creates a new partition on the disk based on whether the partition style is GPO or MBR Applies the correct attributes to the new partition to configure it as a Recovery partition Formats the partition in NTFS format Finally enabling the recovery agent with Start-Process 'reagentc.exe' -ArgumentList '/enable' -Wait -NoNewWindow to allow for the failing update to be installed. All of these settings are exactly as per the Microsoft provided document, but you know, done for you.\nNow We Attack # To allow the script to work within a Remediation, we need to ensure that the data being passed back to Microsoft Intune is suitable, and other that wrapping the bulk of the script in some Try and Catch logic, and handling the output of the commands with Write-Output and corresponding Exit codes, there isn\u0026rsquo;t a whole heap for us to do thankfully.\nTry { #Run reagentc.exe /info and save the output $pinfo = New-Object System.Diagnostics.ProcessStartInfo $pinfo.FileName = \u0026#39;reagentc.exe\u0026#39; $pinfo.RedirectStandardOutput = $true $pinfo.UseShellExecute = $false $pinfo.Arguments = \u0026#39;/info\u0026#39; $p = New-Object System.Diagnostics.Process $p.StartInfo = $pinfo $p.Start() | Out-Null $p.WaitForExit() $stdout = $p.StandardOutput.ReadToEnd() #Verify that disk and partition are listed in reagentc.exe /info. If blank, then something is wrong with WinRE if (($stdout.IndexOf(\u0026#39;harddisk\u0026#39;) -ne -1) -and ($stdout.IndexOf(\u0026#39;partition\u0026#39;) -ne -1)) { #Disable Windows recovery environment Start-Process \u0026#39;reagentc.exe\u0026#39; -ArgumentList \u0026#39;/disable\u0026#39; -Wait -NoNewWindow #Get recovery disk number and partition number $diskNum = $stdout.substring($stdout.IndexOf(\u0026#39;harddisk\u0026#39;) + 8, 1) $recPartNum = $stdout.substring($stdout.IndexOf(\u0026#39;partition\u0026#39;) + 9, 1) #Resize partition before the recovery partition $size = Get-Disk $diskNum | Get-Partition -PartitionNumber ($recPartNum - 1) | Select-Object -ExpandProperty Size Get-Disk $diskNum | Resize-Partition -PartitionNumber ($recPartNum - 1) -Size ($size - 250MB) #Remove the recovery partition Get-Disk $diskNum | Remove-Partition -PartitionNumber $recPartNum -Confirm:$false #Create new partion with diskpart script $diskpartScriptPath = $env:TEMP $diskpartScriptName = \u0026#39;ResizeREScript.txt\u0026#39; $diskpartScript = $diskpartScriptPath + \u0026#39;\\\u0026#39; + $diskpartScriptName \u0026#34;sel disk $($diskNum)\u0026#34; | Out-File -FilePath $diskpartScript -Encoding utf8 -Force $PartStyle = Get-Disk $diskNum | Select-Object -ExpandProperty PartitionStyle if ($partStyle -eq \u0026#39;GPT\u0026#39;) { #GPT partition commands \u0026#39;create partition primary id=de94bba4-06d1-4d40-a16a-bfd50179d6ac\u0026#39; | Out-File -FilePath $diskpartScript -Encoding utf8 -Append -Force \u0026#39;gpt attributes =0x8000000000000001\u0026#39; | Out-File -FilePath $diskpartScript -Encoding utf8 -Append -Force } else { #MBR partition command \u0026#39;create partition primary id=27\u0026#39; | Out-File -FilePath $diskpartScript -Encoding utf8 -Append -Force } \u0026#34;format quick fs=ntfs label=`\u0026#34;Windows RE tools`\u0026#34;\u0026#34; | Out-File -FilePath $diskpartScript -Encoding utf8 -Append -Force Start-Process \u0026#39;diskpart.exe\u0026#39; -ArgumentList \u0026#34;/s $($diskpartScriptName)\u0026#34; -Wait -NoNewWindow -WorkingDirectory $diskpartScriptPath #Enable the recovery environment Start-Process \u0026#39;reagentc.exe\u0026#39; -ArgumentList \u0026#39;/enable\u0026#39; -Wait -NoNewWindow Write-Output \u0026#39;Recovery Partition Extended Successfully.\u0026#39; Exit 0 } else { Write-Output \u0026#39;Recovery partition not found. Aborting script.\u0026#39; Exit 2000 } } Catch { Write-Output \u0026#39;Unable to update Recovery Partition on the device.\u0026#39; Exit 2000 } With the script now in a more useful format, on to how we deploy this to a select group of test devices.\nDeploying the Remediation # I would strongly advised testing this in small numbers before you go deploying the the All Devices group, and use a new Remediation with the same detection script method as before, but this time with the fully functioning remediation script, so we can actually fix this issue that Microsoft has caused.\nThe Remediation should look something like the below, again with a schedule for once as we don\u0026rsquo;t need this running more than once.\nIf we\u0026rsquo;ve been successful in our deployment we should start seeing device report back the status of the remediation, and advise where there are issues with the size of the WinRE partition.\nFollowing the successful run of the remediation script, we now have an output of the results with a device that had issues with the partition size, now successfully remediated.\nAll is left to do now, is find some more test devices to add to the assignment group, and monitor their progress.\nSummary # In short, this should allow you to get over the hurdle caused by the failing update delivery, and also give the devices with the issue a push in the right direction following the update to their recovery partition size, to allow them to realise they can now install the update. I can\u0026rsquo;t take credit for the scripting of the Microsoft published resolution, that goes to u/InternetStranger4You, but with this and moving it to a Remediation in Microsoft Intune, means that it can do the heavy lifting on your behalf.\nOr you can just wait for Microsoft to release a fix, totally up to you.\nThanks to piotrxj in the comments for the updated detection method.\nI hold no responsibility for the impact to your devices or environments, please, please, please test this on devices you do not care about first before even contemplating pushing this to a wider audience. ","date":"31 January 2024","permalink":"/posts/winre-parition-resize-kb5034441/","section":"Blog","summary":"When Microsoft releases an update that won\u0026rsquo;t install due to the size of a Recovery partition, what do you do? Follow the manual steps provided by Microsoft or blindly follow a script created by a stranger on the internet?","title":"Automatically Resizing the WinRE Partition for Windows Update KB5034441"},{"content":"","date":"10 January 2024","permalink":"/tags/cap/","section":"Tags","summary":"","title":"Conditional Access"},{"content":"","date":"10 January 2024","permalink":"/tags/graph/","section":"Tags","summary":"","title":"Graph API"},{"content":"Introduction # Imagine you\u0026rsquo;ve spent time getting your Windows devices enrolled into Intune, they\u0026rsquo;re all getting Device Compliance policies, and you\u0026rsquo;ve finally pulled the trigger on your shiny new Conditional Access Policy that require device compliance for all your users across Windows devices, and low and behold, you\u0026rsquo;ve broken access to Microsoft 365 authenticated services from your Remote Desktop service environment, or even VDI environments.\nSo what next? Use the trusted location exemption in your policy for the virtual environment? What happens if the public facing address range is the same as your workstation environments or that you\u0026rsquo;d rather not blow a massive hole in security by allowing an entire IP address range free access to Microsoft 365 authenticated services? That\u0026rsquo;s not very Zero Trust of you is it.\nFiltering Devices # Luckily within the the Conditional Access Policy configuration, there is a way to filter devices based on the device object registered with Entra ID, there are some useful native device attributes that can be used as long as your devices have registered in Entra ID (think Hybrid Entra Joined for this VDI environment).\nWhat happens when you can\u0026rsquo;t find a suitable attribute to use that excludes your virtual environment, but still includes your end user computer workstations? The answer here are the attributes extensionAttribute1-15, which are attributes attached only to the Entra ID device object, and not synchronised, and require specific permissions to set using Graph. These seem like a good way to go.\nGetting Attributes # For us to understand how these attributes can be updated or added, we\u0026rsquo;d probably best take a look at how we see the attributes in the first place. Let\u0026rsquo;s start with a device in Entra ID, we can see from the below where these attributes should be:\nCurrently this device has no attributes assigned, shock. We\u0026rsquo;ll need the Object ID in a second, so may as well grab it now.\nWhat about using Graph? We can pull back these attributes by querying the device itself, using a GET to https://graph.microsoft.com/beta/devices/{objectId}/, so for this device the call is https://graph.microsoft.com/beta/devices/492a52d0-ec1a-40ed-8ea5-79f27aa0f8bf/.\nYup still no attributes.\nAdding Attributes # Now that we can see where these attributes reside on the device object in Entra ID, if we\u0026rsquo;re going to be using them as a filtering option in our Conditional Access Policy, we should probably have a look at how we update them.\nPretty straight forward, as it\u0026rsquo;s the device object we\u0026rsquo;re updating, we can create, remove, or replace these attributes using a PATCH to the same Graph endpoint https://graph.microsoft.com/beta/devices/492a52d0-ec1a-40ed-8ea5-79f27aa0f8bf/ using the JSON format in the documentation and like the example below.\n{ \u0026#34;extensionAttributes\u0026#34;: { \u0026#34;extensionAttribute1\u0026#34;: \u0026#34;I\u0026#39;m an Attribute\u0026#34;, \u0026#34;extensionAttribute2\u0026#34;: \u0026#34;I\u0026#39;m also an Attribute\u0026#34; } } Punting the above to the device using Graph Explorer, we get the expected response of {} which is always pleasant, and querying the device object again with a GET, we can now see the attributes updated.\nWe\u0026rsquo;re onto something here.\nUpdating or Removing Attributes # We need to be careful with our PATCH calls to the device object, as they will update the attributes, this means removal and update of existing attributes, you can see using the below example that we can change extensionAttribute1 and just plain remove extensionAttribute2.\n{ \u0026#34;extensionAttributes\u0026#34;: { \u0026#34;extensionAttribute1\u0026#34;: \u0026#34;CAP-00-Out\u0026#34;, \u0026#34;extensionAttribute2\u0026#34;: \u0026#34;\u0026#34; } } Now the device object is an attribute crisis.\nI\u0026rsquo;ve given the attribute a sensible value of CAP-00-Out as we can utilise the range of operators available in the Conditional Access Policy device filter for the attributes.\nFilter for Devices # So now we have a way to essentially tag devices we want to exclude from a Conditional Access Policy, we should look at how we create a device filter, and also explore the fact we can build a naming convention with these \u0026ldquo;tags\u0026rdquo; and utilise the operators available.\nYou have to be careful with filtering within Conditional Access Policies, as there is some level of logic over not only supported operators, but also the attributes that use the operators, and how they are evaluated.\nFor our scenario, we\u0026rsquo;re going to use extensionAttributes which as of today, support the following operators Equals, NotEquals, StartsWith, NotStartsWith, EndsWith, NotEndsWith, Contains, NotContains, In, NotIn\nSo building a quick query in the policy, we can exclude devices where extensionAttribute1 equals CAP-00-Out.\nOr if we want to be clever and capture devices where where extensionAttribute1 ends in Out regardless of the other content.\nSo there is value in coming up with good naming conventions across all areas of Entra ID and Microsoft Intune, who knew?\nFiltering in Action # Having created a Conditional Access Policy in Report-only mode to Require device to be marked as compliant or Require Microsoft Entra hybrid joined device on Windows device platforms, with the filter to exclude devices matching device.extensionAttribute1 -eq \u0026quot;CAP-00-Out\u0026quot;, we can see in the sign in logs for the user in scope of the policy, when accessing Microsoft 365 authenticated resources, that they are not subject to the policy.\nWhich for our situation is exactly the outcome we\u0026rsquo;re after. Now time to make this less of a manual process.\nPowerShell and Graph # I\u0026rsquo;ll assume you\u0026rsquo;re familiar with authenticating to Graph, and this time instead of the trusty MSAL.PS module I\u0026rsquo;m using Microsoft the native commands, ikr, shocking. Now that we\u0026rsquo;re connected to Graph with the required scope options using Connect-MgGraph -Scopes 'Device.ReadWrite.All', we need to be able to pull back all the devices we want to assign an attribute to.\nGetting Devices # Who knew that when working in non-development tenants that you\u0026rsquo;d have to consider pagination, so yeah, I had to throw something together to pull back all Entra ID device objects using the very same Graph endpoint we used earlier to look at a single device https://graph.microsoft.com/beta/devices/ and the Invoke-MgGraphRequest command.\nFunction Get-DeviceAAD() { $graphApiVersion = \u0026#39;beta\u0026#39; $Resource = \u0026#39;devices\u0026#39; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource\u0026#34; $GraphResults = Invoke-MgGraphRequest -Method GET -Uri $uri $Results = @() $Results += $GraphResults.value $Pages = $GraphResults.\u0026#39;@odata.nextLink\u0026#39; while ($null -ne $Pages) { $Additional = Invoke-MgGraphRequest -Method GET -Uri $Pages if ($Pages) { $Pages = $Additional.\u0026#39;@odata.nextLink\u0026#39; } $Results += $Additional.value } $Results } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } For the pagination, we\u0026rsquo;re capturing the results of the web request into an array variable $Results, and looping through the @odata.nextLink data with a subsequent Graph calls, adding each result back into the same array variable until there are no more results. Simple right?\nRunning this will allow us to pull back all Entra ID device objects, and with the below we can present them in a table using Out-GridView.\n$Devices = @(Get-DeviceAAD | Select-Object displayName, operatingSystem, manufacturer, model, id, deviceId | Out-GridView -PassThru -Title \u0026#39;Select Devices to update extension attributes...\u0026#39;) Allowing the selection of the devices that need their extension attributes updating, and importantly the id of the device object used to update the attribute.\nExtension Attribute JSON # The JSON content we can build from another Out-GridView prompt, with some logic so that you only select a single extension Attribute to update, and we can pass that selection using $Attribute and a simple Read-Host to prompt for the value of the attribute itself, added to the $attributeValue variable into the JSON format needed to update the extension attributes.\n$extensionAttributes = @() for ($i = 1; $i -le 15; $i++) { $extensionAttributes += \u0026#39;extensionAttribute\u0026#39; + $i } $Attribute = @($extensionAttributes | Out-GridView -PassThru -Title \u0026#39;Select only one attribute you wish to update...\u0026#39;) while ($Attribute.count -gt 1) { Write-Host \u0026#39;Only select one attribute to update...\u0026#39; -ForegroundColor Yellow $Attribute = @($extensionAttributes | Out-GridView -PassThru -Title \u0026#39;Select only one attribute you wish to update...\u0026#39;) } With the data required now captured, we can build the JSON that can be passed to the device object Graph endpoint to update the required data.\n$JSON = @\u0026#34; { \u0026#34;extensionAttributes\u0026#34;: { \u0026#34;$Attribute\u0026#34;: \u0026#34;$attributeValue\u0026#34; } } \u0026#34;@ Running these PowerShell sections in isolation we get a JSON output similar to the below:\n{ \u0026#34;extensionAttributes\u0026#34;: { \u0026#34;extensionAttribute1\u0026#34;: \u0026#34;CAP-00-Out\u0026#34; } } Giving us the required data and attribute value to update the device object, now we just need a function to do this.\nUpdating Attributes Function # With the device or devices now at our disposable, including the Id we used earlier in Graph Explorer, we could do with a function to update the device with the new extension attribute value, handing over the JSON content we created that is required to update the object.\nFunction Add-DeviceAttribute() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] $JSON, [parameter(Mandatory = $true)] $deviceID ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;devices/$deviceID\u0026#34; try { Test-Json -Json $JSON $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-MgGraphRequest -Uri $uri -Method Patch -Body $JSON -ContentType \u0026#39;application/json\u0026#39; } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Now we can run the below passing in the device object id and the JSON content to update the device attributes.\nforeach ($device in $devices){ Add-DeviceAttribute -deviceID $device.id -JSON $JSON } Bulk Updating Device Attributes # Now we have all the component parts, we can build the full script giving us an option with Mode and options Update and Remove to choose whether we want to update attributes, or remove them.\nRemoving Attributes # We should probably run this a couple of times to show what the script can do, we\u0026rsquo;ll start with removing the data in an attribute using the below.\n./Invoke-DeviceExtensionAttributes.ps1 -Mode Remove Taking our existing device PHXNB-695630804 we used and manually added attributes to, we can clear our original data in extensionAttribute1.\nSelecting the device when prompted.\nSelecting the attribute we want to clear.\nConfirming we want to continue.\nNow we can check the device in Entra ID and confirm that the attribute has now been cleared.\nNow that we\u0026rsquo;ve got a blank canvas, let\u0026rsquo;s update some device objects with a new extension attribute value.\nUpdating Attributes # We can now run the script again, but with the Update option, and start tagging multiple devices at once.\n./Invoke-DeviceExtensionAttributes.ps1 -Mode Update This time we\u0026rsquo;re asked to enter in the value of the attribute, here entering CAP-00-Out\nSelecting a handful of devices when prompted.\nSelecting the attribute we want to update.\nThis warning section now shows how many devices, the attribute extension to be updated and the new value.\nConfirming we want to continue, the devices have now been updated with the CAP-00-Out in extensionAttribute1.\nChecking a device in Entra ID gives us exactly the result we want.\nTake my word for it that the other five devices have updated too üòÖ.\nSummary # This may seem like a simple script, and honestly it is, but the application of the script, to allow for tagging of extension attributes by privileged accounts only, on Entra ID device objects, that are not overwritten by directory sync for hybrid joined Windows devices, changes to device operating system version etc. for all device objects, gives us two major bits of functionality:\nConditional Access Policy inclusion or exclusion Dynamic Security Groups Our use case was for exclusion of Conditional Access Policies, but with the dynamic security group option, the possibilities for tagging device objects in this way and grouping them becomes almost endless, want to group devices for specific configuration in Microsoft Intune? Yup. Want to group devices for specific application deployments in Microsoft Intune? Also yup. Want to exclude groups of devices from Microsoft Intune profiles for some reason where existing Entra ID attributes or Device Filters don\u0026rsquo;t cut it, this one too.\nWhat we have created here is at least a method for the assignment of these tags, what you can do is take this and apply it to your own requirements, hopefully making the management of devices a little more straight forward.\n","date":"10 January 2024","permalink":"/posts/device-attributes-cap/","section":"Blog","summary":"So you like Intune Device Compliance and the integration with Conditional Access, what about if you\u0026rsquo;ve got VDI or Remote Desktop infrastructure that you want to exclude from specific policies, how do you go about that in a safe and controlled way.","title":"Using Entra ID Device Attributes for Conditional Access Exceptions"},{"content":"Introduction # If you\u0026rsquo;ve ever experienced the joys of migrating Group Policy and in particular Windows Defender Firewall rules away from Group Policy to Microsoft Intune, you\u0026rsquo;ve probably encountered the Rule Migration Tool, and for now this tool has worked well, beavering away grabbing firewall rules from a source Windows 10 or later device and punting them straight in Microsoft Intune. So what\u0026rsquo;s the catch?\nWell with the move to Settings Catalog based policies all over the shop in Microsoft Intune, and the advent of Reusable Settings for Defender Firewall Rules, these \u0026ldquo;legacy\u0026rdquo; Endpoint Security Defender Firewall Rule profiles don\u0026rsquo;t support the new world, so how do we fix that?\nIt\u0026rsquo;s obviously PowerShell and Graph, you should know this by now.\nGetting Firewall Rule Profiles # I haven\u0026rsquo;t had time to update my fork of the Rule Migration Tool to support Settings Catalog policies just yet, so instead of focusing on capturing new rules, let\u0026rsquo;s look at how we get the rules from existing Endpoint Security profiles. I\u0026rsquo;ve worked long enough on bodging together my own PowerShell functions that I can pull back existing profiles and the data, so let\u0026rsquo;s do that first to see what we\u0026rsquo;re working with, as we\u0026rsquo;ll need to translate these existing rules into the new format.\nOnce we\u0026rsquo;ve authenticated to Graph in the usual manner, and using the functions below to get the Endpoint Security profiles, Endpoint Security Templates and Endpoint Security Categories and finally each setting within the profile we can put all the existing rules into a variable that we can work with.\nEndpoint Security Profile # This function will get all Endpoint Security profiles, or a specific profile by either Id or Name. We\u0026rsquo;ll need this to get the profiles that contains all the firewall rules we want to migrate.\nFunction Get-DeviceEndpointSecProfile() { [cmdletbinding()] param ( [Parameter(Mandatory = $false)] $Name, [Parameter(Mandatory = $false)] $Id ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#39;deviceManagement/intents\u0026#39; try { if ($Id) { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource/$Id\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get } elseif ($Name) { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value | Where-Object { ($_.displayName).contains(\u0026#34;$Name\u0026#34;) } } Else { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Method Get -Uri $uri -Headers $authToken).value } } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Endpoint Security Templates # As Endpoint Security profiles are a little more complicated that other profiles in Microsoft Intune, and rely on underpinning templates, we also have to get the template being used by the profile itself. We can pass the templateId captured from an Endpoint Security Profile using the above function into the Id parameter in the below function.\nFunction Get-DeviceEndpointSecTemplate() { [cmdletbinding()] param ( [Parameter(Mandatory = $false)] $Name, [Parameter(Mandatory = $false)] $Id ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceManagement/templates?`$filter=(isof(%27microsoft.graph.securityBaselineTemplate%27))\u0026#34; try { if ($Id) { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource/$Id\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get } elseif ($Name) { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value | Where-Object { ($_.displayName).contains(\u0026#34;$Name\u0026#34;) } } Else { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Method Get -Uri $uri -Headers $authToken).value } } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Endpoint Security Template Categories # Lastly, we now need to be able to get all the Endpoint Security categories that are assigned to the template allowing us to extract the actual content of the profile, and using the function above, we can get all the categories for the template by taking the id of the Endpoint Security Template, looping through each category in the template, and finally being able to extract the data we need.\nAll of this makes me glad that Settings Catalog profiles are being used more and more in Microsoft Intune.\nFunction Get-DeviceEndpointSecCategorySetting() { [cmdletbinding()] param ( [Parameter(Mandatory = $true)] $Id, [Parameter(Mandatory = $true)] $categoryId ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceManagement/intents/$Id/categories/$categoryId/settings?`$expand=Microsoft.Graph.DeviceManagementComplexSettingInstance/Value\u0026#34; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Method Get -Uri $uri -Headers $authToken).value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Capturing Firewall Rules # Using existing legacy Endpoint Security Firewall Rule profiles in a tenant, we just need to know their names so we can pass them into an array variable, so we can use the below profile names as examples.\nAdding them into an array so we can loop through each one of them, and extract the needed data.\n$FirewallPolicies = @(\u0026#39;LegacyRules-0\u0026#39;, \u0026#39;LegacyRules-1\u0026#39;,\u0026#39;LegacyRules-2\u0026#39;, \u0026#39;LegacyRules-3\u0026#39;) Using the Endpoint Security functions we can now process each of the profiles and rip out all the rules into a useable format using a new array variable $FWRules.\n$FWRules = @() foreach ($FirewallPolicy in $FirewallPolicies) { $EndpointSecProfile = Get-DeviceEndpointSecProfile -Name $FirewallPolicy $EndpointSecTemplates = Get-DeviceEndpointSecTemplate $EndpointSecTemplate = $EndpointSecTemplates | Where-Object { $_.id -eq $EndpointSecProfile.templateId } $EndpointSecCategories = Get-DeviceEndpointSecTemplateCategory -Id $EndpointSecTemplate.id foreach ($EndpointSecCategory in $EndpointSecCategories) { $EndpointSecSettings = Get-DeviceEndpointSecCategorySetting -Id $EndpointSecProfile.id -categoryId $EndpointSecCategories.id $FWRules += $EndpointSecSettings.valueJson | ConvertFrom-Json } } With these we now have the $FWRules array of Firewall Rules captured from the existing profiles similar to the below.\ndisplayName : NVIDIA SHIELD Streaming SSAS UDP Exception description : UDP exceptions for NVIDIA SHIELD Streaming SSAS (mDNS) trafficDirection : in action : allowed profileTypes : {notConfigured} packageFamilyName : filePath : C:\\Program Files\\NVIDIA Corporation\\NvContainer\\nvcontainer.exe serviceName : protocol : 17 localPortRanges : {5353} remotePortRanges : {} interfaceTypes : {notConfigured} localUserAuthorizations : useAnyLocalAddressRange : True actualLocalAddressRanges : {} useAnyRemoteAddressRange : True actualRemoteAddressRanges : {} displayName : BlueStacks Service Hyper-V description : trafficDirection : in action : allowed profileTypes : {notConfigured} packageFamilyName : filePath : serviceName : protocol : 6 localPortRanges : {2860-2892} remotePortRanges : {} interfaceTypes : {notConfigured} localUserAuthorizations : useAnyLocalAddressRange : True actualLocalAddressRanges : {} useAnyRemoteAddressRange : False actualRemoteAddressRanges : {172.31.224.0/255.255.240.0} We now have the data we need to start building firewall rules in the new Setting Catalog format. Surely it get\u0026rsquo;s easier, (hint: it doesn\u0026rsquo;t).\nCreating Firewall Rules # We now have the information from the existing legacy profiles allowing us to create rules in the Settings Catalog policy format, so we should process each of the rules we\u0026rsquo;ve captured and pass the data into reusable variables in preparation for building the JSON structure.\nFirewall Rule Grouping # One thing I didn\u0026rsquo;t expect is that Settings Catalog policies, for Firewall rules at least, have a maximum number of rules, 100 in fact. Compared with the legacy profiles maximum of 150, we\u0026rsquo;re going to have to split out the rules in $FWRules into 100 rule groups to allow us to add them to a single policy.\n$counter = [pscustomobject] @{ Value = 0 } $groupSize = 100 $FWRuleGroups = $FWRules | Group-Object -Property { [math]::Floor($counter.Value++ / $groupSize) } With the above, we can ensure that we are breaking the rules into 100 rule sections that we can then reference using the $FWRuleGroups variable when building the new policies.\nCount Name Group ----- ---- ----- 100 0 {@{displayName=Wi-Fi Direct Spooler Use (Out); description=Outbound rule to use WSD printers on Wi-Fi Direct networks.; trafficDirection=out; 100 1 {@{displayName=Network Discovery (SSDP-In); description=Inbound rule for Network Discovery to allow use of the Simple Service Discovery Protocol. [UDP 100 2 {@{displayName=teams.exe; description=; trafficDirection=in; action=allowed; profileTypes=System.Object[]; packageFamilyName=; 100 3 {@{displayName=Microsoft Sync Center; description=Microsoft Sync Center; trafficDirection=in; action=allowed; profileTypes=System.Object[]; 63 4 {@{displayName=Microsoft Office Outlook; description=; trafficDirection=in; action=allowed; profileTypes=System.Object[]; packageFamilyName=; These groups can now be used to create separate Settings Catalog policies.\nDuplicate Rule Names # So for each of these rule groups in the $FWRuleGroups variable, we need to take each rule and extract the data, adding it to a variable that we can reference later, as well as one important different between the legacy and the new profiles\u0026hellip;we can\u0026rsquo;t have duplicate rule names. Yeah this one bit me in the arse pretty hard during testing, and I can tell you now I have thrown in a very quick fix for this using a counter in the form of the $RuleNameCount variable.\nforeach ($FWRuleGroup in $FWRuleGroups) { $Rules = $FWRuleGroup.Group $RuleNameCount = 0 foreach ($Rule in $Rules) { # Capturing existing rules with duplicate names, as Settings Catalog will not allow duplicates $DuplicateNames = $Rules.displayName | Group-Object | Where-Object { $_.count -gt 1 } $Name = $Rule.displayName if ($DuplicateNames.name -contains $Name) { $Name = $Name + \u0026#39;-\u0026#39; + $RuleNameCount++ } } } This isn\u0026rsquo;t the cleanest, but at least it gets us over the line with making sure every rule has a unique name. As you can see from the below, in just one of the groups we have a number of duplicates.\nCount Name Group ----- ---- ----- 2 App Installer {App Installer, App Installer} 7 Captive Portal Flow {Captive Portal Flow, Captive Portal Flow, Captive Portal Flow, Captive Portal Flow‚Ä¶} 2 Company Portal {Company Portal, Company Portal} 2 Dell SupportAssist for H‚Ä¶ {Dell SupportAssist for Home PCs, Dell SupportAssist for Home PCs} 2 Microsoft Edge {Microsoft Edge, Microsoft Edge} 3 Microsoft Edge (mDNS-In) {Microsoft Edge (mDNS-In), Microsoft Edge (mDNS-In), Microsoft Edge (mDNS-In)} 2 Microsoft Sticky Notes {Microsoft Sticky Notes, Microsoft Sticky Notes} 2 Microsoft Store {Microsoft Store, Microsoft Store} 2 Microsoft To Do {Microsoft To Do, Microsoft To Do} 4 VMware Remote MKS {VMware Remote MKS, VMware Remote MKS, VMware Remote MKS, VMware Remote MKS} 23 Windows Feature Experien‚Ä¶ {Windows Feature Experience Pack, Windows Feature Experience Pack, Windows Feature Experience Pack, Windows Feature Experience Pack‚Ä¶} Rule Processing # On to how we capture the rest of the rule settings, and you may have noticed that not every rule will have every setting, for good reason, but we need to ensure that for each rule processed we\u0026rsquo;re not taking through data from the previous rule, so we can update the code snippet above to capture the data into variables, but clear them out before we do so.\nforeach ($FWRuleGroup in $FWRuleGroups) { $Rules = $FWRuleGroup.Group $RuleNameCount = 0 foreach ($Rule in $Rules) { Clear-Variable -Name (\u0026#39;Name\u0026#39;, \u0026#39;Description\u0026#39;, \u0026#39;Direction\u0026#39;, \u0026#39;Action\u0026#39;, \u0026#39;FWProfiles\u0026#39;, \u0026#39;PackageFamilyName\u0026#39;, \u0026#39;FilePath\u0026#39;, \u0026#39;Service\u0026#39;, \u0026#39;Protocol\u0026#39;, \u0026#39;LocalPorts\u0026#39;, \u0026#39;RemotePorts\u0026#39;, \u0026#39;Interfaces\u0026#39;, \u0026#39;UseAnyLocalAddresses\u0026#39;, \u0026#39;LocalAddresses\u0026#39;, \u0026#39;UseAnyRemoteAddresses\u0026#39;, \u0026#39;RemoteAddresses\u0026#39;) -ErrorAction Ignore # Capturing existing rules with duplicate names, as Settings Catalog will not allow duplicates $DuplicateNames = $Rules.displayName | Group-Object | Where-Object { $_.count -gt 1 } $Name = $Rule.displayName if ($DuplicateNames.name -contains $Name) { $Name = $Name + \u0026#39;-\u0026#39; + $RuleNameCount++ } $Description = $Rule.description $Direction = $Rule.trafficDirection $Action = $Rule.action $FWProfiles = $Rule.profileTypes $PackageFamilyName = $Rule.packageFamilyName $FilePath = ($Rule.filePath).Replace(\u0026#39;\\\u0026#39;, \u0026#39;\\\\\u0026#39;) $Service = $Rule.serviceName $Protocol = $Rule.protocol $LocalPorts = $Rule.localPortRanges $RemotePorts = $Rule.remotePortRanges $Interfaces = $Rule.interfaceTypes $AuthUsers = $Rule.localUserAuthorizations $UseAnyLocalAddresses = $Rule.useAnyLocalAddressRange $LocalAddresses = $Rule.actualLocalAddressRanges $UseAnyRemoteAddresses = $Rule.useAnyRemoteAddressRange $RemoteAddresses = $Rule.actualRemoteAddressRanges } } We now have the information from the existing rules to create new ones. Now to the fun part of JSON formatting.\nCreating Settings Catalog Policies # Luckily we have experience creating Settings Catalog policies, and have a good grasp of the JSON formatting required not just for the policy itself, but also for the settings contained within, with the first setting having differing JSON formatting structure and data compared with all subsequent settings. So I had at least an idea on how to build the JSON data to throw it at Microsoft Intune.\nBuilding the Policy # With the rules in neat little groups, and with all the variables in place, we can loop through each of them to create individual Settings Catalog policies, we need to make sure that each policy has a unique name, so we can just take an existing $PolicyName variable and append the group name to it, as these are sequential numbers, giving us something like COPE_FW_RulesMigrated-0, COPE_FW_RulesMigrated-1, COPE_FW_RulesMigrated-2, COPE_FW_RulesMigrated-3, COPE_FW_RulesMigrated-4 for the five groups we have in our example.\nEach Settings Catalog Policy starts and ends with the same JSON data structure, so we can top and tail each policy with these new variables $JSONPolicyStart and $JSONPolicyEnd, passing in the $NewPolicyName and $PolicyDescription.\nforeach ($FWRuleGroup in $FWRuleGroups) { $NewPolicyName = $PolicyName + \u0026#39;-\u0026#39; + $FWRuleGroup.Name $PolicyDescription = \u0026#39;Migrated Firewall Rules Policy\u0026#39; $JSONPolicyStart = @\u0026#34; { \u0026#34;description\u0026#34;: \u0026#34;$PolicyDescription\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;$NewPolicyName\u0026#34;, \u0026#34;platforms\u0026#34;: \u0026#34;windows10\u0026#34;, \u0026#34;technologies@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationTechnologies\u0026#34;, \u0026#34;technologies\u0026#34;: \u0026#34;mdm,microsoftSense\u0026#34;, \u0026#34;templateReference\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationPolicyTemplateReference\u0026#34;, \u0026#34;templateId\u0026#34;: \u0026#34;19c8aa67-f286-4861-9aa0-f23541d31680_1\u0026#34;, \u0026#34;templateFamily@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationTemplateFamily\u0026#34;, \u0026#34;templateFamily\u0026#34;: \u0026#34;endpointSecurityFirewall\u0026#34;, \u0026#34;templateDisplayName\u0026#34;: \u0026#34;Microsoft Defender Firewall Rules\u0026#34;, \u0026#34;templateDisplayVersion\u0026#34;: \u0026#34;Version 1\u0026#34; }, \u0026#34;settings\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSetting\u0026#34;, \u0026#34;settingInstance\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationGroupSettingCollectionInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;vendor_msft_firewall_mdmstore_firewallrules_{firewallrulename}\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference\u0026#34;, \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;76c7a8be-67d2-44bf-81a5-38c94926b1a1\u0026#34; }, \u0026#34;groupSettingCollectionValue@odata.type\u0026#34;: \u0026#34;#Collection(microsoft.graph.deviceManagementConfigurationGroupSettingValue)\u0026#34;, \u0026#34;groupSettingCollectionValue\u0026#34;: [ \u0026#34;@ $JSONPolicyEnd = @\u0026#39; ] } } ] } \u0026#39;@ } This was the easy part of the process, we now need to focus on the rules themselves.\nBuilding the Rules # As I\u0026rsquo;ve mentioned before, the initial rule in each policy has different JSON structure and data than the rest, so we can reuse our previous way of dealing this checking whether the rule is the first in the array.\nif ($Rule -eq $Rules[0]) { ... } else { ... } On top of this we need to build in logic to only add in JSON data when the rule requires it. Now there are a lot of potentials with each rule, but there are some consistencies across them all which we can look at now, the rest, well you can have a gander at the full script.\nThe start of each rule is the same, which is kind of Microsoft.\n$JSONRuleStart = @\u0026#39; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationGroupSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;children@odata.type\u0026#34;: \u0026#34;#Collection(microsoft.graph.deviceManagementConfigurationSettingInstance)\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#39;@ But that\u0026rsquo;s it for niceties, each of the options for every rule has different formatting, let\u0026rsquo;s look at comparing just the JSON data for the name of the rule.\nJSON Differences # The first rule in the policy has additional content, mainly in the settingValueTemplateId sections across each object.\n$JSONRuleName = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;vendor_msft_firewall_mdmstore_firewallrules_{firewallrulename}_name\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference\u0026#34;, \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;116a696a-3270-493e-9938-c336cf05ea98\u0026#34; }, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$Name\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSettingValueTemplateReference\u0026#34;, \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;12994a33-6185-4c3d-a0e8-69316f6293ea\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false } } }, \u0026#34;@ Compared with each subsequent Rule name, where the JSON doesn\u0026rsquo;t need the settingValueTemplateId and other sections.\n$JSONRuleName = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;vendor_msft_firewall_mdmstore_firewallrules_{firewallrulename}_name\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;$Name\u0026#34; } }, \u0026#34;@ You get the idea, now imagine spending half a day reviewing and comparing JSON for each of the potential options in the rule, I can\u0026rsquo;t say it was an enjoyable time, but here we are.\nBringing the above together, we\u0026rsquo;ll get something like the below.\nif ($Rule -eq $Rules[0]) { $JSONRuleName = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;vendor_msft_firewall_mdmstore_firewallrules_{firewallrulename}_name\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference\u0026#34;, \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;116a696a-3270-493e-9938-c336cf05ea98\u0026#34; }, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$Name\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSettingValueTemplateReference\u0026#34;, \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;12994a33-6185-4c3d-a0e8-69316f6293ea\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false } } }, \u0026#34;@ } else { $JSONRuleName = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;vendor_msft_firewall_mdmstore_firewallrules_{firewallrulename}_name\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;$Name\u0026#34; } }, \u0026#34;@ } Completing the Policy # With the JSON data for all our rule(s) now in place, or at least hopefully, we need to combine all the $JSONRule* variables per rule into a new variable $JSONRule, and the add that rule to a new array variable $JSONAllRules that can be used to build the full Settings Catalog policy.\n$JSONAllRules = @() ... $JSONRule = $JSONRuleStart + $JSONRuleName + $JSONRuleState + $JSONRuleDirection + $JSONRuleProtocol + $JSONRuleLocalAddressRange + $JSONRuleInterface + $JSONRulePackageFamily + $JSONRuleFilePath + $JSONRuleAuthUsers + $JSONRuleRemotePorts + $JSONRuleFWProfile + $JSONRuleService + $JSONRuleLocalPorts + $JSONRuleRemoteAddressRange + $JSONRuleAction + $JSONRuleDescription + $JSONRuleEnd $JSONAllRules += $JSONRule Now we have the start of the policy, the end of the policy, and the middle bit containing all the rules, we can combine them into one mega-JSON variable.\n$JSONPolicy = $JSONPolicyStart + $JSONAllRules + $JSONPolicyEnd And using the function below, we can send this to Graph and create ourselves a new Settings Catalog policy.\nFunction New-DeviceSettingsCatalog() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] $JSON ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#39;deviceManagement/configurationPolicies\u0026#39; try { Test-Json -Json $JSON $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Post -Body $JSON -ContentType \u0026#39;application/json\u0026#39; } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Which looks something like this.\nNew-DeviceSettingsCatalog -JSON $JSONPolicy With, if all went well, the response below.\n@odata.context : https://graph.microsoft.com/beta/$metadata#deviceManagement/configurationPolicies/$entity id : b9ae4e1f-7f78-4506-8520-aa7919f06a73 name : COPE_FW_RulesMigrated-4 description : Migrated Firewall Rules Policy platforms : windows10 technologies : mdm,microsoftSense createdDateTime : 14/09/2023 09:33:27 lastModifiedDateTime : 14/09/2023 09:33:27 settingCount : 1 creationSource : roleScopeTagIds : {0} priorityMetaData : templateReference : @{templateId=19c8aa67-f286-4861-9aa0-f23541d31680_1; templateFamily=endpointSecurityFirewall; templateDisplayName=Microsoft Defender Firewall Rules; templateDisplayVersion=Version 1} This looks pretty good if I do say so myself.\nRunning the Script # The full script which let\u0026rsquo;s be honest, is what you\u0026rsquo;re after, can be run using the below command, passing in the required variables for User, PolicyName, and FirewallPolicies\n./Invoke-ConvertFirewallRules.ps1 -User \u0026#34;yourGAaccount@you.onmicrosoft.com\u0026#34; -PolicyName \u0026#34;COPE_FW_RulesMigrated\u0026#34; -FirewallPolicies \u0026#34;LegacyRules-0\u0026#34;, \u0026#34;LegacyRules-1\u0026#34;, \u0026#34;LegacyRules-2\u0026#34;, \u0026#34;LegacyRules-3\u0026#34; After authenticated to Graph, this will give us the below output having successfully created the new Settings Catalog policies.\nFound Legacy Firewall Rule Profile LegacyRules-0 Found Legacy Firewall Rule Profile LegacyRules-1 Found Legacy Firewall Rule Profile LegacyRules-2 Found Legacy Firewall Rule Profile LegacyRules-3 Captured 463 rules from the provided legacy Endpoint Security Firewall Rules profiles. Creating new Settings Catalog Policy COPE_FW_RulesMigrated-0 @odata.context : https://graph.microsoft.com/beta/$metadata#deviceManagement/configurationPolicies/$entity id : 14c02164-36ce-446f-9101-90c833ee441e name : COPE_FW_RulesMigrated-0 description : Migrated Firewall Rules Policy platforms : windows10 technologies : mdm,microsoftSense createdDateTime : 14/09/2023 09:40:30 lastModifiedDateTime : 14/09/2023 09:40:30 settingCount : 1 creationSource : roleScopeTagIds : {0} priorityMetaData : templateReference : @{templateId=19c8aa67-f286-4861-9aa0-f23541d31680_1; templateFamily=endpointSecurityFirewall; templateDisplayName=Microsoft Defender Firewall Rules; templateDisplayVersion=Version 1} Successfully created new Settings Catalog Policy COPE_FW_RulesMigrated-0 Creating new Settings Catalog Policy COPE_FW_RulesMigrated-1 @odata.context : https://graph.microsoft.com/beta/$metadata#deviceManagement/configurationPolicies/$entity id : 213957bd-2bc1-4103-af59-25e406894213 name : COPE_FW_RulesMigrated-1 description : Migrated Firewall Rules Policy platforms : windows10 technologies : mdm,microsoftSense createdDateTime : 14/09/2023 09:40:31 lastModifiedDateTime : 14/09/2023 09:40:31 settingCount : 1 creationSource : roleScopeTagIds : {0} priorityMetaData : templateReference : @{templateId=19c8aa67-f286-4861-9aa0-f23541d31680_1; templateFamily=endpointSecurityFirewall; templateDisplayName=Microsoft Defender Firewall Rules; templateDisplayVersion=Version 1} Successfully created new Settings Catalog Policy COPE_FW_RulesMigrated-1 Creating new Settings Catalog Policy COPE_FW_RulesMigrated-2 @odata.context : https://graph.microsoft.com/beta/$metadata#deviceManagement/configurationPolicies/$entity id : 8eade932-9563-4cc5-b24e-9b478f98cebe name : COPE_FW_RulesMigrated-2 description : Migrated Firewall Rules Policy platforms : windows10 technologies : mdm,microsoftSense createdDateTime : 14/09/2023 09:40:33 lastModifiedDateTime : 14/09/2023 09:40:33 settingCount : 1 creationSource : roleScopeTagIds : {0} priorityMetaData : templateReference : @{templateId=19c8aa67-f286-4861-9aa0-f23541d31680_1; templateFamily=endpointSecurityFirewall; templateDisplayName=Microsoft Defender Firewall Rules; templateDisplayVersion=Version 1} Successfully created new Settings Catalog Policy COPE_FW_RulesMigrated-2 Creating new Settings Catalog Policy COPE_FW_RulesMigrated-3 @odata.context : https://graph.microsoft.com/beta/$metadata#deviceManagement/configurationPolicies/$entity id : 9723ffd1-198e-4b96-8572-668e16c8dbda name : COPE_FW_RulesMigrated-3 description : Migrated Firewall Rules Policy platforms : windows10 technologies : mdm,microsoftSense createdDateTime : 14/09/2023 09:40:34 lastModifiedDateTime : 14/09/2023 09:40:34 settingCount : 1 creationSource : roleScopeTagIds : {0} priorityMetaData : templateReference : @{templateId=19c8aa67-f286-4861-9aa0-f23541d31680_1; templateFamily=endpointSecurityFirewall; templateDisplayName=Microsoft Defender Firewall Rules; templateDisplayVersion=Version 1} Successfully created new Settings Catalog Policy COPE_FW_RulesMigrated-3 Creating new Settings Catalog Policy COPE_FW_RulesMigrated-4 @odata.context : https://graph.microsoft.com/beta/$metadata#deviceManagement/configurationPolicies/$entity id : a82b554f-34a9-4f1c-bc46-05e1d399e255 name : COPE_FW_RulesMigrated-4 description : Migrated Firewall Rules Policy platforms : windows10 technologies : mdm,microsoftSense createdDateTime : 14/09/2023 09:40:35 lastModifiedDateTime : 14/09/2023 09:40:35 settingCount : 1 creationSource : roleScopeTagIds : {0} priorityMetaData : templateReference : @{templateId=19c8aa67-f286-4861-9aa0-f23541d31680_1; templateFamily=endpointSecurityFirewall; templateDisplayName=Microsoft Defender Firewall Rules; templateDisplayVersion=Version 1} Successfully created new Settings Catalog Policy COPE_FW_RulesMigrated-4 I\u0026rsquo;d call that a win in my books.\nComparing Profiles to Policies # Checking in Microsoft Intune we should have five new policies that contain the same rules as the legacy profiles. With the new rules having the supplied name prefix, and using the updated policies.\nThe clue is the \u0026lsquo;Target\u0026rsquo; being mdm,microsoftSense not just mdm Let\u0026rsquo;s have a gander at comparing the rules between the profiles, with the old profile looking like the below with the rule detail.\nAnd the new policy looking pretty damn good.\nI think we\u0026rsquo;re done.\nSummary # This, and the script, as usual all came about from improving a Customers Microsoft Intune environment. The customer being very security focussed was blocking legitimately everything inbound and outbound unless there was a firewall rule; this included all Microsoft 365 endpoints.\nWith their existing rules in legacy profiles, they had to have rules with all the IP addresses for these Microsoft endpoints, and keep these up-to-date across multiple profiles.\nThis obviously wasn\u0026rsquo;t ideal, and with the advent of the reusable settings and the auto discovery of addresses and domains for firewall rules in Settings Catalog policies, allowed for more confidence in the rules, a reduced maintenance overhead, and you know, new stuff is cool.\nThere is still a scenario I need to look at, and I mentioned that at the start, looking at the original Microsoft Rule Migration Tool and getting that to create Settings Catalog policies instead of the legacy format, but that is one for a very very rainy day.\n","date":"12 September 2023","permalink":"/posts/settings-catalog-firewall-rules/","section":"Blog","summary":"If you\u0026rsquo;ve ever experienced the joys of migrating Group Policy and in particular Windows Defender Firewall rules away from Group Policy to Microsoft Intune, you\u0026rsquo;ve probably encountered the Rule Migration Tool, and for now this tool has worked well. So what\u0026rsquo;s the catch?","title":"Modernising Microsoft Intune Firewall Rule Policies"},{"content":"","date":"12 September 2023","permalink":"/tags/settingscatalog/","section":"Tags","summary":"","title":"Settings Catalog"},{"content":"Introduction # You might have been asked the question, especially from organisations that currently utilise Microsoft Configuration Manager, about how you mimic existing Device Collections used for Software Update deployments in Microsoft Intune.\nWith Configuration Manager having the backing of Microsoft SQL, and a hardware inventory that collects every granular detail about Windows devices, splitting out your device estate into logical phases is very easy to achieve.\nBut what about Microsoft Intune, how do we phase these updates in a similar way to Configuration Manager?\nWindows Update for Business Rings # The first thing we need to understand is how many WUfB (Windows Update for Business) rings we should create, usually based on the size of your Windows device estate, for now we\u0026rsquo;ll stick with four update rings.\nTesting Ring: This should be devices that are dedicated for testing, not IT machines. Roughly 5% of your device estate. Pilot Ring: This should be a stratified sample of either users or devices, not friends and family (HR and Finance). Roughly 15% of your device estate. Initial Production Ring: This should be roughly half of the remaining devices, roughly 30% of your device estate. Final Production Ring: This should cover all remaining devices, so 50% of the device estate. These rings can be created in Microsoft Intune with differing deferral periods, installation deadlines, and if you like, grace periods.\nInstallation Settings # Taking the Update Rings above, we should ensure that the end result of deferral, deadlines, and grace periods is that that there is no crossover between the timings. What I mean is that you don\u0026rsquo;t want to discover an issue with devices in the Pilot Ring after the Initial Production Ring has already started deploying updates, this sounds like a nightmare.\nSo we can use settings similar to those in the below table to ensure that one phase doesn\u0026rsquo;t start until the previous has completed.\nUpdate Ring Deferral Deadline Grace Period Updates Installed Testing Ring 0 days 1 day 0 days 1 day Pilot Ring 2 days 1 day 1 day 4 days Initial Production Ring 6 days 2 days 1 day 9 days Final Production Ring 10 days 2 days 1 day 13 days You may have noticed that we\u0026rsquo;re working within a 14-day window here, because we all love NCSC Guidelines. So with the Update Rings configured, we now need to look at how these are assigned to Users and Devices.\nUsers versus Devices Assignment # Now assignment of Update Rings is no different to any other assignment in Microsoft Intune, and by that I mean that you cannot mix assignment target identities within Include and Exclude targets. We do also need to consider not just the individual Update Ring assignment, but how they all interact together. What we don\u0026rsquo;t want is a device meant to be in the Final Production ring, getting a 0-day deferral because the user is in the Testing Ring.\nSo we should stick with assigning these rings to a single identity, but which one?\nI mean, the answer is Devices, but I\u0026rsquo;ll explain why.\nIf you\u0026rsquo;re using Users, which seems like the easier approach as finding and managing pilot users is pretty straight forward, it means that the Update Ring will follow them regardless of which device they login to. This is not the functionality we want, updates are delivered to devices, not users, so let\u0026rsquo;s see how we can group devices together in a sensible way.\nUpdate Ring Groups # So now we need to find a way group devices in a sensible way, so let\u0026rsquo;s create three (yes three) new Azure AD Microsoft Entra ID Security Groups for each of the Update Rings.\nWindows Updates Testing Windows Updates Pilot Windows Updates Initial Production With both the Testing and Pilot ring being specifically designated devices, we can use Assigned Groups and add Windows devices to each of those groups, what are we doing with the \u0026lsquo;Windows Updates Initial Production\u0026rsquo; group though?\nDynamic Groups # Now I know I love Device Filters, and do not fear, we\u0026rsquo;ll need one of these later, but as covered previously Dynamic Groups are more powerful, and for this use case will perfectly fit our need to split our Windows device estate in half-ish.\nDevice Name is how we\u0026rsquo;re going to split our device estate, whether these are you old-school naming conventions on-premises based on asset tag, serial number or otherwise, Autopilot Azure AD Join MEID Join (really?) devices with a prefix and a serial, or god forbid Autopilot Hybrid Joined devices with a prefix and random numbers.\nEither way, we should be able use Dynamic Device Groups to capture half of the device estate.\nStart of Device Name Matching # Before we look at how we capture the devices let\u0026rsquo;s look at some device name examples starting with a list of devices with a mixture of device names.\nENB-BDZX4M3 ENB-3231EQSM PGT-45E8LN1S VIP-ec9d473986d9 ITS-CRJ7C39 CON-f6f64b04a9e7 As we have some kind of naming convention here with a three letter prefix follow by a hyphen and then some random characters, we should be able to capture half of the devices by pulling back only devices that after the hyphen start with odd numbers (1, 3, 5, 7, 9), or alternate letters (a, c, e, etc.).\nThrowing open you\u0026rsquo;re favourite RegEx tester we can plonk in the device names and start playing with queries, and if we want to be exact so we only capture devices that match our three character prefix followed by a hyphen and an odd number, we can use an expression like this.\n^[a-zA-Z]{3}-d*[13579] For capturing devices that match the three character prefix followed by a hyphen and alternative lowercase characters, we can use the expression below.\n^[a-zA-Z]{3}-d*[acegikmoqsuwy] For capturing devices that match the three character prefix followed by a hyphen and alternative uppercase characters, we can use the expression below.\n^[a-zA-Z]{3}-d*[ACEGIKMOQSUWY] To give you an insight into the expression:\n^: Start of the string [a-zA-Z]{3}-: First three characters are either uppercase or lowercase letters followed by a hyphen d*[13579]: One odd number d*[acegikmoqsuwy]: One alternative lowercase letter from the supplied range d*[ACEGIKMOQSUWY]: One alternative uppercase letter from the supplied range This should cover our requirements, we just need to create the Dynamic Group query.\nEnd of Device Name Matching # What happens if you\u0026rsquo;re still using asset tag naming conventions, most of these devices will all start with the same letter or number, so we need a way to split these in a different way.\nLooking at the sample device list below, we can create a new expression that looks at the last number of the device name, but taking into consideration the prefix, hyphen, and only the following six digits.\nLTP-002003 LTP-002042 DTP-001191 DTP-000117 LTP-000008 Once again into RegEx testing we can plonk in the device names and start playing with queries, this time we just want to match devices with any three character prefix followed by a hyphen, but end in an odd number.\n^[a-zA-Z]{3}-\\d{5}[13579]$ An overview of the expression:\n^: Start of the string [a-zA-Z]{3}-: First three characters are either uppercase or lowercase letters followed by a hyphen \\d{5}: Matches five digits after the hyphen [13579]$: The sixth digit is odd This should work for the sample asset tag named devices.\nDynamic Group Query # As well as the using one of the above name matching expressions, we could do with capturing whether the device is actually a Windows Corporate-Owned device.\nSo let\u0026rsquo;s build our Dynamic Group Query based on the below requirements.\n(device.deviceOSType -eq \u0026quot;Windows\u0026quot;): Any Windows Device (device.deviceOSVersion -startsWith \u0026quot;10\u0026quot;): Any device with an Operating System that starts with 10 (device.deviceOwnership -eq \u0026quot;Company\u0026quot;): Any device that is corporate owned ((device.displayName -match \u0026quot;^[a-zA-Z]{3}-d*[13579]\u0026quot;): Device name matches our naming convention followed by an odd number (device.displayName -match \u0026quot;^[a-zA-Z]{3}-d*[acegikmoqsuwy]\u0026quot;): Device name matches our naming convention followed by a lowercase letter in the set (device.displayName -match \u0026quot;^[a-zA-Z]{3}-d*[ACEGIKMOQSUWY]\u0026quot;)): Device name matches our naming convention followed by a uppercase letter in the set We need to throw in some and and or into the mix to ensure we\u0026rsquo;re only grabbing the correct devices, but the full query can be found below.\n(device.deviceOSType -eq \u0026#34;Windows\u0026#34;) and (device.deviceOSVersion -startsWith \u0026#34;10\u0026#34;) and (device.deviceOwnership -eq \u0026#34;Company\u0026#34;) and ((device.displayName -match \u0026#34;^[a-zA-Z]{3}-d*[13579]\u0026#34;) or (device.displayName -match \u0026#34;^[a-zA-Z]{3}-d*[acegikmoqsuwy]\u0026#34;) or (device.displayName -match \u0026#34;^[a-zA-Z]{3}-d*[ACEGIKMOQSUWY]\u0026#34;)) Using our sample of devices names, the above query would capture the highlighted names below.\nENB-BDZX4M3 ENB-3231EQSM PGT-45E8LN1S VIP-ec9d473986d9 ITS-CRJ7C39 CON-f6f64b04a9e7 Expanding this over an entire device estate should give us roughly half of all Windows 10 and later corporate owned devices.\nUpdate Ring Assignment # So have pretty much all we need to actually start assigning our Update Rings to device groups, but hang fire, we\u0026rsquo;ve only created three groups and have four Update Rings, what gives?\nWell for the final ring, we need to cover all remaining Windows corporate owned devices, so we can use the built-in \u0026lsquo;All Devices\u0026rsquo; group and a Device Filter that only pulls back corporate owned devices, so something like (device.deviceOwnership -eq \u0026quot;Corporate\u0026quot;).\nNow we can start assigning, but we need to make sure that there is no conflict with the profiles, so we\u0026rsquo;ll make use of both Include and Exclude assignment targets, detailed in the table below.\nUpdate Ring Include Group Filter Mode Exclude Groups Testing Ring Windows Updates Testing n/a n/a n/a Pilot Ring Windows Updates Pilot n/a n/a Windows Updates Testing Initial Production Ring Windows Updates Initial Production n/a n/a Windows Updates Testing, Windows Updates Pilot Final Production Ring All Devices Corporate Windows Include Windows Updates Testing, Windows Updates Pilot, Windows Updates Initial Production Once you\u0026rsquo;ve assigned the Update Rings and confirmed that devices are receiving the correct one, you\u0026rsquo;re good to go. Simple really.\nSummary # There you have it, a phased and self maintaining deployment of Windows Updates across your device estate, allowing you to truly control when devices are getting updates and an ability to pause update rings in the event of an issue without taking out all of your device estate at once.\nObviously you can tailor the number of Update Rings and logic behind splitting devices across them, but it was hard enough for me to work out the RegEx for these two examples to be honest with you.\nI\u0026rsquo;d suggest you start with understanding what devices you need to target, their naming conventions if any, and then play around with RegEx to ensure that you are capturing the correct devices, no one wants unexpected Windows Updates.\nOnce happy with your expressions, you can then create the Dynamic Group and review the membership before going all gung ho and straight up assigning the Update Ring profile to the group, you know, just in case.\n","date":"17 July 2023","permalink":"/posts/windows-update-phased-deployment/","section":"Blog","summary":"You might have been asked the question, especially from organisations that currently utilise Microsoft Configuration Manager, about how you mimic existing Device Collections used for Software Update deployments in Microsoft Intune..","title":"Intelligent Phased Windows Update for Business Deployments"},{"content":"","date":"11 July 2023","permalink":"/tags/configuration/","section":"Tags","summary":"","title":"Configuration"},{"content":"","date":"11 July 2023","permalink":"/tags/ncsc/","section":"Tags","summary":"","title":"NCSC"},{"content":"Introduction # We looked at some of the ways to secure macOS devices in Microsoft Intune, aligned with the NCSC platform guidance in macOS National Cyber Security Centre Security Settings in Intune, but this was when macOS device management in Intune was, at best, in beta.\nGeneral hardening has been covered previously by Hubert Maslowski in their post that covers device compliance and configuration settings, but we\u0026rsquo;re looking at ensuring that the macOS devices meet the National Cyber Security Centre settings, including Cyber Essentials requirements.\nNow with the additional macOS settings, and new macOS versions, I thought we should look at how we can now secure these enrolled devices aligned to these known good practice settings.\nNCSC Guidelines # Handily, NCSC provide a list of their recommendations for macOS device security, and unlike our previous attempt at hardening, we don\u0026rsquo;t need to rely on mobileconfig custom settings to deliver these hardening requirements.\nThe settings from the platform guidance we\u0026rsquo;ll cover in this post are as detailed in the sections below. We\u0026rsquo;re not going to cover all the restrictions, the implications, and the expected behaviour, as the company I work for charges customers for this and I already provide too much \u0026lsquo;value add\u0026rsquo; as part of consultancy as it is.\nDevice Password Settings # Password complexity in the NCSC guidance is a little open ended, however when you dig through their other guidance, we can see that the new requirements for passwords on macOS devices have the restrictions of the below:\n12 Characters or more Allow the use of lower case, upper case, numbers Block the use of special characters Block the use of simple passwords that have repeating, ascending, or descending characters Password does not expire Remember previous 24 passwords Minimum activity before a password is required set to five minutes The NCSC guidance does cover screen saver settings, and password sharing settings, so we can include those as well when configuring password settings.\nRequire password after sleep or screen saver begins within five seconds Disable password sharing Disable proximity based password sharing requests With the above, we can easily create a device compliance policy\u0026hellip;\nWhen a compliance policy contains password restrictions, this will force the end user to change their password at next logon, and result in any attempt at elevation to fail with existing credentials until the password has been updated. \u0026hellip;and a device restrictions profile to meet these requirements.\nAs there isn\u0026rsquo;t a five second option for when a password is required, with the minimum being one minute, we\u0026rsquo;ve set this to be immediately. Login Restrictions # There are a number of recommendations when it comes to the login window, with most of these impacting the end-user experience, but obviously for good security based reasons. We can group the restrictions into one Settings Catalog profile and one Device Restriction profile, who knows why Microsoft didn\u0026rsquo;t just make them all available within Settings Catalogs.\nUsing a Settings Catalog profile we can cover the following restrictions.\nDisable Guest User Disable console logon Log out users after three minutes of inactivity* Block user setting a lock message *We can\u0026rsquo;t do three minutes so five will have to do, Microsoft Intune supports between five minutes and 24 hours. For the Device Restriction Profile we can cover the restriction below.\nShow only Name and Password Text fields Software Updates # Ah yes, software updates, basically we need to ensure that updates are installed within a 14-day window from the release of the update, that the updates can be installed by the end user, and that only production updates can be installed.\nAutomatically install macOS updates Allow non-admin users to install software updates Do not defer macOS Updates Allow installation of macOS beta releases With these requirements we can create the Settings Catalog profile below to adhere to the restrictions.\nThe Microsoft documentation talks about these settings in the Additional settings section, there appears to be a caveat to that whole document that these update settings will only apply to Supervised macOS devices. Restrict Items in System Preferences # Limiting access to areas in the System areas used to be accomplished by a custom profile, but now we can use a Settings Catalog profile, oh how Intune has changed. The excerpt from the NCSC guide is as follows.\nDisable iCloud Profiles Disable Security \u0026amp; Privacy Disable Startup Disk Disable Sharing (enables remote management) Disable Siri Disable Xsan (If not in use) Disable FibreChannel (if not in use). We can now use a Settings Catalog profile to hide these system preference panes, using the Apple Developer Reference as a reference for each of these system preferences, allowing us to restrict the following areas:\nSystem Preference Item iCloud Profiles com.apple.preferences.icloud Security and Privacy com.apple.preference.security Startup Disk com.apple.preference.startupdisk Sharing com.apple.preferences.sharing Siri com.apple.Siri-Settings.extension Xsan com.apple.Xsan FibreChannel com.apple.prefpanel.fibrechannel With this we can create a new profile using the Disabled Preference Panes option.\nThis will then disable these panes on the device for the end user, stopping them adding iCloud accounts, configuring sharing settings include remote control, along with other NCSC deemed risky areas on the macOS device.\nTime Server Configuration # This one is nice and easy, and a lot easier to handle now in Intune, without the need to create a new mobileconfig file, we can just throw both the time zone and time servers into the same Settings Catalog profile as per the requirement below.\nSpecify time server by device location Ensure that you are selecting location specific time servers, in this instance we\u0026rsquo;re in the UK so using the UK servers from the NTP Pool Project, you may want to configure your own servers, but remember these devices may not always be on your local corporate network.\nSummary # Even if you\u0026rsquo;re not aligning to NCSC or Cyber Essentials guidance for your macOS devices, this post will be useful as a good practice security configuration, as well as the fact that Microsoft is investing into the management of operating systems that aren\u0026rsquo;t Windows in Microsoft Intune.\nThere have been many developments with macOS device management with new changes coming for these devices already listed in the In Development page, hopefully one day we\u0026rsquo;ll get Azure Active Directory Microsoft Entra ID joined macOS devices\u0026hellip;we can but hope.\n","date":"11 July 2023","permalink":"/posts/macos-ncsc-revisited/","section":"Blog","summary":"With the improved support for macOS devices in Microsoft Intune, it\u0026rsquo;s time we revisited how to secure macOS devices aligned the National Cyber Security Centre guidance.","title":"Revisiting macOS National Cyber Security Centre Security Settings"},{"content":"","date":"27 June 2023","permalink":"/tags/assignments/","section":"Tags","summary":"","title":"Assignments"},{"content":"Introduction # Fresh off the back of a trawl of a Modern Endpoint Management LinkedIn group, someone wanted the ability to assign existing Settings Catalog profiles in Microsoft Intune to additional Groups\u0026hellip;this sounded like a quick win if you fancy manually doing it, but no one wants that, and as I had experience of dealing with the logic when assigning apps, I thought I\u0026rsquo;d give it a go.\nAssignment Overview # Assigning Settings Catalog profiles for Windows, macOS, and iOS/iPadOS devices isn\u0026rsquo;t anything new, though Settings Catalogs were a bit of a revelation when they first appeared in Microsoft Intune allowing you to build profiles from scratch with a searchable interface, and with the ability to assign them to groups and use Device Filters, I jumped at the chance to use them in place of custom profiles where applicable.\nWhat about the assignment though, what does that look like?\nAssignment Restrictions # Settings Catalog assignment isn\u0026rsquo;t too dissimilar from assigning any other profile type, though as you\u0026rsquo;ll discover through subsequent posts, each has it\u0026rsquo;s own nuance when it comes to how you assign the profiles. So let\u0026rsquo;s list what we can do when it comes to assignment, and what we can\u0026rsquo;t do, as this will shape how we build out a PowerShell function to allow us to assign profiles in bulk.\nAssignment Wins # These assignments, if already familiar with Microsoft Intune, shouldn\u0026rsquo;t come as any surprise:\nIncluded Groups: Assigning to All Devices, All Users, and Groups of Devices or Users Included Groups: Assigning to All Devices with an Include Device Filter, All Users with an Include Device Filter, and Groups of Devices or Users with an Include Device Filter Included Groups: Assigning to All Devices with an Exclude Device Filter, All Users with an Exclude Device Filter, and Groups of Devices or Users with an Exclude Device Filter Excluded Groups: Assigning to Groups of Devices or Users Remember that when excluding groups, you cannot mix user and device groups across include and exclude. So this is pretty useful and should, especially with Device Filters, be all you need for assignment. What about the things we can\u0026rsquo;t do?\nAssignment No-nos # The list below is the current list of things you cannot do with the assignments for Settings Catalogs, and takes into consideration whether there are existing assignments on the profile:\nIncluded Groups: Assigning to All Devices and a Group of Devices or Users Included Groups: Assigning to All Users and a Group of Devices or Users Included Groups: Assigning to a Group that already has an assignment Included Groups: Assigning to All Devices that already has an assignment Included Groups: Assigning to All Users that already has an assignment Included Groups: Assigning to Groups of Devices or Users if All Devices already has an assignment Included Groups: Assigning to Groups of Devices or Users if All Users already has an assignment Excluded Groups: Assigning to Groups of Devices or Users with any Device Filter Excluded Groups: Assigning to All Devices or All Users Excluded Groups: Assigning to a Group that already has an assignment There are many restrictions when it comes to adding additional assignments, the above are the important ones, as we don\u0026rsquo;t want to be creating ourselves issues with assignments later on. Though this is going to give me a headache writing PowerShell to deal with this logic.\nGetting Settings Catalog Information # We\u0026rsquo;ve now got a good grip on the methods for assignment, but to start this all off, we need a way to get both the the Settings Catalog profile itself, a method to capture all existing assignments, and importantly, how to add assignments to the profile.\nGetting Settings Catalogs # I already had the PowerShell function below at my disposal, so after connecting to Graph API using preferred method we can use the deviceManagementConfigurationPolicy endpoint in the below function to pull back either all Settings Catalogs, or specific ones using either the Id or Name.\nFunction Get-DeviceSettingsCatalog() { [cmdletbinding()] param ( [Parameter(Mandatory = $false)] $Name, [Parameter(Mandatory = $false)] $Id ) $graphApiVersion = \u0026#39;beta\u0026#39; $Resource = \u0026#34;deviceManagement/configurationPolicies?`$filter=technologies has \u0026#39;mdm\u0026#39;\u0026#34; try { if ($Id) { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource/$Id\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get } elseif ($Name) { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value | Where-Object { ($_.Name).contains(\u0026#34;$Name\u0026#34;) } } Else { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Error \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Break } } Running this function will get us the information we need in the Id of the Setting Catalog profile.\ncreatedDateTime : 08/03/2023 13:39:14 creationSource : description : lastModifiedDateTime : 10/05/2023 08:40:16 name : Corporate_Configuration_Policy_Conflict platforms : windows10 priorityMetaData : roleScopeTagIds : {0} settingCount : 1 technologies : mdm id : 0565e69e-7bba-455a-bfaa-4ca6680a02b5 templateReference : @{templateId=; templateFamily=none; templateDisplayName=; templateDisplayVersion=} With a way to get a Settings Catalog profile, we now need a way to pull back any and all assignments for a profile using the deviceManagementConfigurationPolicyAssignments endpoint in Graph and the above Id of the profile.\nGetting Settings Catalog Assignments # Function Get-DeviceSettingsCatalogAssignment() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] $Id ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceManagement/configurationPolicies/$Id/assignments\u0026#34; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Error \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Break } } This is the set of assignments on an existing Settings Catalog profile that we can now query.\nPassing through the Id we will get an output that looks like the below for the above assignments, with the target being the important part, as this contains the details of the types of assignments as well as the Ids of the groups the profile is assigned to.\nid : 0565e69e-7bba-455a-bfaa-4ca6680a02b5_b2358c32-aff8-4408-bf90-d6c4c4e73a90 source : direct sourceId : 0565e69e-7bba-455a-bfaa-4ca6680a02b5 target : @{@odata.type=#microsoft.graph.groupAssignmentTarget; deviceAndAppManagementAssignmentFilterId=; deviceAndAppManagementAssignmentFilterType=none; groupId=b2358c32-aff8-4408-bf90-d6c4c4e73a90} id : 0565e69e-7bba-455a-bfaa-4ca6680a02b5_c4480982-3342-4dc5-9c58-b272a77b7ab1 source : direct sourceId : 0565e69e-7bba-455a-bfaa-4ca6680a02b5 target : @{@odata.type=#microsoft.graph.groupAssignmentTarget; deviceAndAppManagementAssignmentFilterId=4feb8cf9-1529-41d6-80bb-498922c5e567; deviceAndAppManagementAssignmentFilterType=include; groupId=c4480982-3342-4dc5-9c58-b272a77b7ab1} id : 0565e69e-7bba-455a-bfaa-4ca6680a02b5_f9c1e630-771d-4c12-b366-8a3e4db0509a source : direct sourceId : 0565e69e-7bba-455a-bfaa-4ca6680a02b5 target : @{@odata.type=#microsoft.graph.exclusionGroupAssignmentTarget; deviceAndAppManagementAssignmentFilterId=; deviceAndAppManagementAssignmentFilterType=none; groupId=f9c1e630-771d-4c12-b366-8a3e4db0509a} So we kinda have the bits we need to get existing assignments, what about adding a new assignment?\nAssigning Settings Catalogs # First thing to note about assignments in Microsoft Intune, is there is no PATCH option with Graph API for the assignment endpoints, what this means is there is no native way to update the assignments of a Settings Catalog profile, the default behaviour is to replace any and all existing assignments. After trying to deal with the restrictions around assignments, I can understand why there is no PATCH option, as it\u0026rsquo;s a nightmare dealing with the logic.\nWe however, are not an API, so we can apply our squishy human brains and work something out to give us the ability to add new assignments, without ripping out the existing ones surely?\nBuilding New Assignments # So where do we start exactly? With the many different ways to assign a profile, or the twelfty different restrictions when adding new assignments to existing ones? Let\u0026rsquo;s go with the relatively simple creation of new assignments first, as this seems a little more straightforward.\nLuckily for us, Microsoft provide documentation for the JSON format of the payload required to create a new assignment, and as we have our own function to get existing assignments, we can quite easily build out the required data in PowerShell based on each of the methods for assignment.\nThe table below details the data used for each assignment method, so this is useful reference for us when building our own assignment function.\nTarget Type Name Value Group Include @odata.type #microsoft.graph.groupAssignmentTarget groupId Id of the Assignment Group Group Exclude @odata.type #microsoft.graph.exclusionGroupAssignmentTarget groupId Id of the Assignment Group All Users Include @odata.type #microsoft.graph.allLicensedUsersAssignmentTarget All Devices Include @odata.type #microsoft.graph.allDevicesAssignmentTarget Device Filter Include deviceAndAppManagementAssignmentFilterType Include deviceAndAppManagementAssignmentFilterId Id of the Device Filter Device Filter Exclude deviceAndAppManagementAssignmentFilterType Exclude deviceAndAppManagementAssignmentFilterId Id of the Device Filter So we can take the above and using the below excerpt from an existing assignment function, build the required JSON data.\n$TargetGroup = New-Object -TypeName psobject if ($GroupId) { if ($AssignmentType -eq \u0026#39;Exclude\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.exclusionGroupAssignmentTarget\u0026#39; } elseif ($AssignmentType -eq \u0026#39;Include\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.groupAssignmentTarget\u0026#39; } $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;groupId\u0026#39; -Value \u0026#34;$GroupId\u0026#34; } else { if ($All -eq \u0026#39;Users\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#39; } ElseIf ($All -eq \u0026#39;Devices\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.allDevicesAssignmentTarget\u0026#39; } } if ($FilterType) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterId\u0026#39; -Value $FilterId $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterType\u0026#39; -Value $FilterType } $Target = New-Object -TypeName psobject $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;target\u0026#39; -Value $TargetGroup This will give us the correct format that can be submitted to Graph API to create a new assignment for example for All Users with a Device Filter.\n{ \u0026#34;assignments\u0026#34;: [ { \u0026#34;target\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#34;, \u0026#34;deviceAndAppManagementAssignmentFilterId\u0026#34;: \u0026#34;4feb8cf9-1529-41d6-80bb-498922c5e567\u0026#34;, \u0026#34;deviceAndAppManagementAssignmentFilterType\u0026#34;: \u0026#34;include\u0026#34; } } ] } Or including a Group with a Device Filter.\n{ \u0026#34;assignments\u0026#34;: [ { \u0026#34;target\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.groupAssignmentTarget\u0026#34;, \u0026#34;groupId\u0026#34;: \u0026#34;f9c1e630-771d-4c12-b366-8a3e4db0509a\u0026#34;, \u0026#34;deviceAndAppManagementAssignmentFilterId\u0026#34;: \u0026#34;4feb8cf9-1529-41d6-80bb-498922c5e567\u0026#34;, \u0026#34;deviceAndAppManagementAssignmentFilterType\u0026#34;: \u0026#34;include\u0026#34; } } ] } That was the easy part, and we can take the above methods to create new assignments. So now onto the head scratcher.\nCapturing Existing Assignments # We have the Get-DeviceSettingsCatalogAssignment function at our disposal now, so we can query a Settings Catalog profile to get any existing assignments, which is going to be important when dealing with the logic of adding new ones, for now we just need to get the existing ones into a useable JSON format so we can punt it back to Graph API.\n#Gets existing Assignments $Assignments = Get-DeviceSettingsCatalogAssignment -Id $Id # Creates an array for the existing assignments $TargetGroups = @() foreach ($Assignment in $Assignments) { $TargetGroup = New-Object -TypeName psobject $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value $Assignment.target.\u0026#39;@odata.type\u0026#39; if ($Assignment.target.\u0026#39;@odata.type\u0026#39; -like \u0026#39;*groupAssignmentTarget*\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;groupId\u0026#39; -Value $Assignment.target.groupId } if ($Assignment.target.deviceAndAppManagementAssignmentFilterType -ne \u0026#39;none\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterId\u0026#39; -Value $Assignment.target.deviceAndAppManagementAssignmentFilterId $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterType\u0026#39; -Value $Assignment.target.deviceAndAppManagementAssignmentFilterType } $Target = New-Object -TypeName psobject $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;target\u0026#39; -Value $TargetGroup $TargetGroups += $Target } This captures the existing assignments and adds them to the $TargetGroups array variable, which can then be added to for any new assignments we want to add, then converted to JSON and eventually posted to Graph API.\nSo for our example, the output of the above would look something like the below.\n{ \u0026#34;assignments\u0026#34;: [ { \u0026#34;target\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.groupAssignmentTarget\u0026#34;, \u0026#34;groupId\u0026#34;: \u0026#34;b2358c32-aff8-4408-bf90-d6c4c4e73a90\u0026#34; } }, { \u0026#34;target\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.groupAssignmentTarget\u0026#34;, \u0026#34;groupId\u0026#34;: \u0026#34;c4480982-3342-4dc5-9c58-b272a77b7ab1\u0026#34;, \u0026#34;deviceAndAppManagementAssignmentFilterId\u0026#34;: \u0026#34;4feb8cf9-1529-41d6-80bb-498922c5e567\u0026#34;, \u0026#34;deviceAndAppManagementAssignmentFilterType\u0026#34;: \u0026#34;include\u0026#34; } }, { \u0026#34;target\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.exclusionGroupAssignmentTarget\u0026#34;, \u0026#34;groupId\u0026#34;: \u0026#34;f9c1e630-771d-4c12-b366-8a3e4db0509a\u0026#34; } } ] } We\u0026rsquo;re onto something here, time to look at the logic around adding new assignments to existing ones, mmmm logic my favourite coffee fuelled exercise.\nHandling Existing Assignments # Now that we can capture existing assignment, we need to deal with the logic when trying to add new assignments to the Settings Catalog profile. This will not be fun.\nLet\u0026rsquo;s go through each of the assignment non-nos we\u0026rsquo;ve already covered in this post.\nInclude Assignments # Assigning to All Devices and a Group of Devices or Users We just need to check if the function parameter $All which equates to an option to assign to All Device or All Users exists, and whether there are any existing group targetted assignment on the Settings Catalog profile.\nElseIf (($All -ne \u0026#39;\u0026#39;) -and ($Assignments.target.\u0026#39;@odata.type\u0026#39; -contains \u0026#39;#microsoft.graph.groupAssignmentTarget\u0026#39;)) { Write-Warning \u0026#39;The policy is already assigned to a group(s), and cannot be assigned to All Devices or All Users groups\u0026#39; break } Assigning to All Users and a Group of Devices or Users This one is covered by the above logic, as we wrote the If statement to only look for the $All parameter which takes into consideration both the All Devices and All Users assignment targets.\nAssigning to a Group that already has an assignment This one is pretty easy really, we just need to compare the GroupId of the new assignment, to any existing assignments targetting to groups, and if the Ids match, to stop the function from running.\nIf (($GroupId -ne \u0026#39;\u0026#39;) -and ($GroupId -in $Assignments.target.groupId)) { Write-Warning \u0026#39;The policy is already assigned to the Group\u0026#39; break } Assigning to All Devices that already has an assignment Similar to the above, we\u0026rsquo;re checking to see if the new All Devices assignment already existing, and if it does, stopping the progress of the assignment.\nIf (($All -eq \u0026#39;Devices\u0026#39;) -and ($Assignments.target.\u0026#39;@odata.type\u0026#39; -contains \u0026#39;#microsoft.graph.allDevicesAssignmentTarget\u0026#39;)) { Write-Warning \u0026#39;The policy is already assigned to the All Devices group\u0026#39; break } Assigning to All Users that already has an assignment This was pretty much a copy and paste of the above, just swapping the devices parameters for the users one.\nIf (($All -eq \u0026#39;Users\u0026#39;) -and ($Assignments.target.\u0026#39;@odata.type\u0026#39; -contains \u0026#39;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#39;)) { Write-Warning \u0026#39;The policy is already assigned to the All Users group\u0026#39; break } Assigning to Groups of Devices or Users if All Devices already has an assignment We need to identity whether a group assignment is being created, which is captured with the $GroupId function parameter, and whether either the All Devices or All Users assignment target exists, and if it does break the function from running.\nIf (($GroupId -ne \u0026#39;\u0026#39;) -and (($Assignments.target.\u0026#39;@odata.type\u0026#39; -contains \u0026#39;#microsoft.graph.allDevicesAssignmentTarget\u0026#39;) -or ($Assignments.target.\u0026#39;@odata.type\u0026#39; -contains \u0026#39;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#39;))) { Write-Warning \u0026#39;The policy is already assigned to All Devices or All Users groups, and cannot be assigned to a group\u0026#39; break } Assigning to Groups of Devices or Users if All Users already has an assignment This one is captured in the above logic, which is lucky as I was running out of steam by this point.\nExclude Assignments # Assigning to Groups of Devices or Users with any Device Filter Using the parameters of the function itself, we can stop this assignment type, with parameters configured for Group assignment in $GroupID and the Assignment Type parameter $AssignmentType, as well as the Filter ID parameter $FilterId. With this combination of parameters being true, we can throw an error and stop the function from running.\nIf (($AssignmentType -eq \u0026#39;Exclude\u0026#39;) -and ($GroupId -ne \u0026#39;\u0026#39;) -and ($FilterId -ne \u0026#39;\u0026#39;)) { Write-Warning \u0026#39;You cannot assign a group with a filter as an exclude assignment\u0026#39; break } Assigning to All Devices or All Users We can again handle this in the function itself, with parameters for an \u0026lsquo;All Devices or Users\u0026rsquo; assignment and the \u0026lsquo;Assignment Type\u0026rsquo;, so if you select the $All assignment and the assignment type $AssignmentType equalling Exclude, we can throw an error.\nIf (($All -ne \u0026#39;\u0026#39;) -and ($AssignmentType -eq \u0026#39;Exclude\u0026#39;)) { Write-Warning \u0026#39;You cannot All Devices or All Users groups as an exclude assignment\u0026#39; break } Assigning to a Group that already has an assignment The logic for this is exactly the same as the Include assignment type, as whether there is an include or exclude assignment for the same group, the result is the same.\nThe Assignment Function # We now have all the component parts, all is left to do is to throw them all at Visual Studio Code and pray that we\u0026rsquo;ve got something that works, configuring all the required logic and the function parameters to allow the assignment of new groups to Settings Catalog profiles.\nI\u0026rsquo;ve given the option to not only add to existing assignments, but also to just flatten the existing ones and create new using the $AssignmentAction parameter.\nFunction Add-DeviceSettingsCatalogAssignment() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] [string]$Id, [parameter(Mandatory = $false)] [string]$GroupId, [parameter(Mandatory = $true)] [ValidateSet(\u0026#39;Include\u0026#39;, \u0026#39;Exclude\u0026#39;)] [string]$AssignmentType, [parameter(Mandatory = $false)] [string]$FilterId, [parameter(Mandatory = $false)] [ValidateSet(\u0026#39;Include\u0026#39;, \u0026#39;Exclude\u0026#39;)] [string]$FilterType, [parameter(Mandatory = $false)] [ValidateSet(\u0026#39;Users\u0026#39;, \u0026#39;Devices\u0026#39;)] [string]$All, [parameter(Mandatory = $true)] [ValidateSet(\u0026#39;Replace\u0026#39;, \u0026#39;Add\u0026#39;)] $AssignmentAction ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceManagement/configurationPolicies/$Id/assign\u0026#34; try { # Stopping assignmnent of All Users or All Devices as an exclude assignment if (($All -ne \u0026#39;\u0026#39;) -and ($AssignmentType -eq \u0026#39;Exclude\u0026#39;)) { Write-Warning \u0026#39;You cannot All Devices or All Users groups as an exclude assignment\u0026#39; break } # Stopping assignment of group and All Devices/Users if (($All -ne \u0026#39;\u0026#39;) -and ($GroupId -ne \u0026#39;\u0026#39;)) { Write-Warning \u0026#39;You cannot assign to All Devices or All Users, and groups\u0026#39; break } # Stopping assignment of group with filter as an exclude assignment if (($AssignmentType -eq \u0026#39;Exclude\u0026#39;) -and ($GroupId -ne \u0026#39;\u0026#39;) -and ($FilterId -ne \u0026#39;\u0026#39;)) { Write-Warning \u0026#39;You cannot assign a group with a filter as an exclude assignment\u0026#39; break } # If Adding an assignment to existing assignments If ($AssignmentAction -eq \u0026#39;Add\u0026#39;) { # Checking if there are Assignments already configured $Assignments = Get-DeviceSettingsCatalogAssignment -Id $Id if ($Assignments.count -ge 1) { # Checking if the group is already assigned If (($GroupId -ne \u0026#39;\u0026#39;) -and ($GroupId -in $Assignments.target.groupId)) { Write-Warning \u0026#39;The policy is already assigned to the Group\u0026#39; break } # Checking if already assigned to All Devices ElseIf (($All -eq \u0026#39;Devices\u0026#39;) -and ($Assignments.target.\u0026#39;@odata.type\u0026#39; -contains \u0026#39;#microsoft.graph.allDevicesAssignmentTarget\u0026#39;)) { Write-Warning \u0026#39;The policy is already assigned to the All Devices group\u0026#39; break } # Checking if aleady assigned to All users ElseIf (($All -eq \u0026#39;Users\u0026#39;) -and ($Assignments.target.\u0026#39;@odata.type\u0026#39; -contains \u0026#39;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#39;)) { Write-Warning \u0026#39;The policy is already assigned to the All Users group\u0026#39; break } # Checking if already assigned to groups when assigning \u0026#39;All\u0026#39; assignment ElseIf (($All -ne \u0026#39;\u0026#39;) -and ($Assignments.target.\u0026#39;@odata.type\u0026#39; -contains \u0026#39;#microsoft.graph.groupAssignmentTarget\u0026#39;)) { Write-Warning \u0026#39;The policy is already assigned to a group(s), and cannot be assigned to All Devices or All Users groups\u0026#39; break } # Checking if already assigned to \u0026#39;All\u0026#39; when assigning groups ElseIf (($GroupId -ne \u0026#39;\u0026#39;) -and (($Assignments.target.\u0026#39;@odata.type\u0026#39; -contains \u0026#39;#microsoft.graph.allDevicesAssignmentTarget\u0026#39;) -or ($Assignments.target.\u0026#39;@odata.type\u0026#39; -contains \u0026#39;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#39;))) { Write-Warning \u0026#39;The policy is already assigned to All Devices or All Users groups, and cannot be assigned to a group\u0026#39; break } # If new assignment viable, captures existing assignments Else { # Creates an array for the existing assignments $TargetGroups = @() foreach ($Assignment in $Assignments) { $TargetGroup = New-Object -TypeName psobject $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value $Assignment.target.\u0026#39;@odata.type\u0026#39; if ($Assignment.target.\u0026#39;@odata.type\u0026#39; -like \u0026#39;*groupAssignmentTarget*\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;groupId\u0026#39; -Value $Assignment.target.groupId } if ($Assignment.target.deviceAndAppManagementAssignmentFilterType -ne \u0026#39;none\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterId\u0026#39; -Value $Assignment.target.deviceAndAppManagementAssignmentFilterId $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterType\u0026#39; -Value $Assignment.target.deviceAndAppManagementAssignmentFilterType } $Target = New-Object -TypeName psobject $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;target\u0026#39; -Value $TargetGroup $TargetGroups += $Target } } } } # Creates the new assignment $TargetGroup = New-Object -TypeName psobject if ($GroupId) { if ($AssignmentType -eq \u0026#39;Exclude\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.exclusionGroupAssignmentTarget\u0026#39; } elseif ($AssignmentType -eq \u0026#39;Include\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.groupAssignmentTarget\u0026#39; } $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;groupId\u0026#39; -Value \u0026#34;$GroupId\u0026#34; } else { if ($All -eq \u0026#39;Users\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#39; } ElseIf ($All -eq \u0026#39;Devices\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.allDevicesAssignmentTarget\u0026#39; } } if ($FilterType) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterId\u0026#39; -Value $FilterId $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterType\u0026#39; -Value $FilterType } $Target = New-Object -TypeName psobject $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;target\u0026#39; -Value $TargetGroup $TargetGroups += $Target # Creating JSON object to pass to Graph $Output = New-Object -TypeName psobject $Output | Add-Member -MemberType NoteProperty -Name \u0026#39;assignments\u0026#39; -Value @($TargetGroups) $JSON = $Output | ConvertTo-Json -Depth 3 # POST to Graph Service $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Post -Body $JSON -ContentType \u0026#39;application/json\u0026#39; } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Break } } That\u0026rsquo;s all there is to it, which is hilarious as I\u0026rsquo;m pretty sure I aged significantly when coming up with this function. Let\u0026rsquo;s see how we can use this to create new assignments.\nUsing the Assignment Function # We need to start by getting the Id of an existing Settings Catalog profile, so we can reference this Id when creating new assignments, and if we\u0026rsquo;re using Devices Filters or Groups, we need to get the Ids of those as well.\n$Policy = Get-DeviceSettingsCatalog | Where-Object { $_.Name -eq \u0026#39;Corporate_Configuration_Policy_Conflict\u0026#39; } $Group = Get-MDMGroup -GroupName \u0026#39;SG_MDM_Devices_Corporate_POC\u0026#39; $Filter = Get-DeviceFilter -Name \u0026#39;Corporate_Windows_All\u0026#39; Right, onto the fun parts. I\u0026rsquo;ve provided examples of each of the possible assignment methods below and in an example script which as always can be found on GitHub\n# Adding an include Group assignment Add-DeviceSettingsCatalogAssignment -Id $Policy.id -AssignmentAction Add -AssignmentType Include -GroupId $group.id # Adding an include Group assignment with include filter Add-DeviceSettingsCatalogAssignment -Id $Policy.id -AssignmentAction Add -AssignmentType Include -GroupId $group.id -FilterType Include -FilterID $Filter.id # Adding an exclude Group assignment Add-DeviceSettingsCatalogAssignment -Id $Policy.id -AssignmentAction Add -AssignmentType Exclude -GroupId $group.id # Adding an Include All Devices assignment Add-DeviceSettingsCatalogAssignment -Id $Policy.id -AssignmentAction Add -AssignmentType Include -All Devices # Adding an Include All Devices assignment with filter Add-DeviceSettingsCatalogAssignment -Id $Policy.id -AssignmentAction Add -AssignmentType Include -All Devices -FilterType Include -FilterID $Filter.id # Replacing all assignment and adding an Include All Users assignment Add-DeviceSettingsCatalogAssignment -Id $Policy.id -AssignmentAction Replace -AssignmentType Include -All Users If all went to plan, we should now be able to successfully create Settings Catalog profile assignments as little and often as we\u0026rsquo;d like, with the ability to now get all of your Settings Catalog profiles, and for each of them create and add new assignments.\nSummary # This will end up being the first in a series of posts about managing assignments in Microsoft Intune, but luckily for me, Settings Catalog assignment is one of the more complicated ones (he says already knowing the Application assignment is more complicated) so the next one I look at should be a little less logic heavy, as well as the fact I should be able to reuse some of the Settings Catalog profile assignment function across many areas of Microsoft Intune.\n","date":"27 June 2023","permalink":"/posts/managing-intune-assignment-settingscatalog/","section":"Blog","summary":"Ever wanted to the ability to re-assign all of your Setting Catalog profiles in Intune to additional device and user groups without having to painstakingly go through each one manually? Well this post is for you.","title":"Managing Assignments in Microsoft Intune: Settings Catalog Profiles"},{"content":"Introduction # So you\u0026rsquo;re interested in Endpoint Privilege Management in Microsoft Intune, you\u0026rsquo;ve found, begged for, borrowed or stolen the money for shiny new Intune Suite or EPM licenses, and in you\u0026rsquo;re excitement you\u0026rsquo;ve gone and deployed a new policy to audit using the Reporting Scope options, all elevations across your managed Windows 10 and later devices. Now what?\nWell it\u0026rsquo;s policy creation time, but that seems like a labour intensive (well many clicks) task, and as much as the reports give you all the required information you need to review unmanaged elevations and create new policies and elevation rules, there has to be a better way to take the data in the report and create these policies and subsequent rules for you.\nEPM Reporting # The Endpoint elevation report in Microsoft Intune will give us the data we need to create hash based rules, so let\u0026rsquo;s find a way to get the report data and export it with some collated information to make reviewing the elevations a little easier, as no one wants to review individual elevations from each user on a case by case basis, unless you\u0026rsquo;re in InfoSec.\nGetting Report Data # Once connected to Graph API using our tried and tested authentication method we can use the deviceManagement/privilegeManagementElevations endpoint (of which there is no documentation currently, tut tut Microsoft) to pull back the report data. I\u0026rsquo;ve given the option to pull back Managed, Unmanaged, and All elevation types with this function so it\u0026rsquo;s at least reusable, though for now we only care about the Unmanaged elevations.\nFunction Get-DeviceEPMReport() { [cmdletbinding()] param ( [Parameter(Mandatory = $false)] [ValidateSet(\u0026#39;Managed\u0026#39;, \u0026#39;Unmanaged\u0026#39;)] [String]$Elevation, ) $graphApiVersion = \u0026#39;beta\u0026#39; $Resource = \u0026#39;deviceManagement/privilegeManagementElevations\u0026#39; try { if ($Elevation -eq \u0026#39;Managed\u0026#39;) { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)?filter=(elevationType ne \u0026#39;unmanagedElevation\u0026#39;)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).value } elseif ($Elevation -eq \u0026#39;Unmanaged\u0026#39;) { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)?filter=(elevationType eq \u0026#39;unmanagedElevation\u0026#39;)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).value } else { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).value } } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Running the PowerShell function will give us an output of each Unmanaged elevation, which we can then process, apply some groupings, and eventually export.\nGet-DeviceEPMReport -Elevation Unmanaged Exporting Report Data # Now that we have the data from the elevation report, I thought it best we group the elevations by hash value, as this is a unique identifier for each application that has been elevated by a user, as well as counting the number of elevations for that application, the users who have elevated, and the devices they have elevated from.\nThe above information, and below details required for rule creation, allows us to review the elevations and whether we want to create rules from them:\nCount of Elevations for the application: so we can see whether this is a widely used elevated application Elevated application file name: required for rule creation Elevated application internal name Elevated application publisher Elevated application product name Elevated application description Elevated application file path: formatted with \\\\ as is required by the rule creation Elevated application file version Users who have elevated the application: formatted for only unique users so we can assess which users are elevating the application Devices where the application has been elevated: formatted for only unique devices so we can assess from which devices the application is being elevated The below PowerShell captures all the required data in the correct formats to a new $Report array variable, which we can then export to CSV once we\u0026rsquo;ve cycled through all elevations.\n$Report = @() $Hashes = Get-DeviceEPMReport -Elevation Unmanaged | Group-Object -Property hash foreach ($Hash in $Hashes) { $Elevations = $Hash.Group $Users = @() $Devices = @() foreach ($Elevation in $Elevations) { $FileName = $Elevation.filePath | Split-Path -Leaf $FileInternalName = $Elevation.internalName $FileCompany = $Elevation.companyName $FileProduct = $Elevation.productName $FileDescription = $Elevation.fileDescription $FilePath = ($Elevation.filePath | Split-Path) -replace \u0026#39;\\\\\u0026#39;, \u0026#39;\\\\\u0026#39; $FileVersion = $Elevation.fileVersion $Users += $Elevation.upn $Devices += $Elevation.deviceName } $Data = [PSCustomObject]@{ ElevationCount = $Hash.Count Product = $FileProduct Description = $FileDescription Publisher = $FileCompany FileName = $FileName FileInternalName = $FileInternalName FileVersion = $FileVersion FilePath = $FilePath FileHash = $Hash.Name Users = (($Users | Get-Unique) -join \u0026#39; \u0026#39; | Out-String).Trim() Devices = (($Devices | Get-Unique) -join \u0026#39; \u0026#39; | Out-String).Trim() ElevationType = \u0026#39;Automatic/UserAuthentication/UserJustification\u0026#39; Group = \u0026#39;GroupName\u0026#39; } $Report += $Data } Exporting the $Report variable to CSV using the append function for each elevation, we get something like the below.\n\u0026#34;ElevationCount\u0026#34;,\u0026#34;Product\u0026#34;,\u0026#34;Description\u0026#34;,\u0026#34;Publisher\u0026#34;,\u0026#34;FileName\u0026#34;,\u0026#34;FileInternalName\u0026#34;,\u0026#34;FileVersion\u0026#34;,\u0026#34;FilePath\u0026#34;,\u0026#34;FileHash\u0026#34;,\u0026#34;Users\u0026#34;,\u0026#34;Devices\u0026#34;,\u0026#34;ElevationType\u0026#34;,\u0026#34;Group\u0026#34;\r\u0026#34;6\u0026#34;,\u0026#34;Microsoft¬Æ Windows¬Æ Operating System\u0026#34;,\u0026#34;Windows PowerShell\u0026#34;,\u0026#34;Microsoft Corporation\u0026#34;,\u0026#34;powershell.exe\u0026#34;,\u0026#34;POWERSHELL\u0026#34;,\u0026#34;10.0.19041.2913\u0026#34;,\u0026#34;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\u0026#34;,\u0026#34;B4E7BC24BF3F5C3DA2EB6E9EC5EC10F90099DEFA91B820F2F3FC70DD9E4785C4\u0026#34;,\u0026#34;AzureAD\\AlexWilber AzureAD\\ChristieCline\u0026#34;,\u0026#34;DESKTOP-DL6CCRJ DESKTOP-7KFLL12\u0026#34;,\u0026#34;Automatic/UserAuthentication/UserJustification\u0026#34;,\u0026#34;GroupName\u0026#34;\r\u0026#34;4\u0026#34;,\u0026#34;PaladinVPN\u0026#34;,\u0026#34;PaladinVPN\u0026#34;,\u0026#34;Ledger Media Ltd\u0026#34;,\u0026#34;PaladinVPN.exe\u0026#34;,\u0026#34;PaladinVPN.exe\u0026#34;,\u0026#34;2.1.3.102\u0026#34;,\u0026#34;C:\\\\Program Files (x86)\\\\PaladinVPN\u0026#34;,\u0026#34;B6EF395DE2F28162DBAFCA79BAABEBB211245A68425CE096402030417FEA1160\u0026#34;,\u0026#34;AzureAD\\AlexWilber\u0026#34;,\u0026#34;DESKTOP-DL6CCRJ\u0026#34;,\u0026#34;Automatic/UserAuthentication/UserJustification\u0026#34;,\u0026#34;GroupName\u0026#34;\r\u0026#34;12\u0026#34;,\u0026#34;Microsoft¬Æ Windows¬Æ Operating System\u0026#34;,\u0026#34;Windows Command Processor\u0026#34;,\u0026#34;Microsoft Corporation\u0026#34;,\u0026#34;cmd.exe\u0026#34;,\u0026#34;cmd\u0026#34;,\u0026#34;10.0.19041.746\u0026#34;,\u0026#34;C:\\\\Windows\\\\system32\u0026#34;,\u0026#34;B99D61D874728EDC0918CA0EB10EAB93D381E7367E377406E65963366C874450\u0026#34;,\u0026#34;AzureAD\\AlexWilber AzureAD\\ChristieCline\u0026#34;,\u0026#34;DESKTOP-DL6CCRJ DESKTOP-7KFLL12\u0026#34;,\u0026#34;Automatic/UserAuthentication/UserJustification\u0026#34;,\u0026#34;GroupName\u0026#34; Now we have something to review, with two additional fields of ElevationType and Group that we will use for creation of new EPM policies and rules later on, forward planning here.\nEPM Policies # I have no shame when I say that I started from Andrew Taylor\u0026rsquo;s script to create EPM rules using PowerShell, allowing the creation of new EPM Policies and associated rules in Microsoft Intune based on a local files on the machine the script is being executed from. For me what this was missing was the ability to create multiple rules per EPM policy, and the to not rely on the file being local to the machine running the script to capture the required rule data.\nImporting Rule Data # With the CSV report exported, we now need to update the file itself, removing entries where we don\u0026rsquo;t want to create rules, and updating those we do want to create with both the ElevationType and Group for each rule we want to create. The ElevationType field needs to be populated with one of the below entries based on the approval type to be used:\nAutomatic: elevation happens invisibly to the user. There\u0026rsquo;s no prompt, and no indication that the file is running in an elevated context. UserAuthentication: A user confirmed elevation always requires the user to click on a confirmation prompt to run the file requiring users to authenticate using their organization credentials. UserJustification: A user confirmed elevation always requires the user to click on a confirmation prompt to run the file requiring the user to enter a business justification. The group field is there to not only reference which Azure Active Directory or synchronised Active Directory group the rule will apply to, but will allow for grouping of rules into a single policy, as this just makes sense as we\u0026rsquo;ll be applying the policy to the same group.\nGrouping EPM Rules # As we want to create a single policy for each provided group, containing all applicable rules, we need to capture the data based on the assignment group, this can be done pretty easily using the Group-Object command.\n$Policies = Import-Csv -Path $ImportPath | Group-Object -Property Group Now we can check if the supplied group exists, using the below function to search for the group based on it\u0026rsquo;s name.\nFunction Get-IntuneGroup() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] [string]$Name ) $graphApiVersion = \u0026#39;beta\u0026#39; $Resource = \u0026#39;groups\u0026#39; try { $authToken[\u0026#39;ConsistencyLevel\u0026#39;] = \u0026#39;eventual\u0026#39; $searchterm = \u0026#39;search=\u0026#34;displayName:\u0026#39; + $Name + \u0026#39;\u0026#34;\u0026#39; $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource`?$searchterm\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Take note of the change to the $authtoken variable which needs updating to include \u0026lsquo;ConsistencyLevel\u0026rsquo; to support advanced queries using Graph API. We can ensure that the group exists prior to deploying the EPM policies to Microsoft Intune, and set the variables for each new rule to be created based on the data in the CSV file.\nforeach ($Policy in $Policies) { $Group = Get-IntuneGroup -Name $Policy.Name if ($null -eq $Group) { Write-Output \u0026#34;$($Policy.Name) group does not exist, unable to create EPM Policy\u0026#34; break } else { $Rules = $Policy.Group $JSONRules = @() foreach ($Rule in $Rules) { $FileName = $Rule.FileName $FileInternalName = $Rule.FileInternalName $FilePath = $Rule.FilePath $FileHash = $Rule.FileHash $ElevationType = $Rule.ElevationType $FileProduct = $Rule.Product -replace \u0026#39;[^\\x30-\\x39\\x41-\\x5A\\x61-\\x7A]+\u0026#39;, \u0026#39; \u0026#39; $FileDescription = $Rule.Description $RuleDescription = $($Rule.Publisher + \u0026#39; \u0026#39; + $Rule.Description) -replace \u0026#39;[^\\x30-\\x39\\x41-\\x5A\\x61-\\x7A]+\u0026#39;, \u0026#39; \u0026#39; Now onto the fun that is EPM policy and rule creation.\nCreating Settings Catalog Policies # The EPM Policies sit within the Setting Catalog space in Microsoft Intune, and it\u0026rsquo;s no secret that creating new Settings Catalog policies in Microsoft Intune is no walk in the park as per this post from Powers Hell. Our issue, in addition to Settings Catalogs creation being a pain in the arse, is that we want to create multiple rules in one EPM policy which comes with it\u0026rsquo;s own headache.\nUsing add-epmfilerule.ps1 and exports of EPM policies using Intune PowerShell Samples as a basis for the JSON structure, we can build the policy with multuple rules in stages with separate sections for the policy and rules.\nPolicy Start JSON # Easy one to start with as this section will be the same for each policy created, passing in variables from the imported CSV report.\n$JSONPolicyStart = @\u0026#34; { \u0026#34;description\u0026#34;: \u0026#34;EPM Policy for $($Group.displayName)\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;EPM Policy for $($Group.displayName)\u0026#34;, \u0026#34;platforms\u0026#34;: \u0026#34;windows10\u0026#34;, \u0026#34;settings\u0026#34;: [ { \u0026#34;settingInstance\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationGroupSettingCollectionInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;ee3d2e5f-6b3d-4cb1-af9b-37b02d3dbae2\u0026#34; }, \u0026#34;groupSettingCollectionValue\u0026#34;: [ \u0026#34;@ Policy End JSON # This finishes off the JSON file needed to submit to Graph API, again this will be the same for each EPM policy.\n$JSONPolicyEnd = @\u0026#34; ] } } ], \u0026#34;technologies\u0026#34;: \u0026#34;endpointPrivilegeManagement\u0026#34;, \u0026#34;templateReference\u0026#34;: { \u0026#34;templateId\u0026#34;: \u0026#34;cff02aad-51b1-498d-83ad-81161a393f56_1\u0026#34; } } \u0026#34;@ That\u0026rsquo;s the simple part done, now to get our head around the rules.\nCreating the Initial Rule # The first rule in an EPM policy has differing JSON formatting than any subsequent rules, requiring settingValueTemplateId values. We\u0026rsquo;ll use logic in the PowerShell script to identify whether the each rule is the first in the list by querying the array of rules to check if the rule being processed is the first.\nInitial Rule Start JSON # The variables we created, and populated by the CSV file, are added to the JSON for the following values:\nRule Description Application Product Name Application Internal Name File Hash $JSONRuleStart = @\u0026#34; { \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_appliesto\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;0cde1c42-c701-44b1-94b7-438dd4536128\u0026#34; }, \u0026#34;choiceSettingValue\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_allusers\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;2ec26569-c08f-434c-af3d-a50ac4a1ce26\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false }, \u0026#34;children\u0026#34;: [] } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_description\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;b3714f3a-ead8-4682-a16f-ffa264c9d58f\u0026#34; }, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$RuleDescription\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;5e82a1e9-ef4f-43ea-8031-93aace2ad14d\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false } } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_productname\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;234631a1-aeb1-436f-9e05-dcd9489caf08\u0026#34; }, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$FileProduct\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;e466f96d-0633-40b3-86a4-9e093b696077\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false } } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_internalname\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;08511f12-25b5-4218-812c-39a2db444ef1\u0026#34; }, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$FileInternalName\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;ec295dd4-6bbc-4fa8-a503-960784c53f41\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false } } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_filehash\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;e4436e2c-1584-4fba-8e38-78737cbbbfdf\u0026#34; }, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$FileHash\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;1adcc6f7-9fa4-4ce3-8941-2ce22cf5e404\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false } } }, \u0026#34;@ Initial Rule Elevation JSON # Based on the updated $ElevationType variable in the CSV file, we can define which of the below three elevation type JSON formats are passed into the policy JSON.\nInitial Rule Elevation Automatic # $JSONRuleElev = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance\u0026#34;, \u0026#34;choiceSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue\u0026#34;, \u0026#34;children\u0026#34;: [], \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;cb2ea689-ebc3-42ea-a7a4-c704bb13e3ad\u0026#34; }, \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_automatic\u0026#34; }, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;bc5a31ac-95b5-4ec6-be1f-50a384bb165f\u0026#34; } }, \u0026#34;@ Initial Rule Elevation User Authentication # $JSONRuleElev = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance\u0026#34;, \u0026#34;choiceSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue\u0026#34;, \u0026#34;children\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingCollectionInstance\u0026#34;, \u0026#34;choiceSettingCollectionValue\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue\u0026#34;, \u0026#34;children\u0026#34;: [], \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype_validation_1\u0026#34; } ], \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype_validation\u0026#34; } ], \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;cb2ea689-ebc3-42ea-a7a4-c704bb13e3ad\u0026#34; }, \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_self\u0026#34; }, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;bc5a31ac-95b5-4ec6-be1f-50a384bb165f\u0026#34; } }, \u0026#34;@ Initial Rule Elevation User Business Justification # $JSONRuleElev = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance\u0026#34;, \u0026#34;choiceSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue\u0026#34;, \u0026#34;children\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingCollectionInstance\u0026#34;, \u0026#34;choiceSettingCollectionValue\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingValue\u0026#34;, \u0026#34;children\u0026#34;: [], \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype_validation_0\u0026#34; } ], \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype_validation\u0026#34; } ], \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;cb2ea689-ebc3-42ea-a7a4-c704bb13e3ad\u0026#34; }, \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_self\u0026#34; }, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;bc5a31ac-95b5-4ec6-be1f-50a384bb165f\u0026#34; } }, \u0026#34;@ Initial Rule End JSON # The JSON contained below tails the first rule creation, with variables passed through based on the CSV report imported data for the following values:\nFile Description Rule Name File Name File Path $JSONRuleEnd = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_filedescription\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;5e10c5a9-d3ca-4684-b425-e52238cf3c8b\u0026#34; }, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$FileDescription\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;df3081ea-4ea7-4f34-ac87-49b2e84d4c4b\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false } } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_name\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;fdabfcf9-afa4-4dbf-a4ef-d5c1549065e1\u0026#34; }, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$FileDescription $TypeDescription\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;03f003e5-43ef-4e7e-bf30-57f00781fdcc\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false } } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_filename\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;0c1ceb2b-bbd4-46d4-9ba5-9ee7abe1f094\u0026#34; }, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$FileName\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;a165327c-f0e5-4c7d-9af1-d856b02191f7\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false } } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_filepath\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: { \u0026#34;settingInstanceTemplateId\u0026#34;: \u0026#34;c3b7fda4-db6a-421d-bf04-d485e9d0cfb1\u0026#34; }, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;$FilePath\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: { \u0026#34;settingValueTemplateId\u0026#34;: \u0026#34;f011bcfc-03cd-4b28-a1f4-305278d7a030\u0026#34;, \u0026#34;useTemplateDefault\u0026#34;: false } } } ] \u0026#34;@ Creating Subsequent Rules # This is where I was on the strugglebus understanding what format the JSON needed to be in when a policy has multiple rules. Eventually I worked out that any additional rule added to the policy has different JSON formatting, with no need for the settingValueTemplateId values, so here we go.\nRule Start JSON # The variables we created are added to the JSON in the same was as the initial rule, but with a differing JSON structure.\n$JSONRuleStart = @\u0026#34; { \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_appliesto\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;choiceSettingValue\u0026#34;: { \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_allusers\u0026#34;, \u0026#34;children\u0026#34;: [] } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_description\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;$RuleDescription\u0026#34; } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_productname\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;$FileProduct\u0026#34; } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_internalname\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;$FileInternalName\u0026#34; } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_filehash\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;$FileHash\u0026#34; } }, \u0026#34;@ Rule Elevation JSON # Based on the $ElevationType variable, we can define which of the below three elevation type JSON formats are passed into the policy JSON, but this time with different JSON structure.\nRule Elevation Automatic # $JSONRuleElev = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;choiceSettingValue\u0026#34;: { \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_automatic\u0026#34;, \u0026#34;children\u0026#34;: [] } }, \u0026#34;@ Rule Elevation User Authentication # $JSONRuleElev = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;choiceSettingValue\u0026#34;: { \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_self\u0026#34;, \u0026#34;children\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingCollectionInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype_validation\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;choiceSettingCollectionValue\u0026#34;: [ { \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype_validation_1\u0026#34;, \u0026#34;children\u0026#34;: [] } ] } ] } }, \u0026#34;@ Rule Elevation User Business Justification # $JSONRuleElev = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;choiceSettingValue\u0026#34;: { \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_self\u0026#34;, \u0026#34;children\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationChoiceSettingCollectionInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype_validation\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;choiceSettingCollectionValue\u0026#34;: [ { \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_ruletype_validation_0\u0026#34;, \u0026#34;children\u0026#34;: [] } ] } ] } }, \u0026#34;@ Rule End JSON # The JSON below tails rule creation, with variables passed through based on the CSV report imported data, again with different JSON structure.\n$JSONRuleEnd = @\u0026#34; { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_filedescription\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;$FileDescription\u0026#34; } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_name\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;$FileDescription $TypeDescription\u0026#34; } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_filename\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;$FileName\u0026#34; } }, { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance\u0026#34;, \u0026#34;settingDefinitionId\u0026#34;: \u0026#34;device_vendor_msft_policy_privilegemanagement_elevationrules_{elevationrulename}_filepath\u0026#34;, \u0026#34;settingInstanceTemplateReference\u0026#34;: null, \u0026#34;simpleSettingValue\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.deviceManagementConfigurationStringSettingValue\u0026#34;, \u0026#34;settingValueTemplateReference\u0026#34;: null, \u0026#34;value\u0026#34;: \u0026#34;$FilePath\u0026#34; } } ] \u0026#34;@ Rule Ending JSON # By this point I\u0026rsquo;m tired of looking at JSON, but we need to close off the rules before we complete the policy JSON as a whole; we have to identify whether the rule being processed is last rule, as the end of the JSON for rules will need to be different, in this case whether a }, or a }, so we can use a quick query as to whether the rule being processed is the last in the array.\nif ($Rule -eq $Rules[-1]) { $JSONRuleEnding = @\u0026#39; } \u0026#39;@ } else { $JSONRuleEnding = @\u0026#39; }, \u0026#39;@ } Submitting EPM Policies # At this point we should have the all the JSON content we need, now is time to combine them all to form the master JSON which can be submitted to Graph API, but we need to firstly combine all the JSON variables, and secondly have a way to pass it to the API.\nFinal Policy JSON # Luckily we can define an array variable $JSONRules which we can add each combined rule to as we loop through each rule in the set.\n$JSONRule = $JSONRuleStart + $JSONRuleElev + $JSONRuleEnd + $JSONRuleEnding $JSONRules += $JSONRule Adding these combined rules to the $JSONPolicyStart and $JSONPolicyEnd variables will give us the required JSON file we can submit to Graph API.\n$JSONOutput = $JSONPolicyStart + $JSONRules + $JSONPolicyEnd Pushing to Graph API # JSON file complete, let\u0026rsquo;s use a function to push the data to Microsoft Intune via Graph API, as I\u0026rsquo;m not hand cranking this for every policy we want to create.\nFunction New-DeviceSettingsCatalog() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] $JSON ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#39;deviceManagement/configurationPolicies\u0026#39; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Post -Body $JSON -ContentType \u0026#39;application/json\u0026#39; } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } We can now pass through the $JSONOutput variable to the above function.\n$EPMPolicy = New-DeviceSettingsCatalog -JSON $JSONOutput With this we now have a method to push new policies, and if required, with multiple rules to Microsoft Intune.\nAssigning EPM Policies # Now we have a way to create new EPM policies and rules, grouping the rules by the assignment group, it would only be right to square this all off by assigning the policy to the same group, outrageous I know. To do this we need another function using the deviceManagement/configurationPolicies/$Id/assign Graph API endpoint to create a new Settings Catalog policy assignment.\nFunction Add-DeviceSettingsCatalogAssignment() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] [string]$Id, [parameter(Mandatory = $false)] [string]$Name, [parameter(Mandatory = $true)] [string]$TargetGroupId, [parameter(Mandatory = $true)] [ValidateSet(\u0026#39;Include\u0026#39;, \u0026#39;Exclude\u0026#39;)] [string]$AssignmentType ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceManagement/configurationPolicies/$Id/assign\u0026#34; try { $TargetGroup = New-Object -TypeName psobject if ($AssignmentType -eq \u0026#39;Exclude\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.exclusionGroupAssignmentTarget\u0026#39; } elseif ($AssignmentType -eq \u0026#39;Include\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.groupAssignmentTarget\u0026#39; } $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;groupId\u0026#39; -Value \u0026#34;$TargetGroupId\u0026#34; $Target = New-Object -TypeName psobject $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;target\u0026#39; -Value $TargetGroup $TargetGroups = $Target # Creating JSON object to pass to Graph $Output = New-Object -TypeName psobject $Output | Add-Member -MemberType NoteProperty -Name \u0026#39;assignments\u0026#39; -Value @($TargetGroups) $JSON = $Output | ConvertTo-Json -Depth 3 # POST to Graph Service $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Post -Body $JSON -ContentType \u0026#39;application/json\u0026#39; Write-Host \u0026#34;Successfully assigned policy $Name\u0026#34; -ForegroundColor Green } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } We can finally assign the policy passing through the required information from the $EPMPolicy variable that contains the details of the newly created EPM policy.\nAdd-DeviceSettingsCatalogAssignment -id $EPMPolicy.id -TargetGroupId $Group.id -AssignmentType Include If you\u0026rsquo;re still with me, and you probably are as I haven\u0026rsquo;t posted the full script yet, congratulations, we\u0026rsquo;re almost there.\nEPM Policy Deployment # We\u0026rsquo;re here, finally, with a complete PowerShell Script ready to be used and abused. Let\u0026rsquo;s look at the options we have when running the script.\nReport Mode # Running the script with the below parameters we can export the existing Unmanaged elevations to a location of our choosing that you will be prompted for after running the script.\n./Invoke-EPNRules.ps1 -User username@contoso.com -Deployment Report This CSV file can then updated with the elevation types and groups the rules can be assigned to, as per the example below.\n\u0026#34;ElevationCount\u0026#34;,\u0026#34;Product\u0026#34;,\u0026#34;Description\u0026#34;,\u0026#34;Publisher\u0026#34;,\u0026#34;FileName\u0026#34;,\u0026#34;FilePath\u0026#34;,\u0026#34;FileHash\u0026#34;,\u0026#34;Users\u0026#34;,\u0026#34;Devices\u0026#34;,\u0026#34;ElevationType\u0026#34;,\u0026#34;Group\u0026#34;\r\u0026#34;6\u0026#34;,\u0026#34;Microsoft¬Æ Windows¬Æ Operating System\u0026#34;,\u0026#34;Windows PowerShell\u0026#34;,\u0026#34;Microsoft Corporation\u0026#34;,\u0026#34;powershell.exe\u0026#34;,\u0026#34;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\u0026#34;,\u0026#34;B4E7BC24BF3F5C3DA2EB6E9EC5EC10F90099DEFA91B820F2F3FC70DD9E4785C4\u0026#34;,\u0026#34;AzureAD\\AlexWilber AzureAD\\ChristieCline\u0026#34;,\u0026#34;DESKTOP-DL6CCRJ DESKTOP-7KFLL12\u0026#34;,\u0026#34;UserJustification\u0026#34;,\u0026#34;sg-IT\u0026#34;\r\u0026#34;4\u0026#34;,\u0026#34;PaladinVPN\u0026#34;,\u0026#34;PaladinVPN\u0026#34;,\u0026#34;Ledger Media Ltd\u0026#34;,\u0026#34;PaladinVPN.exe\u0026#34;,\u0026#34;C:\\\\Program Files (x86)\\\\PaladinVPN\u0026#34;,\u0026#34;B6EF395DE2F28162DBAFCA79BAABEBB211245A68425CE096402030417FEA1160\u0026#34;,\u0026#34;AzureAD\\AlexWilber\u0026#34;,\u0026#34;DESKTOP-DL6CCRJ\u0026#34;,\u0026#34;Automatic\u0026#34;,\u0026#34;sg-Operations\u0026#34;\r\u0026#34;12\u0026#34;,\u0026#34;Microsoft¬Æ Windows¬Æ Operating System\u0026#34;,\u0026#34;Windows Command Processor\u0026#34;,\u0026#34;Microsoft Corporation\u0026#34;,\u0026#34;cmd.exe\u0026#34;,\u0026#34;C:\\\\Windows\\\\system32\u0026#34;,\u0026#34;B99D61D874728EDC0918CA0EB10EAB93D381E7367E377406E65963366C874450\u0026#34;,\u0026#34;AzureAD\\AlexWilber AzureAD\\ChristieCline\u0026#34;,\u0026#34;DESKTOP-DL6CCRJ DESKTOP-7KFLL12\u0026#34;,\u0026#34;UserAuthentication\u0026#34;,\u0026#34;sg-IT\u0026#34; Create Mode # The CSV file can then be used for the creation of rules using the below command (you will be prompted for the path to the CSV file).\n./Invoke-EPNRules.ps1 -User username@contoso.com -Deployment Import Which will result in the EPM policies being created:\nDrilling into the EPM policy we can see the rules that were created:\nDigging a little further we can see the settings for the rules:\nPowerShell User Approved with Business Justification Command Prompt User Approved with Authentication Create and Assign Mode # Or if you want to be reckless bold and create and assign the policies, use the below (you will be prompted for the path to the CSV file).\n./Invoke-EPNRules.ps1 -User username@contoso.com -Deployment ImportAssign Which will give us the above policies created, but also assigned to the relevant groups:\nSummary # This script doesn\u0026rsquo;t take into consideration the members of the groups as part of the assignment, and subsequently any conflict or crossover of rules on a per user or device basis, but then I can\u0026rsquo;t script every step of logic as part of an Endpoint Privilege Management implementation, you still have to use your brain somewhere along the way.\nWhat it does give you is an ability to readily identify the priority of elevations required by your user base, a way to review the applications actively being elevated, and importantly a way to use this data and information to automatically create Endpoint Privilege Management policies and rules without the risk of human error when creating rules manually.\n","date":"1 June 2023","permalink":"/posts/automate-endpoint-privilege-management/","section":"Blog","summary":"So you‚Äôre interested in Endpoint Privilege Management in Microsoft Intune and in you‚Äôre excitement you‚Äôve gone and deployed a new policy to audit using the Reporting Scope options, all elevations across your managed Windows 10 and later devices. Now what?","title":"Automating Endpoint Privilege Management Policies with PowerShell"},{"content":"","date":"1 June 2023","permalink":"/tags/epm/","section":"Tags","summary":"","title":"Endpoint Privilege Management"},{"content":"","date":"2 April 2023","permalink":"/tags/antivirus/","section":"Tags","summary":"","title":"Antivirus"},{"content":"","date":"2 April 2023","permalink":"/tags/compliance/","section":"Tags","summary":"","title":"Compliance"},{"content":"Introduction # So what happens when you\u0026rsquo;re not using Windows Defender on your Windows 10 and later Microsoft Intune enrolled devices, and you\u0026rsquo;re not happy with the basic compliance checks for Third-Party Antivirus products?\nMicrosoft have come to the rescue with their Custom Compliance Settings, so let\u0026rsquo;s utilise this detect and check policy, and leverage it to detect and report on Non-Microsoft Antivirus products, their real time protection status, as well as whether the definitions are up to date.\nCustom Compliance Policies # As Custom Compliance isn\u0026rsquo;t that new a feature of Microsoft Intune, I\u0026rsquo;m not going to deep dive into the process, a number of other people have done that already:\nPeter van der Woude Call4Cloud Device Advice We\u0026rsquo;re going to focus on how to use it to achieve our goal, detecting additional information about third-party Antivirus solutions.\nPowerShell and WMI # We need a way to get information about the expected active Antivirus product, in this instance \u0026lsquo;Sophos Antivirus\u0026rsquo;, installed on device; to do this we can use the WMI Class AntiVirusProduct within the root\\SecurityCenter2 namespace.\nGet-WmiObject -Namespace \u0026#34;root\\SecurityCenter2\u0026#34; -Class AntiVirusProduct This will pull back details about the Antivirus software registered by Windows, as you can see from the below, it will pull back all products registered, including Windows Defender.\n__GENUS : 2 __CLASS : AntiVirusProduct __SUPERCLASS : __DYNASTY : AntiVirusProduct __RELPATH : AntiVirusProduct.instanceGuid=\u0026#34;{8E0623B8-CF1C-DFFE-CEA3-AA41BDA4B8EE}\u0026#34; __PROPERTY_COUNT : 6 __DERIVATION : {} __SERVER : LT01540 __NAMESPACE : ROOT\\SecurityCenter2 __PATH : \\\\LT01540\\ROOT\\SecurityCenter2:AntiVirusProduct.instanceGuid=\u0026#34;{8E0623B8-CF1C-DFFE-CEA3-AA41BDA4B8EE}\u0026#34; displayName : Sophos Anti-Virus instanceGuid : {8E0623B8-CF1C-DFFE-CEA3-AA41BDA4B8EE} pathToSignedProductExe : C:\\Program Files (x86)\\Sophos\\Sophos Anti-Virus\\WSCClient.exe pathToSignedReportingExe : C:\\Program Files (x86)\\Sophos\\Sophos Anti-Virus\\WSCClient.exe productState : 331776 timestamp : Tue, 16 Nov 2021 17:29:40 GMT __GENUS : 2 __CLASS : AntiVirusProduct __SUPERCLASS : __DYNASTY : AntiVirusProduct __RELPATH : AntiVirusProduct.instanceGuid=\u0026#34;{D68DDC3A-831F-4fae-9E44-DA132C1ACF46}\u0026#34; __PROPERTY_COUNT : 6 __DERIVATION : {} __SERVER : __NAMESPACE : ROOT\\SecurityCenter2 __PATH : \\\\\\ROOT\\SecurityCenter2:AntiVirusProduct.instanceGuid=\u0026#34;{D68DDC3A-831F-4fae-9E44-DA132C1ACF46}\u0026#34; displayName : Windows Defender instanceGuid : {D68DDC3A-831F-4fae-9E44-DA132C1ACF46} pathToSignedProductExe : windowsdefender:// pathToSignedReportingExe : %ProgramFiles%\\Windows Defender\\MsMpeng.exe productState : 393472 timestamp : Thu, 16 Dec 2021 10:49:39 GMT So we will need a way to filter only to the expected active Antivirus software installed.\nAntivirus Product State # With the information available about the Antivirus products, we need to be able to identify whether Real Time Protection is running, as well as whether the Definitions are up to date. I\u0026rsquo;d say luckily, but I\u0026rsquo;d be lying, we have the productState information to work with.\nproductState : 393472 This hex value does translate into something we can use to identify the definition and protection status checks, and thanks to Marc Schneider we can actually understand this number and how to use it as part of a Custom Compliance policy.\nThe six-digit value for \u0026lsquo;productState\u0026rsquo; can be broken down into three pairs of two-digits, with each actually meaning something once converted to a hex string:\n1st Pair: Product Type 2nd Pair: Real Time Protection Status 3rd Pair: Definition Status The 2nd and 3rd pair may report differently depending on your Antivirus product, as detailed in this post, so you will have to check this on a device with up-to-date definitions as well as real time protection enabled to be sure. The values for each of these pairs for Sophos Antivirus can be seen below:\nItem Values Description Real Time Protection Status 00 Off 01 Expired 10 On 11 Snoozed Definition Status 00 Up to Date 10 Out of Date So we now have a way to identify and confirm that both Real Time protection is enabled, and Definitions are in place for the Antivirus product of choosing.\nDetection Script Creation # With a couple of variables, some hex conversion, switches, and a little bit of logic, we can get the information we need and throw it into the JSON format required by Microsoft to allow the Custom Compliance script to work as expected.\nWe\u0026rsquo;ve used the $AVClient variable, which will allow re-use of the script depending on which product is installed across your device estate.\nWe also have to be able to capture and present back when the script doesn\u0026rsquo;t detect the specified $AVClient variable, otherwise we\u0026rsquo;ll get some grim looking compliance errors on those devices.\n$AVClient = \u0026#39;Sophos Anti-Virus\u0026#39; $AVProduct = Get-WmiObject -Namespace \u0026#39;root\\SecurityCenter2\u0026#39; -Class AntiVirusProduct | Where-Object { $_.displayName -eq $AVClient } | Select-Object -First 1 $AVSummary = New-Object -TypeName PSObject If ($AVProduct) { $hexProductState = [Convert]::ToString($AVProduct.productState, 16).PadLeft(6, \u0026#39;0\u0026#39;) $hexRealTimeProtection = $hexProductState.Substring(2, 2) $hexDefinitionStatus = $hexProductState.Substring(4, 2) $RealTimeProtectionStatus = switch ($hexRealTimeProtection) { \u0026#39;00\u0026#39; { \u0026#39;Off\u0026#39; } \u0026#39;01\u0026#39; { \u0026#39;Expired\u0026#39; } \u0026#39;10\u0026#39; { \u0026#39;On\u0026#39; } \u0026#39;11\u0026#39; { \u0026#39;Snoozed\u0026#39; } default { \u0026#39;Unknown\u0026#39; } } $DefinitionStatus = switch ($hexDefinitionStatus) { \u0026#39;00\u0026#39; { \u0026#39;Up to Date\u0026#39; } \u0026#39;10\u0026#39; { \u0026#39;Out of Date\u0026#39; } default { \u0026#39;Unknown\u0026#39; } } $AVSummary | Add-Member -MemberType NoteProperty -Name \u0026#34;$AVClient\u0026#34; -Value $AVProduct.displayName $AVSummary | Add-Member -MemberType NoteProperty -Name \u0026#34;$AVClient real time protection enabled\u0026#34; -Value $RealTimeProtectionStatus $AVSummary | Add-Member -MemberType NoteProperty -Name \u0026#34;$AVClient definitions up-to-date\u0026#34; -Value $DefinitionStatus } Else { $AVSummary | Add-Member -MemberType NoteProperty -Name \u0026#34;$AVClient\u0026#34; -Value \u0026#39;Error: No Antivirus product found\u0026#39; $AVSummary | Add-Member -MemberType NoteProperty -Name \u0026#34;$AVClient real time protection enabled\u0026#34; -Value \u0026#39;Error: No Antivirus product found\u0026#39; $AVSummary | Add-Member -MemberType NoteProperty -Name \u0026#34;$AVClient definitions up-to-date\u0026#34; -Value \u0026#39;Error: No Antivirus product found\u0026#39; } return $AVSummary | ConvertTo-Json -Compress Running this script on a machine with the Antivirus product installed would be a good idea to test that the scripts works, and is outputting the correct information in the required format for Intune to translate.\nThe output from the script should look a little bit like the below:\n{\u0026#34;Sophos Anti-Virus\u0026#34;:\u0026#34;Sophos Anti-Virus\u0026#34;,\u0026#34;Sophos Anti-Virus real time protection enabled\u0026#34;:\u0026#34;On\u0026#34;,\u0026#34;Sophos Anti-Virus definitions up-to-date\u0026#34;:\u0026#34;Up to Date\u0026#34;} JSON Checks # As we\u0026rsquo;ve seen in the JSON check requirements from Microsoft, we now need to build out a JSON file using the template as a starter, making sure that our JSON output from the script can be translated into something the Custom Compliance Policy can use.\nBelow is the updated JSON content we can use for the check, I\u0026rsquo;ve kept this quite light touch if I\u0026rsquo;m honest, and not specific to the Antivirus product, again so this can be re-used without changing a million things.\nYou will need to change the Operand for the first Rule to match the Antivirus product name you have installed, and if you want to, feel free to update the following fields to your taste:\nMoreInfoUrl Title Description But leave the rest alone, otherwise you\u0026rsquo;ll break stuff.\n{ \u0026#34;Rules\u0026#34;: [ { \u0026#34;SettingName\u0026#34;: \u0026#34;Sophos Anti-Virus\u0026#34;, \u0026#34;Operator\u0026#34;: \u0026#34;IsEquals\u0026#34;, \u0026#34;DataType\u0026#34;: \u0026#34;String\u0026#34;, \u0026#34;Operand\u0026#34;: \u0026#34;Sophos Anti-Virus\u0026#34;, \u0026#34;MoreInfoUrl\u0026#34;: \u0026#34;https://www.google.com\u0026#34;, \u0026#34;RemediationStrings\u0026#34;: [ { \u0026#34;Language\u0026#34;: \u0026#34;en_US\u0026#34;, \u0026#34;Title\u0026#34;: \u0026#34;Incorrect Antivirus solution detected. Value discovered was {ActualValue}.\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Install correct Antivirus solution.\u0026#34; } ] }, { \u0026#34;SettingName\u0026#34;: \u0026#34;Sophos Anti-Virus real time protection enabled\u0026#34;, \u0026#34;Operator\u0026#34;: \u0026#34;IsEquals\u0026#34;, \u0026#34;DataType\u0026#34;: \u0026#34;String\u0026#34;, \u0026#34;Operand\u0026#34;: \u0026#34;On\u0026#34;, \u0026#34;MoreInfoUrl\u0026#34;: \u0026#34;https://www.google.com\u0026#34;, \u0026#34;RemediationStrings\u0026#34;: [ { \u0026#34;Language\u0026#34;: \u0026#34;en_US\u0026#34;, \u0026#34;Title\u0026#34;: \u0026#34;Real time protection is not enabled\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Real time protection must be enabled.\u0026#34; } ] }, { \u0026#34;SettingName\u0026#34;: \u0026#34;Sophos Anti-Virus definitions up-to-date\u0026#34;, \u0026#34;Operator\u0026#34;: \u0026#34;IsEquals\u0026#34;, \u0026#34;DataType\u0026#34;: \u0026#34;String\u0026#34;, \u0026#34;Operand\u0026#34;: \u0026#34;Up to Date\u0026#34;, \u0026#34;MoreInfoUrl\u0026#34;: \u0026#34;https://www.google.com\u0026#34;, \u0026#34;RemediationStrings\u0026#34;: [ { \u0026#34;Language\u0026#34;: \u0026#34;en_US\u0026#34;, \u0026#34;Title\u0026#34;: \u0026#34;Antivirus definitions are not up to date.\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Please update the Antivirus definitions\u0026#34; } ] } ] } Deploying Custom Compliance # We\u0026rsquo;ve now got both a PowerShell script and JSON file, so the last steps are to throw these into Microsoft Intune.\nFirst off we need to add the PowerShell script in the Compliance Scripts section.\nFollowing this, we can now create our Custom Compliance policy for Windows; select the previously created PowerShell script, and we\u0026rsquo;ll need to upload the JSON file created earlier.\nOnce we\u0026rsquo;ve got this in place, we can now assign the Compliance Policy.\nChecking Compliance State # With the Custom Compliance policy deployed, and waiting a little while for devices to start reporting back, we can check on the status of the devices it has been assigned to.\nWe have some good devices Some not so good and some truly problematic With this Compliance Policy now in place, we not only get a view of the device estate, but can integrate Compliance into Conditional Access Policies, so it\u0026rsquo;s not a bad situation to be in at all.\nSummary # Custom Compliance does seem like a bit of an effort, and it currently has minimal operators for the JSON check, an inability to add more than one PowerShell script to a single policy, an eight hour wait for the Compliance state to update after remediation, and a few other limitations, but for those organisations that aren\u0026rsquo;t fully in bed with Microsoft when it comes down to endpoint protection products, it does offer a way to extend compliance to these solutions.\n","date":"2 April 2023","permalink":"/posts/custom-compliance-third-party-av/","section":"Blog","summary":"So what happens when you\u0026rsquo;re not using Windows Defender on your Windows 10 and later Microsoft Intune enrolled devices, and you\u0026rsquo;re not happy with the basic compliance checks for Third-Party Antivirus products?","title":"Detailed Compliance for Non-Microsoft Antivirus Solutions"},{"content":"Introduction # What happens when a stranger on the Internet asks you to look at something they\u0026rsquo;ve got a problem with? Well clearly you jump at the chance and hope that it\u0026rsquo;s not a body part this time. So here we are, looking at how to deploy Microsoft Teams Backgrounds to macOS devices using Intune, for organisations without the licensing to allow for corporate branding using Microsoft Teams Premium Experience.\nTeams Meeting Backgrounds # So after a quick search, to add new backgrounds for Teams we need to dump files in ~/Library/Application Support/Microsoft/Teams/Backgrounds, this directory will exist under the logged in User context, so we\u0026rsquo;re going to need a way to both create an \u0026lsquo;Uploads\u0026rsquo; directory and dump the background files in there.\nChecking for the Teams App # Before we start throwing files in a directory, we should probably check to see if Teams is actually installed, luckily having spent many evenings peering over the macOS Shell Scripts hosted in Intune Shell Scripts, we can use the Dock Customisation script, as there\u0026rsquo;s a section in there that waits for the detection of apps before allowing the script to continue.\nSo we\u0026rsquo;ll pinch that section and update it so it\u0026rsquo;s only checking for the Microsoft Teams.app\nteamsapp=\u0026#34;/Applications/Microsoft Teams.app\u0026#34; while [[ $ready -ne 1 ]]; do missingappcount=0 if [[ -a \u0026#34;$teamsapp\u0026#34; ]]; then echo \u0026#34;$(date) | $teamsapp is installed\u0026#34; else let missingappcount=$missingappcount+1 fi echo \u0026#34;$(date) | [$missingappcount] application missing\u0026#34; if [[ $missingappcount -eq 0 ]]; then ready=1 echo \u0026#34;$(date) | Teams App found, lets prep the dock\u0026#34; else echo \u0026#34;$(date) | Waiting for 10 seconds\u0026#34; sleep 10 fi done This will sit and wait for Teams to be detected, so make sure you\u0026rsquo;ve either already deployed Teams to your devices and/or have a \u0026lsquo;Required\u0026rsquo; install intent for either Microsoft Teams or Microsoft Office, in Intune.\nGetting the Logged in User # Like the Dock Customisation script, we can run the script from Intune as the signed-in user, and as we\u0026rsquo;re dealing with data in the User context, this makes the most sense. We can capture the signed-in user using the built-in $HOME variable, and creating a new teamsUpload variable to use later.\nteamsUpload=\u0026#34;$HOME/Library/Application Support/Microsoft/Teams/Backgrounds/Uploads\u0026#34; Checking the Background Directory # Right, that was easier than I thought, we should look at how to check if the directory exists, and if not create it.\nif [[ -d ${teamsUpload} ]] then echo \u0026#34;$(date) | Teams Background Upload dir [$teamsUpload] already exists\u0026#34; else echo \u0026#34;$(date) | Creating [$teamsUpload]\u0026#34; mkdir -p \u0026#34;$teamsUpload\u0026#34; fi Now onto how we get files in the directory, without just copy and pasting.\nYou may have noticed by now that I\u0026rsquo;m not explaining in much depth how the Shell commands work, well that\u0026rsquo;s because I\u0026rsquo;m still on a steep learning curve myself. Bear with me here, it ain\u0026rsquo;t PowerShell is it. Deploying Files with Shell Scripts # I already know there\u0026rsquo;s a working method to deploy a Desktop Background to a macOS device enrolled in Microsoft Intune. So we\u0026rsquo;ll do what any right minded Consultant would do, and steal modify the script to our needs.\nScript Variables # The original script used a single variable wallpaperurl to capture the desktop wallpaper URL, which is nice and all, and obviously fits the Desktop Background purpose, but we\u0026rsquo;d like to give our users options of Teams Backgrounds, so we\u0026rsquo;ll use an array to hold our list of URLs to the background files (see I am learning).\nbackgroundurls=(\u0026#34;https://memv.ennbee.uk/bgr.png\u0026#34; \u0026#34;https://memv.ennbee.uk/wp-lt.png\u0026#34; \u0026#34;https://memv.ennbee.uk/wp.png\u0026#34;) For any additional URLs, you can add a new line to the array.\nThis lack of a $ when configuring new variables is unsettling me if I\u0026rsquo;m honest, but we move. Downloading with Curl # Pretty simple really, even I can use curl to download the background files to the directory location -L, passing in the URL and a filename as part of the output -o option. We\u0026rsquo;ve added the `-s\u0026rsquo; so as to not clog the log file with the raw download data.\ncurl -s -L -o $teamsUpload/$backgroundfile $backgroundurl We now need to loop through each of the items in the backgroundurls array, and we also need to give each a filename for backgroundfile that isn\u0026rsquo;t duplicated, otherwise we\u0026rsquo;ll end up downloading and overwriting the same file for each URL in the array.\nIncremental Filenames # We can quickly create new file names as part of the for loop needed for the items in the array, by incrementing a variable, and appending that variable to the backgroundfile variable.\ni=0 for backgroundurl in \u0026#34;${backgroundurls[@]}\u0026#34;; do ((i=i+1)) backgroundfile=\u0026#34;TeamsBackground$i.png\u0026#34; ... done This will make sure that each downloaded background file gets a new filename, this won\u0026rsquo;t cater for multiple initiations of the script, but remember, I\u0026rsquo;m still new at this.\nTeams Background Script # The full script looks pretty much like the below, which is just a squishing together of the bits we\u0026rsquo;ve already covered in this post.\n#!/bin/bash #set -x # Add new background URLs to the array backgroundurls=(\u0026#34;https://memv.ennbee.uk/bgr.png\u0026#34; \u0026#34;https://memv.ennbee.uk/wp-lt.png\u0026#34; \u0026#34;https://memv.ennbee.uk/wp.png\u0026#34;) scriptname=\u0026#34;SetTeamsBackground\u0026#34; teamsapp=\u0026#34;/Applications/Microsoft Teams.app\u0026#34; logandmetadir=\u0026#34;$HOME/Library/Logs/Microsoft/Intune/Scripts/$scriptname\u0026#34; log=\u0026#34;$logandmetadir/$scriptname.log\u0026#34; teamsUpload=\u0026#34;$HOME/Library/Application Support/Microsoft/Teams/Backgrounds/Uploads\u0026#34; ## Check if the log directory has been created if [ -d $logandmetadir ]; then ## Already created echo \u0026#34;# $(date) | Log directory already exists - $logandmetadir\u0026#34; else ## Creating Metadirectory echo \u0026#34;# $(date) | creating log directory - $logandmetadir\u0026#34; mkdir -p \u0026#34;$logandmetadir\u0026#34; fi # start logging exec 1\u0026gt;\u0026gt; \u0026#34;$log\u0026#34; 2\u0026gt;\u0026amp;1 ## Checking if Teams is Installed while [[ $ready -ne 1 ]];do missingappcount=0 if [[ -a \u0026#34;$teamsapp\u0026#34; ]]; then echo \u0026#34;$(date) | $teamsapp is installed\u0026#34; else let missingappcount=$missingappcount+1 fi echo \u0026#34;$(date) | [$missingappcount] application missing\u0026#34; if [[ $missingappcount -eq 0 ]]; then ready=1 echo \u0026#34;$(date) | Teams App found, lets download the backgrounds\u0026#34; else echo \u0026#34;$(date) | Waiting for 10 seconds\u0026#34; sleep 10 fi done ## Checking if Teams Backgrounds Upload directory exists and create it if it\u0026#39;s missing if [[ -d ${teamsUpload} ]] then echo \u0026#34;$(date) | Teams Background Upload dir [$teamsUpload] already exists\u0026#34; else echo \u0026#34;$(date) | Creating [$teamsUpload]\u0026#34; mkdir -p \u0026#34;$teamsUpload\u0026#34; fi ## Attempt to download the files. i=0 for backgroundurl in \u0026#34;${backgroundurls[@]}\u0026#34;; do ((i=i+1)) backgroundfile=\u0026#34;TeamsBackground$i.png\u0026#34; echo \u0026#34;$(date) | Downloading Background from [$backgroundurl] to [$teamsUpload/$backgroundfile]\u0026#34; curl -L -o \u0026#34;$teamsUpload/$backgroundfile\u0026#34; $backgroundurl if [ \u0026#34;$?\u0026#34; = \u0026#34;0\u0026#34; ]; then echo \u0026#34;$(date) | Teams Background [$backgroundurl] downloaded to [$teamsUpload/$backgroundfile]\u0026#34; else echo \u0026#34;$(date) | Failed to download Teams Background image from [$backgroundurl]\u0026#34; fi done Time to add this into Intune and reap the rewards.\nIntune Shell Scripts # As with everything Microsoft, there are some requirements and limitations with using Shell Scripts for macOS so have a read before you blindly start trying to push out scripts to your device estate. After you\u0026rsquo;ve read these requirements, create a new Shell Script with the below settings.\nItem Setting Shell script downloadTeamsBackground.sh File contents Uploaded Script Run script as signed-in user Yes Hide script notifications on devices Not Configured Script frequency Not Configured Max number of times to retry if script fails 3 times Looking a little like the below.\nNow we\u0026rsquo;ve added the Shell Script, this can be deployed to the \u0026lsquo;All Users\u0026rsquo;, \u0026lsquo;All Devices\u0026rsquo; groups (Don\u0026rsquo;t do this as we don\u0026rsquo;t have Device Filters to use) or Groups of your choosing.\nChecking Microsoft Teams # With the Script deployed from Intune and assigned to a group of devices, we can check on the devices themselves to make sure that the script has run successfully using the log file, checking that the new backgrounds have downloaded to the correct directory, and that these backgrounds appear in Microsoft Teams.\nScript Logging # As per the configured variable in the script, we can find the log $HOME/Library/Logs/Microsoft/Intune/Scripts/SetTeamsBackground/SetTeamsBackground.log, opening it we can check on the status of the downloads.\nEverything looks solid we should check the download directory.\nBackground Directory # As we can see three files in the Uploads directory, all named appropriately.\nTeams Background Effects # Last check is in a Microsoft Teams meeting.\nAll good here as well, we can relax and have a coffee.\nIf Microsoft Teams was open when the backgrounds were deployed, it will need a restart to pick up the new backgrounds. I did think about force quitting the app, but didn\u0026rsquo;t think users would appreciate that. Summary # This was a pretty straight forward method to deploy backgrounds to Microsoft Teams using Intune Shell Scripts, and not a bad start to my journey into advanced management of macOS devices (despite actually being a macOS user). I\u0026rsquo;d recommend familiarising yourself with the Intune Shell Samples, as this is where started when hacking about with Shell scripts for macOS devices.\nOr you could just pay for Microsoft Teams Premium, but where\u0026rsquo;s the fun in that?\n","date":"14 March 2023","permalink":"/posts/macos-teams-backgrounds/","section":"Blog","summary":"What happens when a stranger on the Internet asks you to look at something they\u0026rsquo;ve got a problem with? Here we are, looking at how to deploy Microsoft Teams Backgrounds to macOS devices.","title":"Deploying Teams Backgrounds to macOS Devices"},{"content":"Introduction # As both Microsoft Intune and Configuration Manager are a match made in heaven, there are many reasons to still utilise both, either using Co-Management or just plain old Tenant Attach, so imagine my joy when Microsoft released Co-Management Authority in Intune, and I thought the days of packaging the Configuration Manager Client were over.\nNow imagine my face when I read the requirements and the fact it doesn\u0026rsquo;t support Autopilot Hybrid Join scenarios.\nI get it, installing the client during Autopilot will pretty much break the deployment, but there should be a way to install the client and not have it bend over and only accept Configuration Manager deployed workloads.\nPackaging the Configuration Manager Client has been covered, many, many, many, many times, almost to death in fact, so I\u0026rsquo;m not going to show you how to package the client files, what I am going to show you is a couple of tricks to make the installation easier, and not break Autopilot.\nApp Requirement Rules # To stop the application from running during the Autopilot process, we can add in a Requirement Rule to ensure that we\u0026rsquo;re not in the Out of Box Experience (OOBE). We\u0026rsquo;ve got a couple of options here, whether it\u0026rsquo;s detecting if the CloudExperienceHostBroker Service is running, or if the User account context is running under defaultUser0.\nI\u0026rsquo;ve gone with the Service approach, as it saves Intune having to run Get-ComputerInfo -Property CsUserName every time it wants to check if the requirement has been met.\nWith this, we can create a Requirement Rule Script using the below to check if the CloudExperienceHostBroker service is running, and if not returning Install:\n$ESPProcess = Get-Process -Name CloudExperienceHostBroker -ErrorAction SilentlyContinue if ($ESPProcess.Count -eq 0) { Return \u0026#39;Install\u0026#39; } Pretty straight forward for one of my documented scripts, but either way, save the file locally as something you can remember.\nCreate the rule in Intune with the below settings:\nItem Setting Requirement Type Script Script Name Autopilot_Not_Running.ps1 Script content {{Script Content}} Run script as 32-bit process on 64-bit clients No Run this script using the logged on credentials No Enforce script signature check No Select Output data type String Operator Equals Value Install Giving us something like this:\nThis will now stop the installation from even starting during Autopilot phase, and only start the installation once the requirement has been met.\nApp Detection Methods # Now that we can control when the Client is installed, we need a way to detect that it has installed, and to be honest, we don\u0026rsquo;t actually care if the Client itself has installed correctly, as the Client setup will just sit and try to install itself every ten minutes until it can.\nIf we had a detection rule for either the MSI product code, or a File check for the client itself, we\u0026rsquo;d be waiting for an absolute age for Intune to be happy and confirm the installation state. We do not want this.\nWhat we do want, is a quick and easy way to ensure that the setup files exist on the device, then we can let the ccmsetup.exe do it\u0026rsquo;s magical thing and install the Client and the associated service.\nSo for the detection rule, we\u0026rsquo;ll just look for the presence of the setup file:\nItem Setting Rule Type File Path %windir%\\ccmsetup File or Folder ccmsetup.exe Detection Method File or Folder Exists Associated with a 32-bit app on 64-bit client No This looks a little bit like the below:\nAllowing for a quick and easy detection of the required setup files on the device.\nIntune Only Mode # If you\u0026rsquo;re wanting Intune to manage all the workloads on the device, and not rely on Co-Managed Workloads at all, there is a solution for this, and one taken straight from Microsoft and their implementation of the Co-Management Authority in Intune.\nYour endpoints enrolled in Intune today have a concept of management authority. That authority tells the device what service owns the management of the workloads on that device. The authority owner can be tracked by a simple registry key and value. This is the value that they\u0026rsquo;re on about:\nHKLM:\\SOFTWARE\\Microsoft\\DeviceManageabilityCSP\\Provider\\MS DM Server When provisioning a device with Autopilot, the above key gets created right after you enter your username and password on the enrolment screen. This key tells the device who the authority is for workload management* Here\u0026rsquo;s the legend for the key:\n1 ‚Äì Intune 2 ‚Äì Configuration Manager Right, so if we really wanted to stick with Intune as the management authority here, we can leverage the above information and force the device to stick with Intune for it\u0026rsquo;s management needs, and in the case of App deployment, the device will still receive Apps from both Intune and Configuration Manger if the key value is set to Intune.\nProactive Remediation # As I\u0026rsquo;ve mentioned previously if you\u0026rsquo;re licensed to use Proactive Remediation Scripts, you should be using them, and in anger. We can throw together a script that looks for the registry key HKLM:\\SOFTWARE\\Microsoft\\DeviceManageabilityCSP\\Provider\\MS DM Server\\ConfigInfo, create it if it doesn\u0026rsquo;t exist, and set it to 1 telling the device to only deal with Intune.\nDetection Script # As with all Proactive Remediation scripts, we need a method to detect, which is run initially upon assessment, and subsequently after remediation. A standard check, fix, check situation. For the detection method, we\u0026rsquo;re looking for both the Registry Key and the item.\nTry { $Registry = \u0026#39;HKLM:\\SOFTWARE\\Microsoft\\DeviceManageabilityCSP\\Provider\\MS DM Server\u0026#39; $Path = Test-Path $Registry $Authority = Get-ItemPropertyValue -Path $Registry -Name ConfigInfo -ErrorAction SilentlyContinue if ($Path -eq \u0026#39;False\u0026#39;) { Write-Warning \u0026#39;Co-Management Authority Not Configured\u0026#39; Exit 1 } else { if ($Authority -ne \u0026#39;1\u0026#39;) { Write-Warning \u0026#39;Co-Management Authority set to Configuration Manager\u0026#39; Exit 1 } else { Write-Output \u0026#39;Co-Management Authority set to Intune\u0026#39; Exit 0 } } } Catch { Write-Error $_.Exception Exit 2000 } Remediation Script # If either the Key or the Data are not detected, we have a Remediation script that configures either the Key and the Data, or just the Data.\nTry { $Registry = \u0026#39;HKLM:\\SOFTWARE\\Microsoft\\DeviceManageabilityCSP\\Provider\\MS DM Server\u0026#39; $Path = Test-Path $Registry $Authority = Get-ItemPropertyValue -Path $Registry -Name ConfigInfo -ErrorAction SilentlyContinue if ($Path -eq $False) { New-Item -Path $Registry -Force | Out-Null New-ItemProperty -Path $Registry -Name ConfigInfo -Value 1 -PropertyType String -Force } else { if ($Authority -ne \u0026#39;1\u0026#39;) { New-ItemProperty -Path $Registry -Name ConfigInfo -Value 1 -PropertyType String -Force } } } Catch { Write-Error $_.Exception Exit 2000 } Creating a Custom Script # With the above PowerShell scripts saved, we can now create our own Proactive Remediation Script and deploy this to the devices we only want to be managed by Intune, in this case, the Hybrid Joined Autopilot devices:\nMake sure you\u0026rsquo;re using 64-bit PowerShell for this script, as we don\u0026rsquo;t want anything screwy going on with the registry settings.\nSummary # We\u0026rsquo;ve managed to delay the installation of the Configuration Manager Client, as well as ensure it\u0026rsquo;s detected quickly once installed, and once it does install and the Client starts looking at Configuration Manager for it\u0026rsquo;s Co-Management settings, we\u0026rsquo;ve even got a way to tell Configuration Manager to look the other way and not break Autopilot whilst letting Intune do its thing.\nAll in all, although not a Microsoft supported method for deploying the Client, it is one that works. As you\u0026rsquo;ve realised by now, I\u0026rsquo;m not about documented good practice.\n","date":"1 March 2023","permalink":"/posts/configmgr-client-hybrid-autopilot/","section":"Blog","summary":"Installing the Configuration Manager client on Hybrid Azure AD Joined Autopilot devices should be an easy process right?","title":"Co-Managing Windows Autopilot Hybrid Join Devices"},{"content":"","date":"1 March 2023","permalink":"/tags/configmgr/","section":"Tags","summary":"","title":"Configuration Manager"},{"content":"","date":"13 February 2023","permalink":"/tags/android/","section":"Tags","summary":"","title":"Android"},{"content":"Introduction # No one, and I mean no one, really wants to manually and individually assign Mobile Apps to Users or Devices in Intune, especially after you\u0026rsquo;ve happily used a script to Approve Managed Google Play Apps in their 100\u0026rsquo;s as part of migrating to Microsoft Intune from other below par Mobile Device Management solutions.\nWe could try and use Policy Sets here, but you know, they\u0026rsquo;re in preview, and more importantly they have issues like not supporting Managed Google Play or Apple VPP apps, so that\u0026rsquo;s a no go.\nSo here we are again, throwing together functions, logic, and some kind of user interface, to allow us to assign these mobile apps in bulk with minimal headache and increase to any pre-existing repetitive strain injuries.\nMobile App Assignment # First off, before we even start looking at how we bring this all together, is to understand how we can assign an App using Graph. So as we\u0026rsquo;ve done before, we could look under the hood and check the Browser Developer Tools to see what is actually going on, or we can just check the Graph documentation.\nWith this we now know that to use the POST /deviceAppManagement/mobileApps/{mobileAppId}/assign call, we\u0026rsquo;ll need the {mobileAppId}, we\u0026rsquo;re in luck, as we\u0026rsquo;ve already got a function Get-MobileApps to do this for us.\nAssignment Types # Knowing the call to Graph is the easy bit, building the JSON data we\u0026rsquo;re sending to it using the POST request is a different story, but at least we\u0026rsquo;ve got a framework to start us off, thanks Microsoft.\n{ \u0026#34;mobileAppAssignments\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.mobileAppAssignment\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;591620b7-20b7-5916-b720-1659b7201659\u0026#34;, \u0026#34;intent\u0026#34;: \u0026#34;required\u0026#34;, \u0026#34;target\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;microsoft.graph.deviceAndAppManagementAssignmentTarget\u0026#34; }, \u0026#34;settings\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;microsoft.graph.mobileAppAssignmentSettings\u0026#34; } } ] } We\u0026rsquo;ve built JSON data in PowerShell before, so this one isn\u0026rsquo;t any different, we do however need to cater for Installation Intents, Assignment Groups, Device Filters, and Device Filter States. These can be broken down as below, with the ones we actually care about to in bold.\nItem Details Installation Intents Required, Available for Enrolled Devices, Available for Un-enrolled Devices, Uninstall Assignment Groups All Users, All Devices, Groups Filters States Include, Exclude We need to allow for the ability to assign Mobile Apps to all permutations of the above, whether this is a Required installation to All Devices, including a Device Filter, or an Available installation to a Group of Users. You get the picture.\nApp Assignment JSON # We can now start to build the JSON data we can POST to Graph, but we do need a bit more information when it comes to the content of the JSON data, in particular what is acceptable in the microsoft.graph.deviceAndAppManagementAssignmentTarget as well as how we pass through a Device Filter as part of the assignment, what headings are needed depending on the Assignment Target as well as the Install Intent.\nThe below structure details the setup for the JSON:\nmobileAppAssignments odata.type #microsoft.graph.mobileAppAssignment: This will be the same for each request intent required: Requiring the App to be installed available: Making the App available to be installed uninstall: Uninstalling the App target odata.type #microsoft.graph.groupAssignmentTarget: Assigns the App the a Group groupId: If using the group assignment, the Id of the Group #microsoft.graph.allLicensedUsersAssignmentTarget: Assigns the App the inbuilt All Users Group #microsoft.graph.allDevicesAssignmentTarget: Assigns the App the inbuilt All Devices Group deviceAndAppManagementAssignmentFilterId id: Device Filter Id deviceAndAppManagementAssignmentFilterType include: Includes the devices in the filter exclude: Excludes the devices in the filter We need to build separate objects in PowerShell to complete the JSON hierarchy, and we can happily do this using PowerShell using something like the below:\nBuilding the PSObject for odata.type and intent, with the App to be an Available Installation Intent:\n$Target = New-Object -TypeName PSObject $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.mobileAppAssignment\u0026#39; $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;intent\u0026#39; -Value \u0026#39;available If we\u0026rsquo;re going for a Group based assignment including a Device Filter, we can build this and add to the existing $Target object using:\n$TargetGroup = New-Object -TypeName PSObject $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.groupAssignmentTarget\u0026#39; $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;groupId\u0026#39; -Value \u0026#39;{Group.Id}\u0026#39; $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterId\u0026#39; -Value \u0026#39;{FilterId}\u0026#39; $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterType\u0026#39; -Value \u0026#39;include\u0026#39; $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;target\u0026#39; -Value $TargetGroup Then the final PSObject for mobileAppAssignments, adding everything together, and converting it to JSON:\n$Output = New-Object -TypeName PSObject $Output | Add-Member -MemberType NoteProperty -Name \u0026#39;mobileAppAssignments\u0026#39; -Value @($Target) $JSON = $Output | ConvertTo-Json -Depth 3 Giving us the below output:\n{ \u0026#34;mobileAppAssignments\u0026#34;: [ { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.mobileAppAssignment\u0026#34;, \u0026#34;intent\u0026#34;: \u0026#34;available\u0026#34;, \u0026#34;target\u0026#34;: { \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.groupAssignmentTarget\u0026#34;, \u0026#34;groupId\u0026#34;: \u0026#34;{Group.Id}\u0026#34;, \u0026#34;deviceAndAppManagementAssignmentFilterId\u0026#34;: \u0026#34;{FilterId}\u0026#34;, \u0026#34;deviceAndAppManagementAssignmentFilterType\u0026#34;: \u0026#34;include\u0026#34; } } ] } This looks miraculously like the Microsoft example, but you know, same same but different. If it actually had the correct {FilterId} and {GroupId} in place, it would allow us to assign an App when pushed to Graph.\nWe\u0026rsquo;re getting there, bear with me, I thought this post would be shorter.\nFunction Building Blocks # There are a few components we need to put together in the form of functions to enable the assignment of Mobile Apps, if we\u0026rsquo;re being complete about this, and for once we are (ish), we need to consider the following:\nGetting Mobile Apps Getting Device Filters Getting Groups Getting existing Assignments Dealing with existing Assignments All of the above will alter the way we deal with the JSON data we are creating, so one for future me to deal with. For now, on to the functions.\nRemember we\u0026rsquo;ll need to authenticate to Graph for all of these.\nGetting Mobile Apps # This one has come straight from an existing script, but we\u0026rsquo;ll need to filter the data gathered, otherwise we\u0026rsquo;re dragging back every Mobile App, including those referenced in App Protection Policies, and we don\u0026rsquo;t want to do anything with those today.\nFunction Get-MobileApps() { [cmdletbinding()] $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#39;deviceAppManagement/mobileApps\u0026#39; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Getting Device Filters # To fix our missing {FilterId} issue, we need to be able to capture this data. This is a quick one, as we just need a call to GET deviceManagement/assignmentFilters resource, once we\u0026rsquo;ve authenticated to Graph of course.\nFunction Get-DeviceFilter() { $graphApiVersion = \u0026#39;beta\u0026#39; $Resource = \u0026#39;deviceManagement/assignmentFilters\u0026#39; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } This function will pull back all Device Filters in the Intune tenant, so we might need to filter this down later on.\nGetting Groups # Ah yes, Groups, I\u0026rsquo;d almost forgotten about these, but Dynamic Groups still have a place in Intune, and we need the {GroupId} to make this work, so we should find a way to grab these as well. As with the Device Filters, this is a call to Graph, but using the GET groups resource to capture the group id we need.\nIt was supposed to be so easy, however as we need to limit the number of Groups being pulled back, we need a way to search for a Group name. Here comes the Search Query Parameter, and importantly the need for ConsistencyLevel in the headers of the Invoke-RestMethod.\nWe already have our header containing the $authToken, so we need to add in a new row, we can do this using the below:\n$authToken[\u0026#34;ConsistencyLevel\u0026#34;] = \u0026#34;eventual\u0026#34; Giving us a new $authToken with output:\nName Value ---- ----- Content-Type application/json ConsistencyLevel eventual ExpiresOn 09/02/2023 11:49:47 +00:00 Authorization Bearer eyJ0eXAiOiJKV1QiLCJub25jZSI6ImFVUTNp... So eventually we have the Get-MDMGroup function, which will require a $GroupName parameter to search for the Groups to retrieve.\nFunction Get-MDMGroup() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] [string]$GroupName ) $graphApiVersion = \u0026#39;beta\u0026#39; $Resource = \u0026#39;groups\u0026#39; try { $authToken[\u0026#39;ConsistencyLevel\u0026#39;] = \u0026#39;eventual\u0026#39; $searchterm = \u0026#39;search=\u0026#34;displayName:\u0026#39; + $GroupName + \u0026#39;\u0026#34;\u0026#39; $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource`?$searchterm\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Honestly, after that I wish I\u0026rsquo;d excluded Group based assignments, and we should have used one of the many PowerShell modules to pull back groups, but I like Graph, I like a consistent approach, and I\u0026rsquo;m using PowerShell Core 7.\nGetting Existing Assignments # We could be brutal with this script, and strip out the existing App assignments when assigning new ones, which is the default behaviour with POST, but I\u0026rsquo;m pretty sure that would make for some unhappy users. I couldn\u0026rsquo;t see a PATCH option for assignments, so we are going to have to write something ourselves to sort this at some point.\nHere is the function we can use to pull back the existing assignment data, I honestly can\u0026rsquo;t remember why I\u0026rsquo;ve done it this way, I think it was due to the lovely format in which the assignments were displayed, but here we only need an App $Id to make this one work.\nFunction Get-ApplicationAssignment() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] $Id ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceAppManagement/mobileApps/$Id/?`$expand=categories,assignments\u0026#34; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri ‚ÄìHeaders $authToken ‚ÄìMethod Get) } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Removing Existing Assignments # Even if we\u0026rsquo;re not accidentally removing existing assignments, we should give ourselves the option to undo any mistakes that we make when assigning Mobile Apps, so a quick tour of Graph gives us the DELETE mobileAppAssignment resource, and with a couple of parameters needed for both the App $Id and the Assignment $AssignmentId, we\u0026rsquo;ve got ourselves a function to get us out of trouble if we need it.\nFunction Remove-ApplicationAssignment() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] $Id, [parameter(Mandatory = $true)] $AssignmentId ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceAppManagement/mobileApps/$Id/assignments/$AssignmentId\u0026#34; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri ‚ÄìHeaders $authToken ‚ÄìMethod Delete) } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } App Assignment Function # Finally we have all the parts to build the function, using the parameters below we can pass through the information needed to build the JSON data, pass through options as to whether we\u0026rsquo;re adding or replacing the assignment, and using some level of logic make sure we\u0026rsquo;re not messing this data up along the way.\nParameters # I\u0026rsquo;ve niced myself here and given options for the application of the function, covering all our requirements for assignment. A break down of the parameters can be found below:\nParameter Description Required Data Id The Id of the Mobile App, obtained via Get-MobileApps True String TargetGroupId The Id of a Group if assigning to a Group obtained via Get-MDMGroup False String InstallIntent Whether the Assignment is set as Available or Required True Available/Required FilterID The ID of a Device Filter if assigning using Device Filters obtained via Get-DeviceFilter False String FilterMode The Filter mode if assigning using Device Filters False Include/Exclude All Used if assigning to the in-built \u0026lsquo;All Users\u0026rsquo; or \u0026lsquo;All Devices\u0026rsquo; groups False Devices/Users Action Whether to Add to existing Assignments, or to Replace them True Add/Replace Add Application Assignment # Here is the function in all it\u0026rsquo;s janky glory, ready to be used and abused by whatever I call PowerShell and acceptable user interfaces. We\u0026rsquo;ve got the ability to capture existing assignments, as well as logic on duplicate assignment methods, and of course adding new ones to the Mobile App in question.\nFunction Add-ApplicationAssignment() { [cmdletbinding()] param ( [parameter(Mandatory = $true)] [ValidateNotNullOrEmpty()] $Id, [parameter(Mandatory = $false)] [ValidateNotNullOrEmpty()] $TargetGroupId, [parameter(Mandatory = $true)] [ValidateSet(\u0026#39;Available\u0026#39;, \u0026#39;Required\u0026#39;)] [ValidateNotNullOrEmpty()] $InstallIntent, $FilterID, [ValidateSet(\u0026#39;Include\u0026#39;, \u0026#39;Exclude\u0026#39;)] $FilterMode, [parameter(Mandatory = $false)] [ValidateSet(\u0026#39;Users\u0026#39;, \u0026#39;Devices\u0026#39;)] [ValidateNotNullOrEmpty()] $All, [parameter(Mandatory = $true)] [ValidateSet(\u0026#39;Replace\u0026#39;, \u0026#39;Add\u0026#39;)] $Action ) $graphApiVersion = \u0026#39;beta\u0026#39; $Resource = \u0026#34;deviceAppManagement/mobileApps/$Id/assign\u0026#34; try { $TargetGroups = @() If ($Action -eq \u0026#39;Add\u0026#39;) { # Checking if there are Assignments already configured $Assignments = (Get-ApplicationAssignment -Id $Id).assignments if (@($Assignments).count -ge 1) { foreach ($Assignment in $Assignments) { If (($null -ne $TargetGroupId) -and ($TargetGroupId -eq $Assignment.target.groupId)) { Write-Host \u0026#39;The App is already assigned to the Group\u0026#39; -ForegroundColor Yellow } ElseIf (($All -eq \u0026#39;Devices\u0026#39;) -and ($Assignment.target.\u0026#39;@odata.type\u0026#39; -eq \u0026#39;#microsoft.graph.allDevicesAssignmentTarget\u0026#39;)) { Write-Host \u0026#39;The App is already assigned to the All Devices Group\u0026#39; -ForegroundColor Yellow } ElseIf (($All -eq \u0026#39;Users\u0026#39;) -and ($Assignment.target.\u0026#39;@odata.type\u0026#39; -eq \u0026#39;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#39;)) { Write-Host \u0026#34;The App is already assigned to the All Users Group\u0026#34; -ForegroundColor Yellow } Else { $TargetGroup = New-Object -TypeName psobject if (($Assignment.target).\u0026#39;@odata.type\u0026#39; -eq \u0026#39;#microsoft.graph.groupAssignmentTarget\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.groupAssignmentTarget\u0026#39; $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;groupId\u0026#39; -Value $Assignment.target.groupId } elseif (($Assignment.target).\u0026#39;@odata.type\u0026#39; -eq \u0026#39;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#39; } elseif (($Assignment.target).\u0026#39;@odata.type\u0026#39; -eq \u0026#39;#microsoft.graph.allDevicesAssignmentTarget\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.allDevicesAssignmentTarget\u0026#39; } if ($Assignment.target.deviceAndAppManagementAssignmentFilterType -ne \u0026#39;none\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterId\u0026#39; -Value $Assignment.target.deviceAndAppManagementAssignmentFilterId $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterType\u0026#39; -Value $Assignment.target.deviceAndAppManagementAssignmentFilterType } $Target = New-Object -TypeName psobject $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.mobileAppAssignment\u0026#39; $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;intent\u0026#39; -Value $Assignment.intent $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;target\u0026#39; -Value $TargetGroup $TargetGroups += $Target } } } } $Target = New-Object -TypeName psobject $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.mobileAppAssignment\u0026#39; $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;intent\u0026#39; -Value $InstallIntent $TargetGroup = New-Object -TypeName psobject if ($TargetGroupId) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.groupAssignmentTarget\u0026#39; $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;groupId\u0026#39; -Value $TargetGroupId } else { if ($All -eq \u0026#39;Users\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.allLicensedUsersAssignmentTarget\u0026#39; } ElseIf ($All -eq \u0026#39;Devices\u0026#39;) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.allDevicesAssignmentTarget\u0026#39; } } if ($FilterMode) { $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterId\u0026#39; -Value $FilterID $TargetGroup | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceAndAppManagementAssignmentFilterType\u0026#39; -Value $FilterMode } $Target | Add-Member -MemberType NoteProperty -Name \u0026#39;target\u0026#39; -Value $TargetGroup $TargetGroups += $Target $Output = New-Object -TypeName psobject $Output | Add-Member -MemberType NoteProperty -Name \u0026#39;mobileAppAssignments\u0026#39; -Value @($TargetGroups) $JSON = $Output | ConvertTo-Json -Depth 3 $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Post -Body $JSON -ContentType \u0026#39;application/json\u0026#39; } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } I can\u0026rsquo;t say I\u0026rsquo;m proud of this function, but it does cater for whatever I\u0026rsquo;ve thrown at it.\nFunction Actions # Running this function allows us to finally assign a Mobile App, I\u0026rsquo;m starting to think I could have just manually assigned the Apps at this point, but I\u0026rsquo;m confident I\u0026rsquo;ll have to use this script again and again in the future.\nReplacing Assignment for an App, with the intent as Required to the \u0026lsquo;All Devices\u0026rsquo; group, with an include Device Filter : Add-ApplicationAssignment -Id {AppId} -InstallIntent Required -All All Devices -FilterMode Include -FilterID {FilterId} -Action Replace Adding an Assignment for an App, with an intent as Available to a Group with no Device Filter would looks something like this: Add-ApplicationAssignment -Id {AppId} -InstallIntent Available -TargetGroupId {Group.Id} -Action Add Adding an Assignment for an App, with the intent as Required to a Group with an exclude Device Filter would looks something like this: Add-ApplicationAssignment -Id {AppId} -InstallIntent Available -TargetGroupId {Group.Id} -FilterMode Exclude -FilterID {FilterId} -Action Add I think we\u0026rsquo;re done here.\nRunning, Assigning and Hiding # I\u0026rsquo;ve included a whole lot of logic and user interface when it comes to this script, and as most of my time has been spent battling with existing assignments, new functions and the headache that is building JSON data from the existing assignment content, I\u0026rsquo;m not going to go into any detail about this part of the script but you can as always find it in GitHub if you want to have a gander at what consists as good practice in my mind.\nThe Payoff # It\u0026rsquo;s got to the point now where I honestly couldn\u0026rsquo;t be bothered to take screenshots of the script in action, plus it would make this already lengthy post even longer, so through the wonder that is screen recording and YouTube you can see the script in action demonstrating the following:\nAdding new Assignments for multiple Apps, with install intent as Required to the All Devices group with a Device Filter Adding new Assignments for multiple Apps, with install intent as Available to a Group with a Device Filter Replacing Assignments for multiple Apps, with install intent as Available to the All Users group with a Device Filter Removing all Assignments for multiple Apps Adding new Assignments for multiple Apps, with install intent as Required to the All Devices group with a Device Filter Adding Assignments for multiple Apps, with install intent as Available to the All Users group with a Device Filter I haven\u0026rsquo;t recorded every possible option, as I have coffee to drink and other awful PowerShell to write, but you get the gist.\nSummary # This felt like a long journey, even with some of the existing foundation functions already at our fingertips, but a worthy one as I\u0026rsquo;m never going to have to individually assign loads of Mobile Apps again, and thanks to this effort, nor do you.\nAs much as there is some intelligence to the script you will still have to use your own knowledge of Intune for when is best to use Devices, Users and Groups, but we can\u0026rsquo;t solve all our problems with PowerShell, trust me, I\u0026rsquo;m trying. The script however does give you an easy way to bulk assign Mobile Apps in Intune, fully strip out assignments, or even just make every Mobile App available to everyone all at once, without too much clicking about.\nThere is definitely room for improvement and expansion, and at some point I\u0026rsquo;ll extend this to cover the assignment of Windows and macOS Apps; but for now you\u0026rsquo;ll have to make do with Android and iOS.\nAs always, please test this one before going large and selecting all your Mobile Apps, I\u0026rsquo;ve included warning break points for a reason.\n","date":"13 February 2023","permalink":"/posts/assigning-intune-applications/","section":"Blog","summary":"No one, and I mean no one, really wants to manually and individually assign Mobile Apps to Users or Devices in Intune in their 100\u0026rsquo;s, so we should find a solution for this bulk assignment approach.","title":"Assigning Intune Mobile Apps Quickly and Consistently"},{"content":"","date":"13 February 2023","permalink":"/tags/ios/","section":"Tags","summary":"","title":"iOS/iPadOS"},{"content":"Introduction # I\u0026rsquo;m not going to go over old ground in too much detail, as I\u0026rsquo;ve already covered the importance of keeping your Operating System Compliance Policies up to date in line with the release of new updates, as well as a way to update your compliance policies using Graph and PowerShell.\nWhat I am going to do is extend this automated Compliance Policy update functionality to Apple Updates as well, it\u0026rsquo;s like I\u0026rsquo;ve been working with a customer that only has iOS/iPadOS devices in Intune or something.\nI guess when I end up working with a customer with only Android devices, that I\u0026rsquo;ll finally be able to put all the pieces together and have one script to update them all.\nOperating System Build Versions # Unlike the Windows Valid Operating System Builds option in Compliance Policies, Apple policies don\u0026rsquo;t give you the option of having a set of versions to work with, limited to only the following settings:\nMinimum OS version Maximum OS version Minimum OS build version Maximum OS build version With Apple having different build versions per Operating System, whether this is iOS/iPadOS or macOS, we\u0026rsquo;re unable to have one Compliance Policy that covers all the supported OS versions, and need to have specific policies per supported Operating System.\nDevice Filters # Now we all know where I stand on Device Filters and they come to the rescue once again, as we need separate Compliance Policies and the ability to target these to the correct devices.\nWe can create filters for each of the current supported (at time of writing) iOS/iPadOS and macOS operating systems:\nDescription OS Filter Rule All Corporate iOS 15 devices iOS (device.deviceOwnership -eq \u0026quot;Corporate\u0026quot;) and (device.osVersion -startsWith \u0026quot;15\u0026quot;) All Corporate iOS 16 devices iOS (device.deviceOwnership -eq \u0026quot;Corporate\u0026quot;) and (device.osVersion -startsWith \u0026quot;16\u0026quot;) All Corporate Big Sur devices macOS (device.deviceOwnership -eq \u0026quot;Corporate\u0026quot;) and (device.osVersion -startsWith \u0026quot;11\u0026quot;) All Corporate Monterey devices macOS (device.deviceOwnership -eq \u0026quot;Corporate\u0026quot;) and (device.osVersion -startsWith \u0026quot;12\u0026quot;) All Corporate Ventura devices macOS (device.deviceOwnership -eq \u0026quot;Corporate\u0026quot;) and (device.osVersion -startsWith \u0026quot;13\u0026quot;) Using these we can now create a Compliance Policy for each Operating System version, assigning it to the All Devices or All Users groups and include the corresponding Device Filter.\nCompliance Policies # You\u0026rsquo;ve probably created Compliance Policies before, and if you haven\u0026rsquo;t there are only a few clicks needed to configure one in preparation for the Operating System compliance check.\nAs the Apple build versions are unique, we don\u0026rsquo;t need to add in the settings Minimum OS version and Maximum OS version, though they are both a useful visual aide, and I could do with referencing them when I come to write a script to update the Compliance Policy.\nSo go ahead and create your Compliance Policies for each supported Operating System version, assigning them to the required group and filter:\nOS Version Minimum OS version iOS iOS 15 15.0.0 iOS iOS 16 16.0.0 macOS Big Sur 11.0.0 macOS Monterey 12.0.0 macOS Ventura 13.0.0 With both the Compliance Policies and the Device Filters in place, now we can move onto how we update the Build Versions.\nUpdates and RSS Feeds # As with the Windows Updates, Apple make their updates available in an easy to digest RSS feed which should make scraping back the information we need pretty straight forward:\n\u0026lt;item\u0026gt; \u0026lt;title\u0026gt;iOS 16.3 (20D47)\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;https://developer.apple.com/news/releases/?id=01232023f\u0026lt;/link\u0026gt; \u0026lt;guid\u0026gt;https://developer.apple.com/news/releases/?id=01232023f\u0026lt;/guid\u0026gt; \u0026lt;description\u0026gt;View downloadsView release notes\u0026lt;/description\u0026gt; \u0026lt;pubDate\u0026gt;Mon, 23 Jan 2023 09:00:00 PST\u0026lt;/pubDate\u0026gt; \u0026lt;content:encoded\u0026gt;\u0026lt;![CDATA[\u0026lt;p\u0026gt;\u0026lt;a href=/download class=more\u0026gt;View downloads\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;il\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=/go/?id=ios-16.3-rn class=more\u0026gt;View release notes\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/il\u0026gt;]]\u0026gt;\u0026lt;/content:encoded\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;item\u0026gt; \u0026lt;title\u0026gt;iPadOS 16.3 (20D47)\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;https://developer.apple.com/news/releases/?id=01232023e\u0026lt;/link\u0026gt; \u0026lt;guid\u0026gt;https://developer.apple.com/news/releases/?id=01232023e\u0026lt;/guid\u0026gt; \u0026lt;description\u0026gt;View downloadsView release notes\u0026lt;/description\u0026gt; \u0026lt;pubDate\u0026gt;Mon, 23 Jan 2023 09:00:00 PST\u0026lt;/pubDate\u0026gt; \u0026lt;content:encoded\u0026gt;\u0026lt;![CDATA[\u0026lt;p\u0026gt;\u0026lt;a href=/download class=more\u0026gt;View downloads\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;il\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=/go/?id=iPadOS-16.3-rn class=more\u0026gt;View release notes\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/il\u0026gt;]]\u0026gt;\u0026lt;/content:encoded\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;item\u0026gt; \u0026lt;title\u0026gt;macOS 13.2 (22D49)\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;https://developer.apple.com/news/releases/?id=01232023d\u0026lt;/link\u0026gt; \u0026lt;guid\u0026gt;https://developer.apple.com/news/releases/?id=01232023d\u0026lt;/guid\u0026gt; \u0026lt;description\u0026gt;View downloadsView release notes\u0026lt;/description\u0026gt; \u0026lt;pubDate\u0026gt;Mon, 23 Jan 2023 09:00:00 PST\u0026lt;/pubDate\u0026gt; \u0026lt;content:encoded\u0026gt;\u0026lt;![CDATA[\u0026lt;p\u0026gt;\u0026lt;a href=/download class=more\u0026gt;View downloads\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;il\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=/go/?id=macos-13.2-rn class=more\u0026gt;View release notes\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/il\u0026gt;]]\u0026gt;\u0026lt;/content:encoded\u0026gt; \u0026lt;/item\u0026gt; So all the information we need is contained within the title of each item in the feed, in particular we\u0026rsquo;ll be needing the Build Version in order to use this to update our Compliance Policy.\nGetting the Build Version # With the $uri set to the RSS feed, we can Invoke-WebRequest to pull through the data into the variable $Updates, making sure we\u0026rsquo;re processing it as XML, and removing any unsupported characters.\n$uri = \u0026#39;https://developer.apple.com/news/releases/rss/releases.rss\u0026#39; [xml]$Updates = (Invoke-WebRequest -Uri $uri -UseBasicParsing -ContentType \u0026#39;application/xml\u0026#39;).Content -replace \u0026#39;[^\\x09\\x0A\\x0D\\x20-\\xD7FF\\xE000-\\xFFFD\\x10000-x10FFFF]\u0026#39;, \u0026#39;\u0026#39; As the feed has multiple update releases for each Operating System, we need to pass them into an array, so we can select the most recent one:\n$BuildVersion = @() Whilst looping through each item in the feed, we can filter each $Update based on both the Operating System $OS, and the version $Version, to ensure that we\u0026rsquo;re only pulling back the data we require, returning only the first and newest update.\nforeach ($Update in $Updates.rss.channel.Item) { if (($Update.title -like \u0026#34;*$OS*\u0026#34;) -and ($Update.title -like \u0026#34;*$Version*\u0026#34;)) { $BuildVersion += $Update.title } } return $BuildVersion[0] Running this all together, passing through iOS and 16 for the variables, we get an output of:\niOS 16.3 (20D47) This looks promising.\nCreating the Function # As the aim is to repeat both the process of updating Compliance Policies, and tailoring for the multiple Operating Systems and versions, we should wrap the above in a Function.\nFunction Get-AppleUpdates() { \u0026lt;# .SYNOPSIS This function is used to get the latest Apple Updates from the Apple Developer RSS Feeds .DESCRIPTION The function pulls the RSS feed from the Apple Developer RSS Feeds .EXAMPLE Get-AppleUpdates -OS iOS -Version 15 #\u0026gt; [cmdletbinding()] param ( [Parameter(Mandatory = $true)] [ValidateSet(\u0026#39;iOS\u0026#39;, \u0026#39;macOS\u0026#39;)] $OS, [Parameter(Mandatory = $true)] $Version ) try { $uri = \u0026#39;https://developer.apple.com/news/releases/rss/releases.rss\u0026#39; [xml]$Updates = (Invoke-WebRequest -Uri $uri -UseBasicParsing -ContentType \u0026#39;application/xml\u0026#39;).Content -replace \u0026#39;[^\\x09\\x0A\\x0D\\x20-\\xD7FF\\xE000-\\xFFFD\\x10000-x10FFFF]\u0026#39;, \u0026#39;\u0026#39; $BuildVersion = @() foreach ($Update in $Updates.rss.channel.Item) { if (($Update.title -like \u0026#34;*$OS*\u0026#34;) -and ($Update.title -like \u0026#34;*$Version*\u0026#34;)) { $BuildVersion += $Update.title } } return $BuildVersion[0] } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } This can now be called within PowerShell using the below as examples:\nGet-AppleUpdates -OS iOS -Version 16 Get-AppleUpdates -OS macOS -Version 13 Updating Compliance # We\u0026rsquo;ve already got functions from our last expedition into this topic for getting and updating Compliance Policies, checking for valid JSON as well as the usual suspect for authentication, so thank you to previous me for this.\nArmed with our new function for getting the latest Apple Build versions, we now need to build out the script to do our job for us.\nGetting the Policies # As we only care about iOS/iPadOS and macOS today, we need to filter the policies we are retrieving using the Get-DeviceCompliancePolicy function, this can be accomplished by using the @odata.type, and also only those policies with a osMinimumVersion configured:\n$OSCompliancePolicies = Get-DeviceCompliancePolicy | Where-Object { (($_.\u0026#39;@odata.type\u0026#39;).contains(\u0026#39;iosCompliancePolicy\u0026#39;) -or ($_.\u0026#39;@odata.type\u0026#39;).contains(\u0026#39;macOSCompliancePolicy\u0026#39;)) -and ($_.osMinimumVersion) -ne $null } Now with the policies in the variable, we can loop through each and set our $OS variable based on the @odata.type of the policy, and grab the $Version variable using the first two digits of osMinimumVersion, as we\u0026rsquo;ll need these for the Get-AppleUpdates parameters.\nforeach ($OSCompliancePolicy in $OSCompliancePolicies) { If ($OSCompliancePolicy.\u0026#39;@odata.type\u0026#39; -like \u0026#39;*ios*\u0026#39;) { $OS = \u0026#39;iOS\u0026#39; } elseif ($OSCompliancePolicy.\u0026#39;@odata.type\u0026#39; -like \u0026#39;*macOS*\u0026#39;) { $OS = \u0026#39;macOS\u0026#39; } $Version = $OSCompliancePolicy.osMinimumVersion.SubString(0, 2) } Handling Build Versions # Now the output of the function gives us all the information we could ask for, but we actually only need a small part of it, the bit in brackets: iOS 16.3 (20D47)\nSo we can strip out the data between the brackets, using the magic of Regex and add this to a new variable we\u0026rsquo;ll use later to update the Compliance Policy in question:\n$Build = (Get-AppleUpdates -OS $OS -Version $Version | Select-String \u0026#39;(?\u0026lt;=\\()[^]]+(?=\\))\u0026#39; -AllMatches).Matches.Value Building the JSON Data # To update our Compliance Policy, we need to send it some JSON data in a particular format as part of the Update-DeviceCompliancePolicy function, we can build this using both the existing information captured from the Get-DeviceCompliancePolicy and the newly acquired build version, then finally calling the function to update the Compliance Policy.\n$Update = New-Object -TypeName psobject $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value $OSCompliancePolicy.\u0026#39;@odata.type\u0026#39; $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;description\u0026#39; -Value $Description $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;osMinimumBuildVersion\u0026#39; -Value $Build $JSON = $Update | ConvertTo-Json -Depth 3 Update-DeviceCompliancePolicy -Id $OSCompliancePolicy.id -JSON $JSON All being good, this data looks something like this for our iOS 16 Compliance Policy:\n{ \u0026#34;@odata.type\u0026#34;: \u0026#34;#microsoft.graph.iosCompliancePolicy\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Updated Operating System Device Compliance Policy on 26-01-2023 10:39:29\u0026#34;, \u0026#34;osMinimumBuildVersion\u0026#34;: \u0026#34;20D47\u0026#34; } We can now submit this JSON data to Graph, passing through the required Compliance Policy id, allowing us to update the required policy:\nUpdate-DeviceCompliancePolicy -Id $OSCompliancePolicy.id -JSON $JSON All going well, we now have an updated policy with the correct and most recent build version for the Operating System.\nThe Solution # We have all the component parts to bring the full script together, of which you can see below without the functions and Graph Authentication.\nKey things to note here that we haven\u0026rsquo;t covered individually is the check to see if the build version is already up to date, as there\u0026rsquo;s no point triggering a Compliance Check on devices if nothing has changed.\n$Date = Get-Date -Format \u0026#39;dd-MM-yyyy hh:mm:ss\u0026#39; $Description = \u0026#34;Updated Operating System Device Compliance Policy on $Date\u0026#34; $OSCompliancePolicies = Get-DeviceCompliancePolicy | Where-Object { (($_.\u0026#39;@odata.type\u0026#39;).contains(\u0026#39;iosCompliancePolicy\u0026#39;) -or ($_.\u0026#39;@odata.type\u0026#39;).contains(\u0026#39;macOSCompliancePolicy\u0026#39;)) -and ($_.osMinimumVersion) -ne $null } foreach ($OSCompliancePolicy in $OSCompliancePolicies) { If ($OSCompliancePolicy.\u0026#39;@odata.type\u0026#39; -like \u0026#39;*ios*\u0026#39;) { $OS = \u0026#39;iOS\u0026#39; } elseif ($OSCompliancePolicy.\u0026#39;@odata.type\u0026#39; -like \u0026#39;*macOS*\u0026#39;) { $OS = \u0026#39;macOS\u0026#39; } $Version = $OSCompliancePolicy.osMinimumVersion.SubString(0, 2) $Build = (Get-AppleUpdates -OS $OS -Version $Version | Select-String \u0026#39;(?\u0026lt;=\\()[^]]+(?=\\))\u0026#39; -AllMatches).Matches.Value If ($OSCompliancePolicy.osMinimumBuildVersion -ne $Build) { $Update = New-Object -TypeName psobject $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value $OSCompliancePolicy.\u0026#39;@odata.type\u0026#39; $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;description\u0026#39; -Value $Description $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;osMinimumBuildVersion\u0026#39; -Value $Build $JSON = $Update | ConvertTo-Json -Depth 3 Update-DeviceCompliancePolicy -Id $OSCompliancePolicy.id -JSON $JSON Write-Host \u0026#34;Updated $OS Compliance Policy $($OSCompliancePolicy.displayName) with latest Build: $Build\u0026#34; -ForegroundColor Green Write-Host } Else { Write-Host \u0026#34;$OS Compliance Policy $($OSCompliancePolicy.displayName) already on latest Build: $Build\u0026#34; -ForegroundColor Cyan Write-Host } } Script in Action # We should practice what we preach and test our script in our own Intune environment before letting loose on a production one, so here we go.\niOS 15 Compliance Policy without an existing build version macOS Big Sur Compliance Policy with a current build version macOS Ventura Compliance Policy with an existing build version Running the script will give us the below output:\nUpdated macOS Compliance Policy Compliance_macOS_Corporate_OS_13 with latest Build: 22D49 macOS Compliance Policy Compliance_macOS_Corporate_OS_12 already on latest Build: 21G217 Updated iOS Compliance Policy Compliance_iOS_Corporate_OS_15 with latest Build: 19H307 Updated iOS Compliance Policy Compliance_iOS_Corporate_OS_16 with latest Build: 20D47 Resulting in our Compliance Policies getting updated with the latest build versions:\niOS 15 Compliance Policy updated to 19H307 Checking this against the Apple Developer Release Feed that we haven\u0026rsquo;t made a mistake:\n\u0026lt;item\u0026gt; \u0026lt;title\u0026gt;iOS 15.7.3 (19H307)\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;https://developer.apple.com/news/releases/?id=01232023b\u0026lt;/link\u0026gt; \u0026lt;guid\u0026gt;https://developer.apple.com/news/releases/?id=01232023b\u0026lt;/guid\u0026gt; \u0026lt;description\u0026gt;View downloads\u0026lt;/description\u0026gt; \u0026lt;pubDate\u0026gt;Mon, 23 Jan 2023 09:00:00 PST\u0026lt;/pubDate\u0026gt; \u0026lt;content:encoded\u0026gt;\u0026lt;![CDATA[\u0026lt;p\u0026gt;\u0026lt;a href=/download class=more\u0026gt;View downloads\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;]]\u0026gt;\u0026lt;/content:encoded\u0026gt; \u0026lt;/item\u0026gt; macOS Ventura Compliance Policy updated to 22D49 Again checking this against the Apple Developer Release Feed that we still haven\u0026rsquo;t made a mistake:\n\u0026lt;item\u0026gt; \u0026lt;title\u0026gt;macOS 13.2 (22D49)\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;https://developer.apple.com/news/releases/?id=01232023d\u0026lt;/link\u0026gt; \u0026lt;guid\u0026gt;https://developer.apple.com/news/releases/?id=01232023d\u0026lt;/guid\u0026gt; \u0026lt;description\u0026gt;View downloadsView release notes\u0026lt;/description\u0026gt; \u0026lt;pubDate\u0026gt;Mon, 23 Jan 2023 09:00:00 PST\u0026lt;/pubDate\u0026gt; \u0026lt;content:encoded\u0026gt;\u0026lt;![CDATA[\u0026lt;p\u0026gt;\u0026lt;a href=/download class=more\u0026gt;View downloads\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;il\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=/go/?id=macos-13.2-rn class=more\u0026gt;View release notes\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/il\u0026gt;]]\u0026gt;\u0026lt;/content:encoded\u0026gt; \u0026lt;/item\u0026gt; Or resulting in the current build version Compliance Policies not getting updated:\nmacOS Big Sur Compliance Policy not updated Overall this looks pretty good to me.\nSummary # We\u0026rsquo;re almost there with maintaining Operating System Compliance Policies, with Windows, iOS/iPadOS, and macOS under our belt, our next challenge will be Android, and bringing them all together into one single script.\nFor now though, we\u0026rsquo;ve reduced the overhead of having to manually update these Compliance Policies for three out of six four (let\u0026rsquo;s not mention Linux or ChromeOS just yet) Operating Systems supported in Microsoft Intune, so something to be happy about I guess.\n","date":"2 February 2023","permalink":"/posts/apple-os-updating-compliance/","section":"Blog","summary":"Apple devices shouldn\u0026rsquo;t be exempt from Operating System compliance policies, and these policies should share the same fate as Windows ones, and be updated monthly in line with update release cycles.","title":"Updating Apple Operating System Compliance Policies"},{"content":"Introduction # Now that you\u0026rsquo;ve made the financial sensible decision to migrate to Microsoft Intune for your Apple device management needs, you\u0026rsquo;ve got your Apple Push Certificate, sorted your Enrolment Token, added Intune as an MDM provider, and now you\u0026rsquo;ve got all your iOS/iPadOS devices happily sitting synchronised in Intune waiting to be deployed using Apple\u0026rsquo;s Automated Device Enrolment. Life is good.\nUntil you realise that in your excitement you\u0026rsquo;ve created loads of Enrolment Profiles (up to 1000 in fact, help), and you now have the daunting task of assigning your thousands (up to 200,000, fml) iOS/iPadOS devices to these profiles.\nNo one likes clicking that much.\nDeveloper Tool Sneaking # If you hadn\u0026rsquo;t realised already, everything in Microsoft Intune is backed by the Graph API, to the point where if you open your browser developer tools, usually by pressing F12, you can actually see the calls to Graph being made when you click around.\nThis makes it pretty easy to identify the resource in Graph being used, as well as the call you\u0026rsquo;ll be making to the API.\nUsing this method, and actually assigning a profile to an iOS/iPadOS device in Intune, and watching what calls are made using the developer tools, allows us to capture the Graph resource endpoint and ultimately throw together the functions we need, in this case, to get and assign the Enrolment Profiles.\nApple Enrolment Token # Using the existing MSAL Authentication Function and associated script we\u0026rsquo;ve got Graph at our fingertips. To get all the Enrolment Profiles and Devices associated with the Apple Enrolment Program Token, we\u0026rsquo;ve got to call the Token itself using the GET /deviceManagement/depOnboardingSettings resource.\nFunction Get-ADEEnrolmentToken() { $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#39;deviceManagement/depOnboardingSettings\u0026#39; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } This function gives us the below output, and the necessary id we can use to call the Enrolment Profiles and everything else associated with out Apple Enrolment Program Token:\nid : 17793d6e-e12d-4a04-b209-73d302b9a563 appleIdentifier : memv@ennbee.uk tokenExpirationDateTime : 16/05/2023 14:40:28 lastModifiedDateTime : 16/05/2022 14:40:52 lastSuccessfulSyncDateTime : 22/01/2023 12:30:03 lastSyncTriggeredDateTime : 18/01/2023 14:45:26 shareTokenWithSchoolDataSyncService : False lastSyncErrorCode : 0 tokenType : dep tokenName : MEMVENNBEE Intune syncedDeviceCount : 4 dataSharingConsentGranted : True roleScopeTagIds : {0} Enrolment Profiles # With the Token, and more importantly the id of the Token in hand, we can now call GET /deviceManagement/depOnboardingSettings/{depOnboardingSettingId}/enrollmentProfiles to pull back all the enrolment profiles associated with that Token ID.\nFunction Get-ADEEnrolmentProfile() { Param( [Parameter(Mandatory = $true)] $Id ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceManagement/depOnboardingSettings/$Id/enrollmentProfiles\u0026#34; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Punting Get-ADEEnrolmentToken into a variable $Token, we can now pull back all the Enrolment Profiles associated with Enrolment Program Token:\n$Token = Get-ADEEnrolmentToken Get-ADEEnrolmentProfile -Id $Token.Id This will now list out all the Enrolment Profiles linked to the Token, with full details of each of the Enrolment Profiles:\n@odata.type : #microsoft.graph.depIOSEnrollmentProfile id : 17793d6e-e12d-4a04-b209-73d302b9a563_289e29a1-34ec-404c-a1d3-9c8dc712ea80 displayName : Enrolment_iOS_Clinical_Shared_User description : requiresUserAuthentication : False configurationEndpointUrl : https://appleconfigurator2.manage.microsoft.com/MDMServiceConfig?id=61513957-6e30-4b9f-a30a-051a20ffe3da\u0026amp;AADTenantId=58775aec-3fd5-42a9-9c65-b4a34d4e78f2 enableAuthenticationViaCompanyPortal : False requireCompanyPortalOnSetupAssistantEnrolledDevices : False isDefault : False supervisedModeEnabled : True supportDepartment : Clinical Shared Device Users isMandatory : True locationDisabled : False supportPhoneNumber : 01904 profileRemovalDisabled : True restoreBlocked : True appleIdDisabled : True termsAndConditionsDisabled : True touchIdDisabled : True applePayDisabled : True siriDisabled : True diagnosticsDisabled : True displayToneSetupDisabled : False privacyPaneDisabled : True screenTimeScreenDisabled : True deviceNameTemplate : CLIN-S-STD-{{SERIAL}} configurationWebUrl : False enabledSkipKeys : {Android, HomeButtonSensitivity, iMessageAndFaceTime, OnBoarding‚Ä¶} iTunesPairingMode : allow restoreFromAndroidDisabled : True awaitDeviceConfiguredConfirmation : False sharedIPadMaximumUserCount : 0 enableSharedIPad : False companyPortalVppTokenId : 00000000-0000-0000-0000-000000000000 enableSingleAppEnrollmentMode : False homeButtonScreenDisabled : True iMessageAndFaceTimeScreenDisabled : True onBoardingScreenDisabled : True simSetupScreenDisabled : True softwareUpdateScreenDisabled : False watchMigrationScreenDisabled : True appearanceScreenDisabled : True expressLanguageScreenDisabled : False preferredLanguageScreenDisabled : False deviceToDeviceMigrationDisabled : True welcomeScreenDisabled : True passCodeDisabled : False zoomDisabled : False restoreCompletedScreenDisabled : True updateCompleteScreenDisabled : False forceTemporarySession : False temporarySessionTimeoutInSeconds : 0 userSessionTimeoutInSeconds : 0 passcodeLockGracePeriodInSeconds : carrierActivationUrl : userlessSharedAadModeEnabled : False managementCertificates : {} Assigning Devices # I had to continue sneaking into the Graph Calls, as I couldn\u0026rsquo;t find any reference in the Graph documentation, to the resource used for assigning devices to a profile.\nWith this we can extract the below resource is being used:\ndeviceManagement/depOnboardingSettings/$Id/enrollmentProfiles(\u0026#39;$ProfileID\u0026#39;)/updateDeviceProfileAssignment` This references the Enrolment Profile Id, which we can now get using the above function, but it also needs a JSON formatted object containing the serial numbers of the devices:\n{ \u0026#34;deviceIds\u0026#34;: \u0026#34;SERIAL1, SERIAL2, SERIAL3\u0026#34; } We can use a PowerShell psobject to build this for us in the function.\nBeing able to pass through many device serial numbers is good news for us, as instead of having to call Graph like a million times for each device, we can just make the call for each profile, so you know, only hundreds of times.\nFunction Add-ADEEnrolmentProfileAssignment() { Param( [Parameter(Mandatory = $true)] $Id, [Parameter(Mandatory = $true)] $ProfileID, [Parameter(Mandatory = $true)] $DeviceSerials ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceManagement/depOnboardingSettings/$Id/enrollmentProfiles(\u0026#39;$ProfileID\u0026#39;)/updateDeviceProfileAssignment\u0026#34; $Output = New-Object -TypeName psobject $Output | Add-Member -MemberType NoteProperty -Name \u0026#39;deviceIds\u0026#39; -Value $DeviceSerials $JSON = $Output | ConvertTo-Json -Depth 3 try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Post -Body $JSON -ContentType \u0026#39;application/json\u0026#39; } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Hash Hash Array # We\u0026rsquo;ve now got all the functions we could ever need, now we need to be able to ingest a list of serial numbers and the Enrolment Profile name that they should be associated with; easy, a CSV file and some effort is all that is required:\nSerial,EnrolmentProfile\rDX3FDFZ6PLFG,Enrolment_iOS_Corp_User_Standard\rH4QJQ01PPLFG,Enrolment_iOS_Corp_User_Standard\rF9GV90XKGHPD,Enrolment_iOS_Clinical_Shared_User\rG6VVLDJPJCLK,Enrolment_iOS_Clinical_Shared_User The tricky part, was how we actually have to use this data, creating a unique list of the Enrolment Profiles, and then based on the association of the device serial number to the profile, add each serial number to each profile.\nIf we don\u0026rsquo;t do this, then we are going to be calling graph for each device serial number in the list, and I\u0026rsquo;d rather not piss off Microsoft. Time for a hashtable, and maybe an array.\nUp, Up and Array # We can now import the CSV file and assign it to a variable:\n$CSVPath = \u0026#34;C:\\Somepath\\SomeCSV.csv\u0026#34; $Devices = Import-Csv -Path $CSVPath Giving us a wonderful output:\nSerial EnrolmentProfile ------ ---------------- DX3FDFZ6PLFG Enrolment_iOS_Corp_User_Standard H4QJQ01PPLFG Enrolment_iOS_Corp_User_Standard F9GV90XKGHPD Enrolment_iOS_Clinical_Shared_User G6VVLDJPJCLK Enrolment_iOS_Clinical_Shared_User Creating a new array $DeviceProfiles = @() and looping through each $Device in $Devices, we can add all the Enrolment Profiles in the CSV file to the array, finally using Get-Unique to ensure that we only have a unique list of Enrolment Profile names.\n$DeviceProfiles = @() foreach ($Device in $Devices) { $DeviceProfiles += $Device.EnrolmentProfile } $UniqueDeviceProfiles = $DeviceProfiles | Get-Unique Giving us an output similar to the below:\nEnrolment_iOS_Clinical_Shared_User Enrolment_iOS_Corp_User_Standard Hash Bang Wallop # With a hashtable, Assignments = @{} we can loop through each $UniqueDeviceProfile in $UniqueDeviceProfiles adding each unique Enrolment Profile as an array to the hashtable.\nAssignments = @{} foreach ($UniqueDeviceProfile in $UniqueDeviceProfiles){ $Assignments[$UniqueDeviceProfile] = @() } With an output of the below:\nName Value ---- ----- Enrolment_iOS_Clinical_Shared‚Ä¶ {} Enrolment_iOS_Corp_User_Stand‚Ä¶ {} With the hashtable and an array for each Enrolment Profile, we can finally loop through $Device in $Devices and add the device serial to the matching Enrolment Profile array.\nforeach ($Device in $Devices) { $Assignments[\u0026#34;$($Device.EnrolmentProfile)\u0026#34;] += $Device.Serial } Giving us our final form hash table, that we can at last use, to assign devices to Enrolment Profiles. This honestly broke my brain.\nName Value ---- ----- Enrolment_iOS_Corp_User_Stand‚Ä¶ {DX3FDFZ6PLFG, H4QJQ01PPLFG} Enrolment_iOS_Clinical_Shared‚Ä¶ {F9GV90XKGHPD, G6VVLDJPJCLK} Assigning Device Enrolment Profiles # With that horrible mess we created, we can combine it all into a sub-par script, to actually assign these devices to the Enrolment Profiles.\nThe full script as always is in my GitHub repo, and gives you some nice messages along the way as it runs off plays with your Intune environment, it also catches errors, which I\u0026rsquo;ve been told is important.\nThe bits you care about now, and the final pay off to our work, can be found below, remember to include the functions and authentication otherwise everything will look a little red in the PowerShell console:\n$CSVPath = Read-Host \u0026#39;Please provide the path to the CSV file containing a list of Serial Numbers and ADE Profile Names e.g. C:\\temp\\ADEDevices.csv\u0026#39; $Devices = Import-Csv -Path $CSVPath $DeviceProfiles = @() foreach ($Device in $Devices) { $DeviceProfiles += $Device.EnrolmentProfile } $UniqueDeviceProfiles = $DeviceProfiles | Get-Unique $Assignments = @{} foreach ($UniqueDeviceProfile in $UniqueDeviceProfiles){ $Assignments[$UniqueDeviceProfile] = @() } foreach ($Device in $Devices) { $Assignments[\u0026#34;$($Device.EnrolmentProfile)\u0026#34;] += $Device.Serial } $Token = Get-ADEEnrolmentToken foreach ($Assignment in $Assignments.GetEnumerator()) { $EnrolmentProfile = Get-ADEEnrolmentProfile -Id $Token.id | Where-Object { ($_.displayName -eq $Assignment.Name) } Add-ADEEnrolmentProfileAssignment -Id $Token.id -ProfileID $EnrolmentProfile.id -DeviceSerial $Assignment.Value } After carefully stepping through the script, we can now see the results of our efforts, and although this was only targetted to four devices, the approach will scale: Digging in a little deeper, we can see that the device has been assigned to the correct Enrolment Profile:\nEverything looks good, you\u0026rsquo;ll now just need to add all your serials numbers and the associated Enrolment Profile name to the CSV file and you can starting assigning the devices in anger.\nSummary # In short, this is a pretty straight forward approach to assist with assignment of profiles in bulk, especially as part of migrating Apple Business or School Manager registered Apple devices from one MDM to Intune, without the need to click around so much.\nRealistically I should have encountered this problem a lot sooner, as there are hundreds of thousands of organisations moving away from their existing MDM provider to Microsoft Intune, maybe the ones with this many Apple devices weren\u0026rsquo;t lucky enough to work with me and my incessant need to script everything.\n","date":"20 January 2023","permalink":"/posts/apple-ade-profile-assignment/","section":"Blog","summary":"Migrating iOS/iPadOS device to Microsoft Intune shouldn\u0026rsquo;t be a headache, and assignment of Automated Device Enrolment profiles with Apple Business Manager integration isn\u0026rsquo;t the exception.","title":"Device Migration and Automated Device Enrolment Profile Assignment"},{"content":"","date":"20 January 2023","permalink":"/tags/enrolment/","section":"Tags","summary":"","title":"Enrolment"},{"content":"","date":"12 January 2023","permalink":"/tags/hybrid/","section":"Tags","summary":"","title":"Hybrid Azure AD"},{"content":"Introduction # Nothing has really changed in the Hybrid Join Autopilot space when it comes to device names, and we\u0026rsquo;re still stuck with useless naming conventions for these devices; sometimes a prefix and random characters just isn\u0026rsquo;t a good enough identification method for Windows devices.\nSo now that it\u0026rsquo;s 2023 it was time to look at this problem once again, mainly because my old solution broke device certificates and an Always On VPN connection that relied on them as part of the Autopilot process.\nName Problems # The trouble with the old method, a PowerShell script disguised as a Win32 App, is that it will happily rename and reboot the device during the Autopilot OOBE process, is that the device will already have a device certificate with it\u0026rsquo;s old jumbled name, and it needs this for both the VPN connection and some level of trust to the domain.\nWhat I was seeing is that the computer renamed, but it lost it\u0026rsquo;s trust and connection to the domain once the Autopilot process had finished. Not ideal when deploying device remotely.\nCertificate Template # We can update the certificate deployment template in Intune to take into consideration the new name of the device, especially as we\u0026rsquo;re using an attribute as part of the device rename that Intune knows about, the serial number.\nAs the Simple Certificate Enrolment Protocol (SCEP) profile supports various device or user attributes we can add these into either Subject Name or Subject Alternative Name of the issued certificate, as well as any prefix we want to add such as L-:\nCN=L-{{SerialNumber}} DNS={{FullyQualifiedDomainName}} DNS={{DeviceName}} DNS=L-{{SerialNumber}}.ennbee.local This sorts out our certificate issue, as the device will have one that has all possible device names, the initial one assigned by the Domain Join profile, and the new one after the device has been renamed. This doesn\u0026rsquo;t solve our Domain trust issue though.\nProactive Remediation # We could do with a way to both check that the device name matches our expected naming convention of L-%SERIAL% for laptops, and D-%SERIAL% for desktops, and fixes the issue for us.\nThis is where Proactive Remediation scripts come to save us, and as I got M365 licenses for Christmas we can make use of them due to this being a licensing requirement.\nNow that we have new tools at our disposal, and modify permissions for \u0026lsquo;SELF\u0026rsquo; already in place in the destination Organisational Unit allowing the computer object to rename itself, we can hack about with the old script that was doing the computer rename as part of the Autopilot process, and using Proactive Remediation scripts, we can check that the existing device name matches the expected device name.\nDetection Script # First off we need a something to check that the device is Domain Joined (Lines 1-6), what the new Computer name is expected to be based on whether a desktop or laptop (Lines 8-21), and what the existing Computer name is (Lines 23-26). As we already have a starter for ten, this wasn\u0026rsquo;t too much of a hassle to throw together quickly.\nTry { $Details = Get-ComputerInfo if (-not $Details.CsPartOfDomain) { Write-Output \u0026#39;Not Domain Joined\u0026#39; Exit 0 } $Serial = Get-WmiObject Win32_bios | Select-Object -ExpandProperty SerialNumber If (Get-WmiObject -Class win32_battery) { $newName = \u0026#39;L-\u0026#39; + $Serial } Else { $newName = \u0026#39;D-\u0026#39; + $Serial } $newName = $newName.Replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;) #Removes spaces #shortens name if ($newName.Length -ge 15) { $newName = $newName.substring(0, 15) } If ($Details.CsName -ne $newName) { Write-Warning \u0026#34;Existing Computer name $($Details.CsName) should be $newName\u0026#34; Exit 1 } Else { Write-Output \u0026#34;Computer has correct name: $($Details.CsName)\u0026#34; Exit 0 } } Catch { Write-Error $_.Exception Exit 2000 } With Proactive Remediation scripts, we need to pass back the results of this check, and any checks, with Exit Codes and some kind of descriptive text.\nRemediation Script # With the information about the device name in place with the detection, now we need something to fix our issues, or if you want to use bigger words, remediate them.\nWe only want this script to run when the device can actually talk to a Domain, otherwise we\u0026rsquo;re in for a bad time of mistrust again. So updating the $domain variable with the name of the domain, we can confirm that we can talk to a Domain Controller, otherwise we exit the script with an error.\n$domain = \u0026#39;ennbee.local\u0026#39; $dcInfo = [ADSI]\u0026#34;LDAP://$domain\u0026#34; if ($null -eq $dcInfo.Path) { Write-Error \u0026#34;No connectivity to $domain\u0026#34; } We can reuse the part of the detection script for the creation of the new computer name, using whether a device has a battery or not to determine whether the device is a laptop or desktop, removing any spaces from the serial, and making sure the new device name is 15 characters or less:\n$Serial = Get-WmiObject Win32_bios | Select-Object -ExpandProperty SerialNumber If (Get-WmiObject -Class win32_battery) { $newName = \u0026#39;L-\u0026#39; + $Serial } Else { $newName = \u0026#39;D-\u0026#39; + $Serial } $newName = $newName.Replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;) #Removes spaces if ($newName.Length -ge 15) { $newName = $newName.substring(0, 15) } Last bit to manage is renaming the device using Rename-Computer and sending a shutdown command with our specified restart time, user notification and friendly message:\n$waittime = \u0026#39;60\u0026#39; Rename-Computer -NewName $newName $waitinseconds = (New-TimeSpan -Minutes $waittime).TotalSeconds Write-Host \u0026#34;Initiating a restart in $waittime minutes\u0026#34; \u0026amp; shutdown.exe /g /t $waitinseconds /f /c \u0026#39;Restarting the computer in 60 minutes due to a computer name change. Please save your work.\u0026#39; Write-Output \u0026#34;Computer renamed from $($Details.CsName) to $newName\u0026#34; This gives the user some notice that the restart is going to happen:\nAll components now in place, we have the full script wrapped in the needed Try/Catch operators, otherwise the good practice PowerShell Police will get you:\n$domain = \u0026#39;ennbee.local\u0026#39; $waittime = \u0026#39;60\u0026#39; Try { $dcInfo = [ADSI]\u0026#34;LDAP://$domain\u0026#34; if ($null -eq $dcInfo.Path) { Write-Error \u0026#34;No connectivity to $domain\u0026#34; } $Serial = Get-WmiObject Win32_bios | Select-Object -ExpandProperty SerialNumber If (Get-WmiObject -Class win32_battery) { $newName = \u0026#39;L-\u0026#39; + $Serial } Else { $newName = \u0026#39;D-\u0026#39; + $Serial } $newName = $newName.Replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;) if ($newName.Length -ge 15) { $newName = $newName.substring(0, 15) } Rename-Computer -NewName $newName $waitinseconds = (New-TimeSpan -Minutes $waittime).TotalSeconds Write-Host \u0026#34;Initiating a restart in $waittime minutes\u0026#34; \u0026amp; shutdown.exe /g /t $waitinseconds /f /c \u0026#39;Restarting the computer in 60 minutes due to a computer name change. Please save your work.\u0026#39; Write-Output \u0026#34;Computer renamed from $($Details.CsName) to $newName\u0026#34; } Catch { Write-Error $_.Exception Exit 2000 } Deployment in Intune # Throwing ourselves into the safe space that is Intune, go and find the Proactive Remediation section, I\u0026rsquo;ll give you a hint, it\u0026rsquo;s under Reports \u0026gt; Endpoint Analytics.\nCreate a new Script Package, selecting and uploading both the detection and remediation scripts as you go, you can get these from GitHub. Make sure you select \u0026lsquo;Run script in 64-bit PowerShell\u0026rsquo; as I couldn\u0026rsquo;t be bothered scripting a check if PowerShell was running in the 64-bit context.\nGo ahead and assign this to a test group of devices, or if you\u0026rsquo;re brave or don\u0026rsquo;t care about testing, all devices with a Device Filter, giving the assignment a schedule; I\u0026rsquo;ve gone with daily repeating every day, but amend this to your environment requirements:\nNow we have to sit back and wait for devices to receive the script package, execute it, and where applicable remediate.\nWhen the devices do check in, you will be able to see the results in Intune under the Device Status, make sure you\u0026rsquo;ve added both the \u0026lsquo;Pre-remediation detection output\u0026rsquo; and \u0026lsquo;Post-remediation detection output\u0026rsquo;:\nI didn\u0026rsquo;t get a screenshot in time for detection picking up errors, only the success, but you get the gist.\nSummary # With this method now successfully renaming the device from the Windows Desktop, the certificate in place to cater to the new computer name, we don\u0026rsquo;t end up losing domain trust or connectivity as part of the Autopilot Hybrid Join deployment, and the user is the only one impacted, not the Service Desk.\nI wouldn\u0026rsquo;t go as far to say this was a difficult problem, but with how flexible and powerful Proactive Remediation Scripts are, with the limitation only being your ability to write PowerShell (and obviously the correct licensing), I\u0026rsquo;d recommend using these more and more in place of wrapping PowerShell scripts as a Win32App and having to battle with creating \u0026rsquo;tag\u0026rsquo; files as a detection method.\n","date":"12 January 2023","permalink":"/posts/hybrid-join-computer-rename-again/","section":"Blog","summary":"Nothing has really changed in the Hybrid Join Autopilot space when it comes to device names, and we\u0026rsquo;re still stuck with useless naming conventions for these devices; sometimes a prefix and random characters just isn\u0026rsquo;t a good enough identification method for Windows devices.","title":"Proactively Renaming Hybrid Azure AD Joined Devices"},{"content":"Introduction # Have you ever had the pleasure of migrating Configuration Manager clients from one domain to another, or maybe between Configuration Manager environments? Tired of manually reinstalling the client from the Console? Wanting a quick and easy way to keep on top of migrated devices? You\u0026rsquo;re in luck.\nProblem Time # With the migration of clients between Configuration Manager environments, or between domains that Configuration Manager manages devices on, you\u0026rsquo;ll inevitably be in the situation where you need to reinstall the client on these devices to ensure that communication still occurs between the client and the Management Point.\nThe problem here, is that the underlying computer object, and associated machine account has changed, and from a Configuration Manager perspective will be treated, as it should, as a newly discovered client. You can remedy this by forcing the un-installation and an installation of the client from within the console, but this really isn\u0026rsquo;t practical for continued migration of clients. So we need a solution, and quickly.\nPowerShell to the Rescue # As always it\u0026rsquo;s PowerShell that will save us, a couple of useful in-built Configuration Manager commands, and a stolen/borrowed Configuration Manager Logging Function.\nThis one will be breezy.\nComputers without a Client # We could do this in a couple of ways, create a collection in Configuration Manager of all machines without the Client installed and use this collection to push the installation:\nselect SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.Client is null Or capture all non-default devices without the client using Get-CMdevice and target them directly:\nGet-CMdevice | Where-Object { ($_.IsClient -eq \u0026#39;\u0026#39;) -and ($_.SMSID -notlike \u0026#39;*Unknown Computer*\u0026#39; ) -and ($_.SMSID -notlike \u0026#39;*Provisioning Device*\u0026#39;) } We\u0026rsquo;re going with the latter as I\u0026rsquo;d like to know which machines are being targeted.\nTo use the Get-CMdevice command, we need to import and connect to the Configuration Manager instance using the below when on the Primary Site Server:\n# Load Configuration Manager PowerShell Module Import-Module ($Env:SMS_ADMIN_UI_PATH.Substring(0, $Env:SMS_ADMIN_UI_PATH.Length - 5) + \u0026#39;\\ConfigurationManager.psd1\u0026#39;) # Get SiteCode $SiteCode = Get-PSDrive -PSProvider CMSITE Set-Location $SiteCode\u0026#34;:\u0026#34; Logging Functions # No we\u0026rsquo;re connected we can use the command to capture all the devices we want to target, but we could do with a way to log wtf is going on as part of the re-installation, and in a format that CMTrace will be happy to read.\nFunction Write-log { [CmdletBinding()] Param( [parameter(Mandatory = $true)] [String]$Path, [parameter(Mandatory = $true)] [String]$Message, [parameter(Mandatory = $true)] [String]$Component, [Parameter(Mandatory = $true)] [ValidateSet(\u0026#39;Info\u0026#39;, \u0026#39;Warning\u0026#39;, \u0026#39;Error\u0026#39;)] [String]$Type ) switch ($Type) { \u0026#39;Info\u0026#39; { [int]$Type = 1 } \u0026#39;Warning\u0026#39; { [int]$Type = 2 } \u0026#39;Error\u0026#39; { [int]$Type = 3 } } # Create a log entry $Content = \u0026#34;\u0026lt;![LOG[$Message]LOG]!\u0026gt;\u0026#34; + ` \u0026#34;\u0026lt;time=`\u0026#34;$(Get-Date -Format \u0026#39;HH:mm:ss.ffffff\u0026#39;)`\u0026#34; \u0026#34; + ` \u0026#34;date=`\u0026#34;$(Get-Date -Format \u0026#39;M-d-yyyy\u0026#39;)`\u0026#34; \u0026#34; + ` \u0026#34;component=`\u0026#34;$Component`\u0026#34; \u0026#34; + ` \u0026#34;context=`\u0026#34;$([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)`\u0026#34; \u0026#34; + ` \u0026#34;type=`\u0026#34;$Type`\u0026#34; \u0026#34; + ` \u0026#34;thread=`\u0026#34;$([Threading.Thread]::CurrentThread.ManagedThreadId)`\u0026#34; \u0026#34; + ` \u0026#34;file=`\u0026#34;`\u0026#34;\u0026gt;\u0026#34; # Write the line to the log file Add-Content -Path $Path -Value $Content } If you\u0026rsquo;d like more detail head over to janikvonrotz.ch who wrote this function.\nWith the function in place, we just need to define the $LogFilePath variable and we\u0026rsquo;re good to capture whatever horrible errors we\u0026rsquo;re to encounter as part of the script.\n$LogFilePath = Join-Path $PSScriptRoot \u0026#34;$(Get-Date -Format yyyy-MM-dd-HHmm) $($MyInvocation.MyCommand.Name).log\u0026#34; And a way to punt the information or errors or warnings to the log file when we encounter then, something like:\nWrite-Error ($_ | Out-String) Write-Log -Path $LogFilePath -Message ($_ | Out-String) -Component $MyInvocation.MyCommand.Name -Type Error Below is an example of the output of the log file: Who would have thought I would bother putting in logging, it\u0026rsquo;s like I wrote this for an actual customer or something.\nClient Installation # With the bare-bone stuff in place, we will be using the Install-CMClient command to force the removal of the old client (-ForceReinstall) and force the installation of the new client (-AlwaysInstallClient), aggressive, I like it.\nI\u0026rsquo;ve chosen to use the -DeviceId as the device identifier, over -DeviceName or -Name as because we\u0026rsquo;re in a situation where there could be duplicate machine names in the case of a client domain migration, so we need something unique.\nPutting this together, we\u0026rsquo;ve now got the installation part of the script done, leaning on the existing $SiteCode variable to pass into this part of the script:\nInstall-CMClient -DeviceId $UnmanagedDevice.ResourceID -AlwaysInstallClient $true -ForceReinstall $true -SiteCode $SiteCode.Name As mentioned previously, if you were using a device collection to capture your devices without the Configuration Manager client, you could use the -CollectionId parameter instead of -DeviceId in the above script snippet.\nInstallation Time # With everything now in place, we can do the following:\nCapture the devices we want that don\u0026rsquo;t have the client installed, excluding the built-in Configuration Manager devices and Servers Loop through each device and install the Client Write to the log file when something good or bad happens This way, we can let Configuration Manager do all our heavy lifting, without manual intervention, or trying to run something from the client side to re-install the Configuration Manager Client.\nThe full script in all it\u0026rsquo;s glory can as always be found in GitHub\nIf you\u0026rsquo;re scared about running this script in anger, throw in a -WhatIf parameter at the end of line 57. # Load Configuration Manager PowerShell Module Import-Module ($Env:SMS_ADMIN_UI_PATH.Substring(0, $Env:SMS_ADMIN_UI_PATH.Length - 5) + \u0026#39;\\ConfigurationManager.psd1\u0026#39;) # Get SiteCode $SiteCode = Get-PSDrive -PSProvider CMSITE Set-Location $SiteCode\u0026#34;:\u0026#34; # Functions Function Write-log { [CmdletBinding()] Param( [parameter(Mandatory = $true)] [String]$Path, [parameter(Mandatory = $true)] [String]$Message, [parameter(Mandatory = $true)] [String]$Component, [Parameter(Mandatory = $true)] [ValidateSet(\u0026#39;Info\u0026#39;, \u0026#39;Warning\u0026#39;, \u0026#39;Error\u0026#39;)] [String]$Type ) switch ($Type) { \u0026#39;Info\u0026#39; { [int]$Type = 1 } \u0026#39;Warning\u0026#39; { [int]$Type = 2 } \u0026#39;Error\u0026#39; { [int]$Type = 3 } } # Create a log entry $Content = \u0026#34;\u0026lt;![LOG[$Message]LOG]!\u0026gt;\u0026#34; + ` \u0026#34;\u0026lt;time=`\u0026#34;$(Get-Date -Format \u0026#39;HH:mm:ss.ffffff\u0026#39;)`\u0026#34; \u0026#34; + ` \u0026#34;date=`\u0026#34;$(Get-Date -Format \u0026#39;M-d-yyyy\u0026#39;)`\u0026#34; \u0026#34; + ` \u0026#34;component=`\u0026#34;$Component`\u0026#34; \u0026#34; + ` \u0026#34;context=`\u0026#34;$([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)`\u0026#34; \u0026#34; + ` \u0026#34;type=`\u0026#34;$Type`\u0026#34; \u0026#34; + ` \u0026#34;thread=`\u0026#34;$([Threading.Thread]::CurrentThread.ManagedThreadId)`\u0026#34; \u0026#34; + ` \u0026#34;file=`\u0026#34;`\u0026#34;\u0026gt;\u0026#34; # Write the line to the log file Add-Content -Path $Path -Value $Content } # Log file location same as script $LogFilePath = Join-Path $PSScriptRoot \u0026#34;$(Get-Date -Format yyyy-MM-dd-HHmm) $($MyInvocation.MyCommand.Name).log\u0026#34; # Gets all devices without the CCM client that are not servers or inbuilt computer objects $UnmanagedDevices = Get-CMdevice | Where-Object { ($_.IsClient -eq \u0026#39;\u0026#39;) -and ($_.SMSID -notlike \u0026#39;*Unknown Computer*\u0026#39; ) -and ($_.SMSID -notlike \u0026#39;*Provisioning Device*\u0026#39;) -and ($_.DeviceOS -notlike \u0026#39;*Server*\u0026#39;) } Foreach ($UnmanagedDevice in $UnmanagedDevices) { Try { Write-Log -Path $LogFilePath -Message \u0026#34;Attempting to install CCM client on computer $($UnmanagedDevice.Name)\u0026#34; -Component $MyInvocation.MyCommand.Name -Type Info Install-CMClient -DeviceId $UnmanagedDevice.ResourceID -AlwaysInstallClient $true -ForceReinstall $true -SiteCode $SiteCode.Name } Catch { Write-Error ($_ | Out-String) Write-Log -Path $LogFilePath -Message ($_ | Out-String) -Component $MyInvocation.MyCommand.Name -Type Error } } If you need to keep this running on an on-going basis as part of a phased migration, I\u0026rsquo;d recommend hooking this into a Scheduled Task running from the Primary Site server, or if you\u0026rsquo;re feeling fancy, a Status Filter Rule to have the script triggered on an event captured by a one of the million Configuration Manager logs files for its components.\nSummary # Like I said, this one was a quick way to resolve an ongoing issue, but one that you may end up encountering if migrating clients between Configuration Manager sites, Domains, or even moving clients from a Workgroup to a Domain.\nAs always, remember to test the script in your environment, utilise the -WhatIf parameter, and update the $UnmanagedDevices variable based on your own environment requirements.\n","date":"15 December 2022","permalink":"/posts/configmgr-client-migration/","section":"Blog","summary":"Have you ever had the pleasure of migrating Configuration Manager clients from one domain to another, or maybe between Configuration Manager environments? Tired of manually reinstalling the client from the Console? Wanting a quick and easy way to keep on top of migrated devices? You\u0026rsquo;re in luck.","title":"Reinstalling the Configuration Manager Client on Migrated Devices"},{"content":"Introduction # So it turns out that Android based MTR (Microsoft Teams Rooms) want to enrol into Microsoft Intune using what we generally term as a legacy enrolment method in Android Device Administrator, one in fact, that is recommended to be disabled for \u0026lsquo;All Users\u0026rsquo; as it will take priority over Android Enterprise Personal Device Work Profile enrolment for personal device or BYOD (Bring Your Own Device) scenarios.\nThis seems easy enough, create a new Enrolment Restriction and assign it to a group containing the Microsoft Teams Rooms resource accounts. Done. Post over.\nWhat if you want to ensure that all these accounts, and any future accounts used for MTR get this allowance for enrolment?\nDevice Enrolment # First off is creating an Enrolment Restriction profile that allows for Android Device Administrator enrolment, secondly is how we let Intune know that the devices are corporate owned, as they will be picked up as personal devices due to the enrolment method, and finally a way to capture all the MTR resource accounts together.\nEnrolment Restrictions # We can create a new Enrolment Restriction to allow for a group of users to enrol Android devices using the Device Administrator enrolment method, and we should block personal devices as well:\nWith the restriction now created, we need to make sure that this restriction has a higher priority than any other enrolment restriction applying to either All Users or any other group that may contains the MTR resource accounts:\nPerfect.\nCorporate Device Identifiers # With the Android Device Administrator enrolment being user driven, and not a method for device enrolment that will automatically set the device as corporate owned, if we attempted to enrol these MTR devices into Intune now, we\u0026rsquo;d get an error about the platform not being supported due to us blocking personal devices in the restriction we created.\nCorporate Device Identifiers to the rescue, kind of, basically this allows us to upload a unique identifier of a device so that when a device goes through an enrolment process, Intune knows it\u0026rsquo;s a corporate owned device.\nSo if the devices are running Android 10 and above, we\u0026rsquo;re straight out of luck and need to amend our restriction profile to allow personally owned device enrolment.\nHowever, if the device has below Android 10, we can add either the device IMEI number (don\u0026rsquo;t use this) or Serial number (do use this) in Intune to identify the device as corporate.\nUtilising Dynamic Groups # With the Device Platform Enrolment restriction in place, we could do with a group to assign this restriction to, if we\u0026rsquo;re strict with our naming conventions of these resource accounts being used for the MTR, such as prefixing all account with \u0026lsquo;MTR-\u0026rsquo;, we could go with something simple and use (user.userPrincipalName -startsWith \u0026quot;MTR-\u0026quot;) as part of our rule syntax.\nSadly though, I don\u0026rsquo;t like nor trust human input when it comes to device management and Intune, so we need to find a different way that at least reduces the human error part, if not removes it entirely and ensure that all new MTR accounts are added to the restriction.\nAssigned Licenses # This is where we use some of the more advanced features of Dynamic User groups, in the multi-value properties and in particular the use of licenses assigned to users. For this, we need to understand which licenses the MTR resource accounts have assigned, and find the correlating Service Plan Id for each service contained within the licenses.\nThe below table details the common services for both the \u0026lsquo;Microsoft Teams Rooms Pro\u0026rsquo; and \u0026lsquo;Microsoft Teams Rooms Pro without Audio Conferencing\u0026rsquo; licenses that allows for enrolment into Intune, the Services, and the Service Plan Ids:\nFriendly Name Service Name Service Plan Id Azure Active Directory Premium P1 AAD_PREMIUM 41781fb2-bc02-4b7c-bd55-b576c07bb09d Microsoft 365 Phone System MCOEV 4828c8ec-dc2e-4779-b502-87ac9ce28ab7 Microsoft Intune INTUNE_A c1ec4a95-1f05-45b3-a911-aa3fa01094f5 Microsoft Teams TEAMS1 57ff2da0-773e-42df-b2af-ffb7a2317929 Skype for Business Online (Plan 2) MCOSTANDARD 0feaeb32-d00e-4d66-bd5a-43b5b83db82c Whiteboard (Plan 3) WHITEBOARD_PLAN3 4a51bca5-1eff-43f5-878c-177680f191af So with this we can attempt to construct a Dynamic User group based on these services that are assigned and enabled for the MTR accounts.\nSome Dirty Logic # So as it turns out, the above services are part of a hundred other license options, so we need a way to drill down and find only the MTR accounts with these licenses or services assigned.\nI thought long and hard (about 5 minutes tbh) and came up with the below; basically making sure the above assigned licenses exist, but the user account doesn\u0026rsquo;t have any Exchange Online or SharePoint Online license assigned and enabled, hopefully filtering out any other users or user types from the group.\nWe\u0026rsquo;re actually using the Service Name captured from the Get-AzureADUser -User 'MTR-Room1@ennbee.uk' | Select -ExpandProperty AssignedPlans PowerShell command here, to cover off all plan types under the service, as there are so many Exchange Online plan types and I want to make this as clean as possible without having to list all the Exchange Online or SharePoint Online service plan Ids.\nSo here\u0026rsquo;s the logic we\u0026rsquo;re using to find only the MTR accounts using a Dynamic Group:\nUser is assigned a Microsoft 365 Phone System license and is enabled: (user.assignedPlans -any (assignedPlan.servicePlanId -eq \u0026quot;4828c8ec-dc2e-4779-b502-87ac9ce28ab7\u0026quot; -and assignedPlan.capabilityStatus -eq \u0026quot;Enabled\u0026quot;))\nUser is assigned any Intune license and is enabled: (user.assignedPlans -any (assignedPlan.service -eq \u0026quot;SCO\u0026quot; -and assignedPlan.capabilityStatus -eq \u0026quot;Enabled\u0026quot;))\nUser is assigned any Teams license and is enabled: (user.assignedPlans -any (assignedPlan.service -eq \u0026quot;TeamspaceAPI\u0026quot; -and assignedPlan.capabilityStatus -eq \u0026quot;Enabled\u0026quot;))\nUser is assigned any Skype for Business license and is enabled: (user.assignedPlans -any (assignedPlan.service -eq \u0026quot;MicrosoftCommunicationsOnline\u0026quot; -and assignedPlan.capabilityStatus -eq \u0026quot;Enabled\u0026quot;))\nUser is assigned a WhiteBoard Plan 3 license and is enabled: (user.assignedPlans -any (assignedPlan.servicePlanId -eq \u0026quot;4a51bca5-1eff-43f5-878c-177680f191af\u0026quot; -and assignedPlan.capabilityStatus -eq \u0026quot;Enabled\u0026quot;))\nUser is not assigned any Exchange Online license that is enabled or deleted: (user.assignedPlans -all (assignedPlan.service -ne \u0026quot;exchange\u0026quot; -and assignedPlan.capabilityStatus -eq \u0026quot;Enabled\u0026quot; -or assignedPlan.capabilityStatus -eq \u0026quot;Deleted\u0026quot;))\nUser is not assigned any SharePoint Online license that is enabled or deleted: (user.assignedPlans -all (assignedPlan.service -ne \u0026quot;SharePoint\u0026quot; -and assignedPlan.capabilityStatus -eq \u0026quot;Enabled\u0026quot; -or assignedPlan.capabilityStatus -eq \u0026quot;Deleted\u0026quot;))\nAllowing Microsoft Team Room Enrolment # After all this effort, we can finally create the a group in Azure AD using some of the above and combine it to create the needed Rule Syntax.\nIn the below example, the accounts didn\u0026rsquo;t have a Microsoft 365 Phone System license so the (user.assignedPlans -any (assignedPlan.servicePlanId -eq \u0026quot;4828c8ec-dc2e-4779-b502-87ac9ce28ab7\u0026quot; -and assignedPlan.capabilityStatus -eq \u0026quot;Enabled\u0026quot;)) part of the rule was removed:\n(user.assignedPlans -any (assignedPlan.service -eq \u0026#34;SCO\u0026#34; -and assignedPlan.capabilityStatus -eq \u0026#34;Enabled\u0026#34;)) and (user.assignedPlans -any (assignedPlan.service -eq \u0026#34;TeamspaceAPI\u0026#34; -and assignedPlan.capabilityStatus -eq \u0026#34;Enabled\u0026#34;)) and (user.assignedPlans -any (assignedPlan.service -eq \u0026#34;MicrosoftCommunicationsOnline\u0026#34; -and assignedPlan.capabilityStatus -eq \u0026#34;Enabled\u0026#34;)) and (user.assignedPlans -any (assignedPlan.servicePlanId -eq \u0026#34;4a51bca5-1eff-43f5-878c-177680f191af\u0026#34; -and assignedPlan.capabilityStatus -eq \u0026#34;Enabled\u0026#34;)) and (user.assignedPlans -all (assignedPlan.service -ne \u0026#34;exchange\u0026#34; -and assignedPlan.capabilityStatus -eq \u0026#34;Enabled\u0026#34; -or assignedPlan.capabilityStatus -eq \u0026#34;Deleted\u0026#34;)) and (user.assignedPlans -all (assignedPlan.service -ne \u0026#34;SharePoint\u0026#34; -and assignedPlan.capabilityStatus -eq \u0026#34;Enabled\u0026#34; -or assignedPlan.capabilityStatus -eq \u0026#34;Deleted\u0026#34;)) The Dynamic Group # Once created we now have a group and a set of rules that you should validate in your own environment before putting into production use. You may also need to tweak the logic based on which services you have enabled as part of your MTR licensing assignment.\nIf all goes well, and you\u0026rsquo;ve managed to copy and paste successfully, you should have a group with rules like the below:\nIf you\u0026rsquo;re really lucky, the group will only populate with the user accounts you are using for the Microsoft Team Room systems, including the Android devices.\nUpdating the Enrolment Restriction # Now armed with the new group, we can use this as part of the restriction to allow these users to enrol Android devices using the Android Device Administrator method:\nSummary # You\u0026rsquo;ve seen here that with a bit of time and patience, you can leverage Dynamic Groups and some of the advanced rules to your advantage, even with an edge use case like allowing only Microsoft Teams Room system accounts the ability to enrol using Android Device Administrator.\nThis is one of many applications of Dynamic Groups throughout Microsoft Intune, and although I bad mouthed them in favour of Device Filters, they are still a necessity when you need a level of advanced logic that the filters can\u0026rsquo;t handle.\n","date":"14 November 2022","permalink":"/posts/microsoft-teams-rooms-android-device-administrator/","section":"Blog","summary":"What if you want to ensure that all of your Microsoft Teams Rooms System accounts, and any future accounts can enrol using Android Device Administrator in Microsoft Intune?","title":"Enrolling Microsoft Teams Room Systems in Intune"},{"content":"","date":"1 November 2022","permalink":"/tags/administration/","section":"Tags","summary":"","title":"Administration"},{"content":"","date":"1 November 2022","permalink":"/tags/authentication/","section":"Tags","summary":"","title":"Authentication"},{"content":"Introduction # With the impending retirement of the Azure AD Graph API and ADAL authentication methods, and by impending, I mean the end of 2022, we should probably look at how we move away from the existing authentication methods I\u0026rsquo;ve been using in all of my scripts and into the new realms of MSAL (Microsoft Authentication Library).\nHold tight, this will be quick.\nBackground # The driver for this move away from the now deemed legacy ADAL (Azure Active Directory Authentication Library) authentication method, is Microsoft\u0026rsquo;s aim to move everyone and everything to PowerShell 7 core and allow for full cross-platform compatibility for PowerShell.\nThe issue with PowerShell 7 however, is that it doesn\u0026rsquo;t natively support the \u0026lsquo;old\u0026rsquo; ADAL authentication libraries only with the use of -UseWindowsPowerShell compatibility flag, hence the need to move to an alternative authentication method.\nMSAL PowerShell Module # Save reinventing the wheel, we can use the MSAL.PS module written by Jason Thompson to achieve authentication to Graph API without the reliance on PowerShell 5 and the AzureAD or ADAL PowerShell modules.\nThis module has been designed to utilise PowerShell core and subsequently be operating system agnostic, with a new device code authentication workflow for devices that have constraints around input.\nInstall-Module MSAL.PS -Scope CurrentUser So we can now use the well used Microsoft Intune PowerShell App Id, and our tenant information to authenticate using the MSAL.PS module using ths new -DeviceCode option for authentication, generating a code that we can use on any device to authenticate on behalf of our initial request:\nGet-MsalToken -ClientId \u0026#39;d1ddf0e4-d672-4dae-b554-9d5bdfd93547\u0026#39; -TenantId \u0026#39;ennbee.uk\u0026#39; -DeviceCode Opening up the presented URL https://microsoft.com/devicelogin prompts us to enter in the code we received: From here we can sign in with the required User Account: Confirm the Application we are signing into: Finally receiving confirmation of the sign in and a prompt to close the window: Once the Window is closed, we now have an authentication token in the shell to use to our heart\u0026rsquo;s content.\nThe New World # With a new way to acquire our Graph API token, we should look at updating the tried and tested Authentication Methods kindly provided by Microsoft in the powershell-intune-samples repo that we have been relying on to authenticate to Graph API.\nAn Updated Function # We need to update the Get-AuthToken function, and sensibly rename it, to do the following:\nDetect the new MSAL.PS PowerShell module and prompt if it\u0026rsquo;s not installed Import the MSAL.PS PowerShell module Strip out the unneeded variables Remove any and all reference to the ADAL DLL libraries Get a new authentication token Function Get-AuthTokenMSAL { \u0026lt;# .SYNOPSIS This function is used to authenticate with the Graph API REST interface .DESCRIPTION The function authenticate with the Graph API Interface with the tenant name .EXAMPLE Get-AuthTokenMSAL Authenticates you with the Graph API interface using MSAL.PS module .NOTES NAME: Get-AuthTokenMSAL #\u0026gt; [cmdletbinding()] param ( [Parameter(Mandatory = $true)] $User ) $userUpn = New-Object \u0026#39;System.Net.Mail.MailAddress\u0026#39; -ArgumentList $User if ($userUpn.Host -like \u0026#39;*onmicrosoft.com*\u0026#39;) { $tenant = Read-Host -Prompt \u0026#39;Please specify your Tenant name i.e. company.com\u0026#39; Write-Host } else { $tenant = $userUpn.Host } Write-Host \u0026#39;Checking for MSAL.PS module...\u0026#39; $MSALModule = Get-Module -Name \u0026#39;MSAL.PS\u0026#39; -ListAvailable if ($null -eq $MSALModule) { Write-Host Write-Host \u0026#39;MSAL.PS Powershell module not installed...\u0026#39; -f Red Write-Host \u0026#34;Install by running \u0026#39;Install-Module MSAL.PS -Scope CurrentUser\u0026#39; from an elevated PowerShell prompt\u0026#34; -f Yellow Write-Host \u0026#34;Script can\u0026#39;t continue...\u0026#34; -f Red Write-Host exit } if ($MSALModule.count -gt 1) { $Latest_Version = ($MSALModule | Select-Object version | Sort-Object)[-1] $MSALModule = $MSALModule | Where-Object { $_.version -eq $Latest_Version.version } # Checking if there are multiple versions of the same module found if ($MSALModule.count -gt 1) { $MSALModule = $MSALModule | Select-Object -Unique } } $ClientId = \u0026#39;d1ddf0e4-d672-4dae-b554-9d5bdfd93547\u0026#39; $RedirectUri = \u0026#39;urn:ietf:wg:oauth:2.0:oob\u0026#39; $Authority = \u0026#34;https://login.microsoftonline.com/$Tenant\u0026#34; try { Import-Module $MSALModule.Name if ($PSVersionTable.PSVersion.Major -ne 7) { $authResult = Get-MsalToken -ClientId $ClientId -Interactive -RedirectUri $RedirectUri -Authority $Authority } else { $authResult = Get-MsalToken -ClientId $ClientId -Interactive -RedirectUri $RedirectUri -Authority $Authority -DeviceCode } # If the accesstoken is valid then create the authentication header if ($authResult.AccessToken) { # Creating header for Authorization token $authHeader = @{ \u0026#39;Content-Type\u0026#39; = \u0026#39;application/json\u0026#39; \u0026#39;Authorization\u0026#39; = \u0026#39;Bearer \u0026#39; + $authResult.AccessToken \u0026#39;ExpiresOn\u0026#39; = $authResult.ExpiresOn } return $authHeader } else { Write-Host Write-Host \u0026#39;Authorization Access Token is null, please re-run authentication...\u0026#39; -ForegroundColor Red Write-Host break } } catch { Write-Host $_.Exception.Message -f Red Write-Host $_.Exception.ItemName -f Red Write-Host break } } Updating Authentication Method # With the new Get-AuthTokenMSAL function in our arsenal, we can quickly update the authentication method to call this function.\nif ($global:authToken) { $DateTime = (Get-Date).ToUniversalTime() $TokenExpires = ($authToken.ExpiresOn.datetime - $DateTime).Minutes if ($TokenExpires -le 0) { Write-Host \u0026#39;Authentication Token expired\u0026#39; $TokenExpires \u0026#39;minutes ago\u0026#39; -ForegroundColor Yellow if ($null -eq $User -or $User -eq \u0026#39;\u0026#39;) { $User = Read-Host -Prompt \u0026#39;Please specify your user principal name for Azure Authentication\u0026#39; } $global:authToken = Get-AuthTokenMSAL -User $User Write-Host \u0026#39;Connected to Graph API\u0026#39; -ForegroundColor Green } Else { Write-Host \u0026#39;Connected to Graph API\u0026#39; -ForegroundColor Green } } else { if ($null -eq $User -or $User -eq \u0026#39;\u0026#39;) { $User = Read-Host -Prompt \u0026#39;Please specify your user principal name for Azure Authentication\u0026#39; } $global:authToken = Get-AuthTokenMSAL -User $User Write-Host \u0026#39;Connected to Graph API\u0026#39; -ForegroundColor Green } Running both the function and authentication code gives us something like the below:\nAnd once you\u0026rsquo;ve run through the Device Code authentication method show earlier, it will give you the token you need in the $authToken variable to use across all the existing scripts in the powershell-intune-samples\nSummary # With the MSAL based authentication in place, and updating scripts to use the new function and associated code, we can lean back and relax a little when Microsoft depreciates and ends the use of ADAL based authentication methods.\nIf you\u0026rsquo;d like a more detailed understanding of MSAL and how to move away from ADAL, I\u0026rsquo;d recommend having a glance over the following:\nOverview of the Microsoft Authentication Library (MSAL) Migrate applications to the Microsoft Authentication Library (MSAL) I won\u0026rsquo;t be, I\u0026rsquo;ll be tirelessly updating all my scripts to use the new authentication method. This is what happens when Microsoft extends their deadlines and gives you more time to use old technologies.\n","date":"1 November 2022","permalink":"/posts/finally-moving-to-msal-auth/","section":"Blog","summary":"With the impending retirement of the Azure AD Graph API and ADAL authentication methods, and by impending, I mean the end of 2022, we should probably look at how we move away from the existing authentication methods.","title":"Migrating from AzureAD Authentication for Graph API"},{"content":"","date":"25 October 2022","permalink":"/tags/defender/","section":"Tags","summary":"","title":"Microsoft Defender"},{"content":"Introduction # So one of those rainy days is here, finally, and as I mentioned in Windows Operating System Compliance Updates many months ago, I said I\u0026rsquo;d look at ways to update other update based compliance policies periodically.\nThat time is now, and although we\u0026rsquo;re not focussing on other Operating Systems, we\u0026rsquo;re going to have a look at updating a Microsoft Defender compliance policy with the latest platform update version.\nExciting I know.\nCompliance Policy Updates # To reiterate from the previous post, and to hammer the point home, you should be updating these types of policies on a regular basis. When you update a Compliance Policy, it will trigger the devices the policy is assigned to, to re-evaluate the conditions and follow the actions for non-compliance if necessary.\nFor the Defender settings, the one we\u0026rsquo;re wanting to update is Microsoft Defender Antimalware minimum version, which if left blank will accept any version of the service, but we should be requiring an up to date version here, you know, for security.\nExisting Functions # As we have looked at this topic previously, we\u0026rsquo;re going to re-use some of the existing functions in this script that we created previously:\nGet-AuthToken Test-JSON Get-DeviceCompliancePolicy Update-DeviceCompliancePolicy We will also need to create a new one, to retrieve the latest Microsoft Defender Update using the Microsoft Feed Picker for Microsoft Defender Updates.\nGetting Latest Platform Update Version # So the feed we\u0026rsquo;ll be using, doesn\u0026rsquo;t actually contain the platform update version, unlike the Windows Operating System feeds which put the information we needed on a plate, this time we need to work a little.\nWe can at least use our previous attempts at capturing the RSS data, but this time, instead of grabbing the data from the feed itself and working with it, we need to grab the link that exists in the feed, grab the data from that page in order to get the version information we need to update the Compliance Policy.\nWe can capture the link we need and associate with the variable $DefenderUpdateUri, and using a bit of magic, we can scrape the data from this link, and capture only the information we need, in this instance it\u0026rsquo;s the \u0026lsquo;New version\u0026rsquo; section of the page:\n$uri = \u0026#39;https://support.microsoft.com/en-us/feed/atom/5d4715e7-a9c9-378e-3f83-fd410db4ef0a\u0026#39; [xml]$Updates = (Invoke-WebRequest -Uri $uri -UseBasicParsing -ContentType \u0026#39;application/xml\u0026#39;).Content -replace \u0026#39;[^\\x09\\x0A\\x0D\\x20-\\xD7FF\\xE000-\\xFFFD\\x10000-x10FFFF]\u0026#39;, \u0026#39;\u0026#39; $DefenderUpdateUri = @() foreach ($Update in $Updates.feed.entry) { if ($Update.title.\u0026#39;#text\u0026#39; -like \u0026#39;*platform*\u0026#39;) { $DefenderUpdateUri += $Update.link.href } } $DefenderPlatformUpdate = Invoke-WebRequest -Uri $($DefenderUpdateUri[0]) $DefenderPlatformVersion = (($DefenderPlatformUpdate.Content).tostring() -split \u0026#34;[`r`n]\u0026#34; | Select-String \u0026#39;New version:\u0026#39;) -replace \u0026#39;[^0-9.]\u0026#39; Yes I know this is rough af, yes I know I am relying on the data existing on the page, yes I know that splitting out raw content into separate lines, selecting string data containing the information I want and stripping away everything but the numbers and periods is absolutely awful, this was a quick script OK, I\u0026rsquo;ll give myself a dead leg as penance. A New Function is Born # So with this absolute atrocity of a method of getting the platform update version, we should wrap it all nicely into a function so we can call it in the script.\nFunction Get-LatestDefenderPlatformUpdate() { try { $uri = \u0026#39;https://support.microsoft.com/en-us/feed/atom/5d4715e7-a9c9-378e-3f83-fd410db4ef0a\u0026#39; [xml]$Updates = (Invoke-WebRequest -Uri $uri -UseBasicParsing -ContentType \u0026#39;application/xml\u0026#39;).Content -replace \u0026#39;[^\\x09\\x0A\\x0D\\x20-\\xD7FF\\xE000-\\xFFFD\\x10000-x10FFFF]\u0026#39;, \u0026#39;\u0026#39; $DefenderUpdateUri = @() foreach ($Update in $Updates.feed.entry) { if ($Update.title.\u0026#39;#text\u0026#39; -like \u0026#39;*platform*\u0026#39;) { $DefenderUpdateUri += $Update.link.href } } $DefenderPlatformUpdate = Invoke-WebRequest -Uri $($DefenderUpdateUri[0]) $DefenderPlatformVersion = (($DefenderPlatformUpdate.Content).tostring() -split \u0026#34;[`r`n]\u0026#34; | Select-String \u0026#39;New version:\u0026#39;) -replace \u0026#39;[^0-9.]\u0026#39; Write-Host Write-Host \u0026#34;Latest Defender Platform - $DefenderPlatformVersion\u0026#34; -ForegroundColor Cyan $DefenderPlatformVersion } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Updating Compliance Policies # So with all the functions we need, we can attack the script that will actually update the Compliance Policy. As we\u0026rsquo;ve done something similar previously, I don\u0026rsquo;t need to use my brain too much to hack around with the existing script, but there are some key areas to focus on\u0026hellip;\nGetting the Defender Policy # We need to make sure we\u0026rsquo;re grabbing the Defender policies for Windows devices so a little bit of a filter here. We\u0026rsquo;re using the @odata.type and the defenderEnabled data here.\n$DefenderCompliancePolicies = Get-DeviceCompliancePolicy | Where-Object { ($_.\u0026#39;@odata.type\u0026#39;).contains(\u0026#39;windows10CompliancePolicy\u0026#39;) -and ($_.defenderEnabled) -ne \u0026#39;\u0026#39; } Building the JSON Content # We need to build the JSON content to update the Compliance Policy with, based on the existing data and the new Microsoft Defender Platform version. We also can use a bit of logic to see if the current version in the Compliance Policy is less than the new one, so we\u0026rsquo;re not needlessly updating the policy.\n$Date = Get-Date $Description = \u0026#34;Updated Defender Antivirus Compliance Policy on $Date\u0026#34; $DefenderPlatformVersion = Get-LatestDefenderPlatformUpdate $Update = New-Object -TypeName psobject $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.windows10CompliancePolicy\u0026#39; $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;description\u0026#39; -Value $Description foreach ($DefenderCompliancePolicy in $DefenderCompliancePolicies) { if ($DefenderCompliancePolicy.defenderVersion -lt $DefenderPlatformVersion) { Write-Host Write-Host \u0026#34;Updating Defender Antivirus Compliance Policy - $($DefenderCompliancePolicy.displayname)\u0026#34; -ForegroundColor Green $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;defenderVersion\u0026#39; -Value $DefenderPlatformVersion # Creating JSON object to pass to Graph $JSON = $Update | ConvertTo-Json -Depth 3 # Updating the compliance policy Update-DeviceCompliancePolicy -Id $DefenderCompliancePolicy.id -JSON $JSON } else { Write-host \u0026#34;Defender Antivirus Compliance Policy - $($DefenderCompliancePolicy.displayname) already up to date\u0026#34; -ForegroundColor Cyan } } Running the Script # First off let\u0026rsquo;s look at the existing out-of-date Defender Compliance Policy, yup, that\u0026rsquo;s an old version of the platform: We should run the script, and make use of the hour it took to write it:\n.\\Set-DefenderCompliance.ps1 Running the script will prompt you to provide a username and connect to Graph, please do what it says and login: Then it does it\u0026rsquo;s job: Checking the policy to see if it updated: And it did, I\u0026rsquo;m as surprised as you are tbh.\nSummary # The whole script is pretty shoddy even for the minimal effort it took, but it is functional (as of today), that\u0026rsquo;s the main thing.\nThe things you do when customers ask you about automating the recommendations you present to them eh?\n","date":"25 October 2022","permalink":"/posts/defender-antivirus-compliance-updates/","section":"Blog","summary":"We\u0026rsquo;re going to have a look at updating a Microsoft Defender compliance policy with the latest platform update version, automatically.","title":"Updating Defender Antivirus Compliance Settings"},{"content":"","date":"27 September 2022","permalink":"/tags/google/","section":"Tags","summary":"","title":"Google"},{"content":"Introduction # We\u0026rsquo;ve all had to add Managed Google Play Apps in bulk to Microsoft Intune for your Android Enterprise enrolled devices, whether this is just the raft of Microsoft Apps now that all your data is in Office 365, or the hundreds you have in a rival MDM (Mobile Device Management) solution that you\u0026rsquo;re looking to migrate away from.\nAnyone fancy doing this one by one with lots of mouse clicks and early onset repetitive strain injury? Didn\u0026rsquo;t think so.\nThis will be a quick one, and annoyingly does require a bit of effort to get the app details\u0026hellip;more on that later though. Onto the fun part.\nManaged Google Play Apps # As always we\u0026rsquo;re leaning on Graph again, as with everything in Microsoft Intune, and knowing we\u0026rsquo;ve setup our Managed Google Play account already, we can leverage this to add some Android Enterprise Apps into our tenant.\nAndroid Enterprise apps can\u0026rsquo;t be added to Microsoft Intune in the same way as iOS Store Apps or even Play Store Apps, so we can\u0026rsquo;t use POST /deviceAppManagement/mobileApps for creating these in the tenant. All the work is done at the Google side, so luckily we have a way to call this via the Graph API.\nApproving and Syncing Applications # We\u0026rsquo;re not actually creating anything here, all the Apps and the associated data exists within the Managed Play Store, what we need to do is approve an app. We can use the POST /deviceManagement/androidManagedStoreAccountEnterpriseSettings/approveApps action to our advantage.\nWe can make a POST call to the below URI with some JSON to approve the applications we need.\nhttps://graph.microsoft.com/beta/deviceManagement/androidManagedStoreAccountEnterpriseSettings/approveApps The JSON format we need to pass through using this call is in the format below.\n{ \u0026#34;packageIds\u0026#34;: [ \u0026#34;Package Ids value\u0026#34; ], \u0026#34;approveAllPermissions\u0026#34;: true } What Microsoft don\u0026rsquo;t tell you in the documentation is that the \u0026ldquo;Package Ids value\u0026rdquo; actually needs to be in the format \u0026ldquo;app:PackageId\u0026rdquo;, i.e. \u0026ldquo;app:com.microsoft.emmx\u0026rdquo;, thanks Microsoft. So we\u0026rsquo;ve got the bare bones of an idea, so what we need to do is get our App Package Ids together for all the Mobile Apps we want. What? You don\u0026rsquo;t have these to hand? Well sadly there isn\u0026rsquo;t a \u0026lsquo;scripty\u0026rsquo; way of getting these, not for free at least, so I\u0026rsquo;ll do you a solid and provide a list of some of the common Microsoft ones.\nMobile App Name Package ID Microsoft Authenticator com.azure.authenticator Microsoft Edge com.microsoft.emmx Microsoft Excel com.microsoft.office.excel Microsoft OneDrive com.microsoft.skydrive Microsoft OneNote com.microsoft.office.onenote Microsoft Outlook com.microsoft.office.outlook Microsoft Planner com.microsoft.planner Microsoft PowerPoint com.microsoft.office.powerpoint Microsoft SharePoint com.microsoft.sharepoint Microsoft Stream com.microsoft.stream Microsoft Teams com.microsoft.teams Microsoft To Do com.microsoft.todos Microsoft Word com.microsoft.office.word Microsoft Yammer com.yammer.v1 For any others, maybe your existing MDM has them listed next the App Name, otherwise you can find an app\u0026rsquo;s package name in the URL of the app‚Äôs Google Play Store listing.\nFor example, the URL of an app page is play.google.com/store/apps/details?id=com.example.app123. The app\u0026rsquo;s package name is com.example.app123.\nAs we\u0026rsquo;re using PowerShell, we could do with throwing these Package Ids into an array of some sort, just so we can loop through them later on.\n$AndroidAppIds = New-Object -TypeName System.Collections.ArrayList $AndroidAppIds.AddRange(@( \u0026#39;com.azure.authenticator\u0026#39;, \u0026#39;com.microsoft.emmx\u0026#39;, \u0026#39;com.microsoft.office.excel\u0026#39;, \u0026#39;com.microsoft.skydrive\u0026#39;, \u0026#39;com.microsoft.office.onenote\u0026#39;, \u0026#39;com.microsoft.office.outlook\u0026#39;, \u0026#39;com.microsoft.planner\u0026#39;, \u0026#39;com.microsoft.office.powerpoint\u0026#39;, \u0026#39;com.microsoft.sharepoint\u0026#39;, \u0026#39;com.microsoft.stream\u0026#39;, \u0026#39;com.microsoft.teams\u0026#39;, \u0026#39;com.microsoft.todos\u0026#39;, \u0026#39;com.microsoft.office.word\u0026#39;, \u0026#39;com.yammer.v1\u0026#39; ) ) We could have also prefixed the Package Id with the required \u0026lsquo;app:\u0026rsquo; but that\u0026rsquo;s one for later me.\nThe Functions # Now we have our list of Package Ids for the Mobile Apps in a nice format, we need to build a couple of functions (obviously) to approve the Mobile Apps and then synchronise the Apps to the Microsoft Intune tenant.\nApproving Managed Google Apps # You would have seen this format for Graph functions a lot on this site, but the important thing here is how we\u0026rsquo;re building the JSON object and adding in the required prefix.\nFunction Add-GoogleApplication() { param ( $PackageID ) $graphApiVersion = \u0026#39;Beta\u0026#39; $App_resource = \u0026#39;deviceManagement/androidManagedStoreAccountEnterpriseSettings/approveApps\u0026#39; try { if (!$PackageID) {} Write-Host \u0026#39;No PackageID was passed to the function, provide a valid PackageID variable\u0026#39; -f Red break } $PackageID = \u0026#39;app:\u0026#39; + $PackageID $Packages = New-Object -TypeName psobject $Packages | Add-Member -MemberType NoteProperty -Name \u0026#39;approveAllPermissions\u0026#39; -Value \u0026#39;true\u0026#39; $Packages | Add-Member -MemberType NoteProperty -Name \u0026#39;packageIds\u0026#39; -Value @($PackageID) $JSON = $Packages | ConvertTo-Json -Depth 3 $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($App_resource)\u0026#34; Invoke-RestMethod -Uri $uri -Method Post -ContentType \u0026#39;application/json\u0026#39; -Body $JSON -Headers $authToken write-host \u0026#34;Successfully added $PackageID from Managed Google Store\u0026#34; -ForegroundColor Green } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Synchronising Managed Google Apps # Now that we have a way to Approve the apps, we need a way to sync them\u0026hellip;bring on the POST /deviceManagement/androidManagedStoreAccountEnterpriseSettings/syncApps the below function, and a POST call to the below URI\nhttps://graph.microsoft.com/beta/deviceManagement/androidManagedStoreAccountEnterpriseSettings/syncApps Function Invoke-SyncGoogleApplication() { [cmdletbinding()] param ( $PackageID ) $graphApiVersion = \u0026#39;Beta\u0026#39; $App_resource = \u0026#39;deviceManagement/androidManagedStoreAccountEnterpriseSettings/syncApps\u0026#39; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($App_resource)\u0026#34; Invoke-RestMethod -Uri $uri -Method Post -ContentType \u0026#39;application/json\u0026#39; -Body $JSON -Headers $authToken Write-Host \u0026#34;Successfully synchronised Google Apps\u0026#34; -ForegroundColor Green } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Running the Script # Throwing in the Get-AuthTokenMSAL function we know and love to the above functions, the authentication section to Graph API, the array variable we created, and the below little snippet of a foreach loop, we can happily run through each of the Mobile App Package Ids and approve them, rounding it off with a quick sync.\nforeach($AndroidAppId in $AndroidAppIds) { Add-GoogleApplication -PackageID $AndroidAppId } Invoke-SyncGoogleApplication The full Script can be found in my GitHub Repo and as always, please test this before adding hundreds of apps to the variable, you\u0026rsquo;ll thank me later.\nRunning the script gives us the following output: After a little while, we\u0026rsquo;ll see the Mobile Apps in the Microsoft Intune Android Apps Portal With the Mobile Apps now in the tenant, you can go ahead and assign them to your hearts content\u0026hellip;or maybe script something to do this for you?\nSummary # Even if grabbing the packageId for each mobile app you want to approve and synchronise to Microsoft Intune is a a bit of a pain, and trust me, I looked at free ways to query the Play Store, this at least cuts the time down for synchronising Managed Google Play apps, especially as part of a migration to Intune.\n","date":"27 September 2022","permalink":"/posts/approving-managed-google-play-apps/","section":"Blog","summary":"We\u0026rsquo;ve all had to add Managed Google Play Apps in bulk to Microsoft Intune for your Android Enterprise enrolled devices, sometimes in the hundreds, let\u0026rsquo;s see if we can make this easier and less clicky.","title":"The Easy Way to Approve Managed Google Play Apps"},{"content":"Introduction # Everyone likes managing clients apps in Microsoft Intune, the grind of packing Windows apps, the chore of selecting Managed Google Play apps, the joy of assigning Apple VPP app licenses in Apple Business Manager\u0026hellip;all good fun.\nWhat about assigning App Categories, do you want to be manually updating hundreds of Apps with categories? Let\u0026rsquo;s make one laborious task, less laborious, with a hacky PowerShell script.\nApp Categories # Microsoft Intune comes with a number of in-built App Categories, that you can assign to a subset of Applications, to make it easier for users to find the apps they need using the Company Portal.\nAs these are designed for use in the Company Portal, not all Apps can have categories assigned to them, mainly Managed Google Play apps, everything else we\u0026rsquo;ll have a crack at.\nThe original list of categories is a little limited, and might not fit your application estate. So we should do something about this.\nCreating App Categories # You could just create new app categories using Microsoft Intune, but I\u0026rsquo;m not sure that\u0026rsquo;s as exciting as you think it is, so we\u0026rsquo;ll do this the sensible way and script it. To do this, we will need a way to get the existing App Categories (so we don\u0026rsquo;t create duplicates) and of course a way to create new ones.\nAs always, it\u0026rsquo;s time for some authentication to Graph API and using the trusted Authentication function we\u0026rsquo;ve used time and time before.\nGetting App Categories # We\u0026rsquo;ll be using the GET /deviceAppManagement/mobileAppCategories part of Graph for most of this, and the List option to get all existing categories using the function below.\nFunction Get-AppCategory() { [cmdletbinding()] $graphApiVersion = \u0026#34;Beta\u0026#34; $Resource = \u0026#34;deviceAppManagement/mobileAppCategories\u0026#34; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Adding App Categories # Sticking with mobileAppCategories section of Graph and using the POST /deviceAppManagement/mobileAppCategories to create new App Categories, we can push new App Categories to Microsoft Intune and all we need is the below function and a name of the category.\nFunction Add-AppCategory() { [cmdletbinding()] param ( $Name ) $graphApiVersion = \u0026#34;Beta\u0026#34; $Resource = \u0026#34;deviceAppManagement/mobileAppCategories\u0026#34; try { if ($Name -eq \u0026#34;\u0026#34; -or $null -eq $Name) { write-host \u0026#34;No name specified, please specify valid Name for the App Category...\u0026#34; -f Red break } else { $Output = New-Object -TypeName psobject $Output | Add-Member -MemberType NoteProperty -Name \u0026#34;@odata.type\u0026#34; -Value \u0026#34;#microsoft.graph.mobileAppCategory\u0026#34; $Output | Add-Member -MemberType NoteProperty \u0026#34;displayName\u0026#34; -Value $Name $JSON = $Output | ConvertTo-Json -Depth 3 Test-JSON -JSON $JSON $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Post -Body $JSON -ContentType \u0026#34;application/json\u0026#34; } } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Updating Mobile Apps # So we have a way to create new App Categories in Microsoft Intune, so we\u0026rsquo;re a third of the way there, we now need a way to get Mobile Apps, get the App Categories assigned to the Mobile Apps, and then add new App Categories. This all seemed more straightforward when I first started this.\nGetting Mobile Apps # Oh we do love Graph here don\u0026rsquo;t we\u0026hellip;more use of Graph and in particular GET /deviceAppManagement/mobileApps, we\u0026rsquo;ll use this to get existing Mobile Apps, be warned though, this resource type will pull back all apps, whether Client Apps or Mobile Application Managed Apps, so we\u0026rsquo;ll need to use some filtering further down the line.\nFunction Get-MobileApps() { [cmdletbinding()] $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#39;deviceAppManagement/mobileApps\u0026#39; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Getting Mobile App assigned App Categories # We will also need to get the App Categories assigned to each Mobile App, as I thought best we have an option to remove some categories as well as add them.\nFunction Get-MobileAppsCategory() { [cmdletbinding()] param ( $Id ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceAppManagement/mobileApps/$Id/categories\u0026#34; try { if ($Id -eq \u0026#39;\u0026#39; -or $null -eq $Id) { Write-Host \u0026#39;No Id specified, please specify valid Id for the Mobile App...\u0026#39; -f Red break } else { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } App Categories for Mobile Apps # Not to hammer the point home, but you could go through each Mobile App and assign the new categories, and if you truly hate yourself, feel free to do this manually. However, we should continue on this scripting path and finish the job we started.\nAssigning App Categories # More functions to play with, this time one to assign App Categories to a Mobile App, nothing special here but we\u0026rsquo;ll need to pass through the $Id of the Mobile App and the $CategoryId of the Category.\nOne little weird one here, need to through in a $ref at the end of the uri for the call to Graph, shout out to the Intune Support Team on YouTube for this bit of information.\nFunction Add-MobileAppCategory() { [cmdletbinding()] param ( $Id, $CategoryId ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceAppManagement/mobileApps/$Id/categories/`$ref\u0026#34; try { if ($Id -eq \u0026#39;\u0026#39; -or $null -eq $Id) { Write-Host \u0026#39;No Mobile App ID specified, please specify valid Id for the Mobile App ID...\u0026#39; -f Red break } elseif ($CategoryId -eq \u0026#39;\u0026#39; -or $null -eq $CategoryId) { Write-Host \u0026#39;No App Category ID specified, please specify valid ID for the App Category...\u0026#39; -f Red break } else { $value = \u0026#34;https://graph.microsoft.com/$graphApiVersion/deviceAppManagement/mobileAppCategories/$CategoryId\u0026#34; $Output = New-Object -TypeName psobject $Output | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.id\u0026#39; -Value $value $JSON = $Output | ConvertTo-Json -Depth 3 Test-JSON -JSON $JSON $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Post -Body $JSON -ContentType \u0026#39;application/json\u0026#39; } } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Removing Assigned App Categories # Last function for today, one to remove the App Category from a Mobile App\u0026hellip;we\u0026rsquo;ll use this one later on.\nFunction Remove-MobileAppCategory() { [cmdletbinding()] param ( $Id, $CategoryId ) $graphApiVersion = \u0026#39;Beta\u0026#39; $Resource = \u0026#34;deviceAppManagement/mobileApps/$Id/categories/$CategoryId/`$ref\u0026#34; try { if ($Id -eq \u0026#39;\u0026#39; -or $null -eq $Id) { Write-Host \u0026#39;No Mobile App ID specified, please specify valid Id for the Mobile App ID...\u0026#39; -f Red break } elseif ($CategoryId -eq \u0026#39;\u0026#39; -or $null -eq $CategoryId) { Write-Host \u0026#39;No App Category ID specified, please specify valid ID for the App Category...\u0026#39; -f Red break } else { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Delete } } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Repeatable Actions # The likelihood is that creation of App Categories is going to be a one-off task, but the assignment and removal of the categories might be a regular occurrence in your Microsoft Intune environment, so I thought we\u0026rsquo;d deal with four differing use cases:\nCreation of new App Categories: Upload a CSV file with the new categories in Creation of new App Categories and Assign the App Categories: still a CSV upload but follows on with assignment options Assign App Categories: plain assignment of categories to Mobile Apps Removal of Assign App Categories: Ronseal Options Everywhere # So we\u0026rsquo;ll use a simple prompt and choice option in the script to set the $setting variable, and use this to denote what actions we take.\nWrite-Host \u0026#39;********************************************************************************\u0026#39; Write-Host \u0026#39;**** Welcome to the Microsoft Intune App Category and Assignment Tool ****\u0026#39; -ForegroundColor Green Write-Host \u0026#39;**** This Script will add new app categories and assign them ****\u0026#39; -ForegroundColor Cyan Write-Host \u0026#39;********************************************************************************\u0026#39; Write-Host Write-Host \u0026#39; Please Choose one of the options below: \u0026#39; -ForegroundColor Yellow Write-Host Write-Host \u0026#39; (1) Upload a CSV of new App Categories...\u0026#39; -ForegroundColor Green Write-Host Write-Host \u0026#39; (2) Upload a CSV of new App Categories and assign App Categories to Apps...\u0026#39; -ForegroundColor Green Write-Host Write-Host \u0026#39; (3) Assign App Categories to Apps...\u0026#39; -ForegroundColor Green Write-Host Write-Host \u0026#39; (4) Remove Assigned App Categories from Apps...\u0026#39; -ForegroundColor Green Write-Host Write-Host \u0026#39; (E) EXIT SCRIPT \u0026#39; -ForegroundColor Red Write-Host $Choice_Number = \u0026#39;\u0026#39; $Choice_Number = Read-Host -Prompt \u0026#39;Based on which option you want to run, please type 1, 2 or E to exit the script, then hit enter \u0026#39; while ( !($Choice_Number -eq \u0026#39;1\u0026#39; -or $Choice_Number -eq \u0026#39;2\u0026#39; -or $Choice_Number -eq \u0026#39;3\u0026#39; -or $Choice_Number -eq \u0026#39;4\u0026#39; -or $Choice_Number -eq \u0026#39;E\u0026#39;)) { $Choice_Number = Read-Host -Prompt \u0026#39;Invalid Option, Based on which option you want to run, please type 1, 2, 3, 4 or E to exit the test, then click enter \u0026#39; } if ($Choice_Number -eq \u0026#39;E\u0026#39;) { Break } if ($Choice_Number -eq \u0026#39;1\u0026#39;) { $Setting = \u0026#39;Upload\u0026#39; } if ($Choice_Number -eq \u0026#39;2\u0026#39;) { $Setting = \u0026#39;Upload/Assign\u0026#39; } if ($Choice_Number -eq \u0026#39;3\u0026#39;) { $Setting = \u0026#39;Assign\u0026#39; } if ($Choice_Number -eq \u0026#39;4\u0026#39;) { $Setting = \u0026#39;Remove\u0026#39; } Handling the Options # Because we now have the variable to play with, we can use some wonderful if statements to deal with the options depending on what has been selected when running the script:\nUpload Assign Remove The below goes into more detail on how each option is handled by the script.\nUpload # This section will prompt for a CSV file containing new App Categories, make sure you\u0026rsquo;ve got a heading of \u0026lsquo;Name\u0026rsquo; in this file, otherwise things will be painful for you.\nName\rWeb Browsers\rMedia Players\rData Management Once uploaded the script will check for existing App Categories of the same name, safely ignore any it finds, and create new ones.\nif ($Setting -like \u0026#39;*Upload*\u0026#39;) { $CSVPath = Read-Host \u0026#39;Please provide the path to the CSV file containing a list of App Categories e.g. C:\\temp\\appcategories.csv\u0026#39; if (!(Test-Path \u0026#34;$CSVPath\u0026#34;)) { Write-Host \u0026#34;Import Path for CSV file doesn\u0026#39;t exist\u0026#34; -ForegroundColor Red Write-Host \u0026#34;Script can\u0026#39;t continue\u0026#34; -ForegroundColor Red Write-Host break } else { $AppCategories = Import-Csv -Path $CSVPath } $CurrentAppCategories = (Get-AppCategory).displayName foreach ($AppCategory in $AppCategories) { if ($AppCategory.Name -in $CurrentAppCategories) { Write-Host \u0026#39;App Category \u0026#39;$AppCategory.Name\u0026#39; already exists...\u0026#39; -ForegroundColor Yellow Write-Host } else { Write-Host \u0026#39;App Category will be created...\u0026#39; -ForegroundColor Yellow Write-Host try { Add-AppCategory -Name $AppCategory.Name | Out-Null Write-Host \u0026#39;App Category \u0026#39;$AppCategory.Name\u0026#39; created...\u0026#39; -ForegroundColor Green Write-Host } catch { Write-Host \u0026#39;App Category \u0026#39;$AppCategory.Name\u0026#39; not created...\u0026#39; -ForegroundColor Red Write-Host } } } } Assign # Whether you have uploaded new App Categories, or just want to use the existing ones, now is the time to assign them to the Mobile Apps, so we need a way for you to select not only the Mobile Apps but also the App Categories you want to assign to them. We\u0026rsquo;ve done this wis a simple Out-Gridview and a variable.\nif ($Setting -like \u0026#39;*Assign*\u0026#39;) { Write-Host \u0026#39;When prompted, wait for all Mobile Apps to load, then select the App or Apps you want to assign a Category. Use The ENTER Key or Mouse \\ OK Button.\u0026#39; -ForegroundColor Yellow Write-Host Start-Sleep -Seconds $sleep $MobileApps = @(Get-MobileApps | Where-Object { (!($_.\u0026#39;@odata.type\u0026#39;).Contains(\u0026#39;managed\u0026#39;)) -and (!($_.\u0026#39;@odata.type\u0026#39;).Contains(\u0026#39;android\u0026#39;)) } | Select-Object \u0026#39;@odata.type\u0026#39;, displayName, publisher, id | Out-GridView -PassThru -Title \u0026#39;Select Mobile Apps...\u0026#39;) Write-Host \u0026#39;Wait for all App Categories to load, then select the Category or Categories you want to assign to an Application. Use The ENTER Key or Mouse \\ OK Button.\u0026#39; -ForegroundColor Yellow Write-Host Start-Sleep -Seconds $sleep $AddAppCategories = @(Get-AppCategory | Select-Object displayName, id | Out-GridView -PassThru -Title \u0026#39;Select Apps Categories...\u0026#39;) Write-Host \u0026#39;Starting assignment of Categories to Mobile Apps\u0026#39; -ForegroundColor Yellow Write-Host Write-Warning \u0026#39;Please confirm you are happy to continue assigning categories to applications\u0026#39; -WarningAction Inquire foreach ($MobileApp in $MobileApps) { $AssignedAppCategories = Get-MobileAppsCategory -Id $MobileApp.id foreach ($AddAppCategory in $AddAppCategories) { if ($AddAppCategory.displayName -in $AssignedAppCategories.displayName) { Write-Host \u0026#39;\u0026#39;$AddAppCategory.displayName\u0026#39; category already assigned to \u0026#39;$MobileApp.displayName\u0026#39;\u0026#39; -ForegroundColor Yellow Write-Host } else { Write-Host \u0026#39;Adding \u0026#39;$AddAppCategory.displayName\u0026#39; category to \u0026#39;$MobileApp.displayName\u0026#39;...\u0026#39; -ForegroundColor Yellow try { Add-MobileAppCategory -Id $MobileApp.id -CategoryId $AddAppCategory.id Write-Host \u0026#39;Added \u0026#39;$AddAppCategory.displayName\u0026#39; category to \u0026#39;$MobileApp.displayName\u0026#39;...\u0026#39; -ForegroundColor Green Write-Host } catch { Write-Host \u0026#39;Unable to add \u0026#39;$AddAppCategory.displayName\u0026#39; category to \u0026#39;$MobileApp.displayName\u0026#39;...\u0026#39; -ForegroundColor Red Write-Host } } } } } Remove # This one is a bit blunt if I\u0026rsquo;m honest, it prompts you to select the Mobile App/s you want to remove App Categories from, and then removes all of them, bit brutal, but can you be bothered selecting \u0026lsquo;OK\u0026rsquo; for each App Category you want removing? Didn\u0026rsquo;t think so.\nif ($setting -eq \u0026#39;Remove\u0026#39;) { Write-Host \u0026#39;When prompted, wait for all Mobile Apps to load, then select the App or Apps you want to remove categories from. Use The ENTER Key or Mouse \\ OK Button.\u0026#39; -ForegroundColor Yellow Write-Host Start-Sleep -Seconds $sleep $MobileApps = @(Get-MobileApps | Where-Object { (!($_.\u0026#39;@odata.type\u0026#39;).Contains(\u0026#39;managed\u0026#39;)) -and (!($_.\u0026#39;@odata.type\u0026#39;).Contains(\u0026#39;android\u0026#39;)) } | Select-Object \u0026#39;@odata.type\u0026#39;, displayName, publisher, id | Out-GridView -PassThru -Title \u0026#39;Select Mobile Apps...\u0026#39;) foreach ($MobileApp in $MobileApps) { $AssignedAppCategories = Get-MobileAppsCategory -Id $MobileApp.id If (!$AssignedAppCategories) { Write-Host \u0026#39;App \u0026#39;$MobileApp.displayName\u0026#39; has no assigned App Categories...\u0026#39; -ForegroundColor Yellow Write-Host } Else { Write-Host \u0026#39;The following App Categories for App \u0026#39;$MobileApp.displayName\u0026#39; will be removed...\u0026#39; -ForegroundColor Yellow $AssignedAppCategories.displayName Write-Host Start-Sleep -Seconds $sleep foreach ($AssignedAppCategory in $AssignedAppCategories) { Try { Remove-MobileAppCategory -Id $MobileApp.id -CategoryId $AssignedAppCategory.id Write-Host \u0026#39;App Category \u0026#39;$AssignedAppCategory.displayName\u0026#39; removed from App \u0026#39;$MobileApp.displayName\u0026#39;\u0026#39; -ForegroundColor Green Write-Host } Catch { Write-Host \u0026#39;Unable to remove App Category \u0026#39;$AssignedAppCategory.displayName\u0026#39; from App \u0026#39;$MobileApp.displayName\u0026#39;\u0026#39; -ForegroundColor Red Write-Host } } } } } Running the Script # As we\u0026rsquo;ve gone through all of this just to assign some App Categories, I guess now would be the time to provide a link to the script, and show you what it does for each of the options.\nCreating New App Categories # Running the script and selecting \u0026lsquo;Option 1\u0026rsquo;: The new App Categories available: Assigning the App Categories # Running the script and selecting \u0026lsquo;Option 3\u0026rsquo;: Selecting the Mobile Apps: Selecting the App Categories: Confirming the assignment of the categories: The new App Categories on the Edge Mobile App: Removing the Assigned App Categories # Running the script and selecting \u0026lsquo;Option 4\u0026rsquo;: Selecting the Mobile Apps: App Categories being removed: No more App Categories on the Edge Mobile App: Summary # I\u0026rsquo;m impressed that you\u0026rsquo;ve gotten to the bottom of this page, as there\u0026rsquo;s way too many functions and screenshots to make the pay off worthwhile, however, what we do have here is a script that can be used regularly to update App Categories, assign them to Mobile Apps, and if you ever have a truly awful day, remove the categories from the apps.\nAll this to make an end-users life a bit easier in the Company Portal. I think I need to re-evaluate the time I spend writing scripts for user experience benefits.\n","date":"10 September 2022","permalink":"/posts/creating-assigning-app-categories/","section":"Blog","summary":"What about assigning App Categories, do you want to be manually updating hundreds of Apps with categories? Let\u0026rsquo;s make one laborious task, less laborious, with a hacky PowerShell script.","title":"Creating and Assigning App Categories the Smart Way"},{"content":"Introduction # What happens if you\u0026rsquo;ve allowed Windows, iOS, Android, and macOS devices to enrol into Microsoft Microsoft Intune in all kinds of ways, and now you\u0026rsquo;re in a situation where devices that should be marked as corporate are marked as personal or unknown?\nThis is more of a common situation than you think, with the need to get remote devices managed in a timely fashion, many organisations used User Driven enrolment methods, such as via the Company Portal, to enrol devices into Microsoft Intune, and without Corporate Device Identifiers, or for the case of Windows no support for them, these devices get enrolled as personal devices.\nCorporate Device Identifiers # Corporate Device Identifiers are useful for tagging devices as corporate for devices that have not yet enrolled into Microsoft Intune, but what about those that have, and what about the poor devices that just don\u0026rsquo;t have a place in the supported corporate device identifier world:\nWe need to find a way to update devices we know are corporate owned and change the ownership type, sadly there isn\u0026rsquo;t a native way of doing this using Bulk Device Actions in Microsoft Intune, so Graph API and PowerShell it is.\nDevice Ownership Change # We\u0026rsquo;re going to leverage Graph API to update devices that we know should be marked as corporate, to corporate ownership in Microsoft Intune. You could manually change this within each device properties page, but if you\u0026rsquo;ve got 100\u0026rsquo;s of devices, this isn\u0026rsquo;t a task I\u0026rsquo;d be willing to do.\nWe can attack this problem in a couple of ways, three if you count manually changing device ownership, but we\u0026rsquo;ll stick with:\nSerial numbers of devices we know are corporate Groups of devices that we know are corporate Now we have options, we\u0026rsquo;d better write something to make this change for these devices.\nDevice Lists # First off is putting together the list of devices you know are corporate, now I\u0026rsquo;m hoping you have an Asset Register that contains all the serial numbers of your owned devices, so you could use this to create a CSV file, make sure the serial numbers are under the heading \u0026lsquo;SerialNumber\u0026rsquo; as we\u0026rsquo;ll need this later.\nDeviceName,SerialNumber ENB-564d71,VMware-564d710031a992c6-ca795244c03a8322 If you don\u0026rsquo;t have these serials to hand, you could probably export all data from the Microsoft Intune All Devices blade, and then filter the data to show devices with unknown or personal ownership and review them. Good luck.\nFor the group, let\u0026rsquo;s make use of Azure AD Dynamic Groups,and find a suitable way to use the query to capture the corporate devices. This could be display name, or device make and model, or device ownership not equals corporate, or a combination of all three, really you can be creative here to fit your environment.\n(device.displayName -startsWith \u0026#34;ENB-\u0026#34;) (device.deviceManufacturer -eq \u0026#34;Dell Inc.\u0026#34;) and (device.deviceModel -startsWith \u0026#34;XPS\u0026#34;) (device.deviceOSType -eq \u0026#34;Windows\u0026#34;) and (device.deviceOwnership -ne \u0026#34;Company\u0026#34;) (device.deviceOSType -eq \u0026#34;Windows\u0026#34;) and (device.deviceOwnership -ne \u0026#34;Company\u0026#34;) and (device.deviceManufacturer -eq \u0026#34;Dell Inc.\u0026#34;) and (device.deviceModel -startsWith \u0026#34;XPS\u0026#34;) and (device.displayName -startsWith \u0026#34;ENB-\u0026#34;) Managed Devices # With our list of devices, either CSV or Azure AD Group, we will need to use this data to get the Managed Device object in Microsoft Intune.\nTo do this we will need to authenticate to Graph, and as you\u0026rsquo;ve seen this one a lot on this blog already in previous posts, I won\u0026rsquo;t put the functions here, but we\u0026rsquo;re using the PowerShell Authentication Function from the Intune PowerShell Samples GitHub repo to allow us to connect to Graph.\nOnce connected, we can now look at not only getting devices, but updating the device object, time for a function or two.\nGetting Managed Devices # First off let\u0026rsquo;s use Graph to get all Managed Devices, we can use a Where-Object clause late to fine tune which device we\u0026rsquo;re getting the details of later on.\nFunction Get-ManagedDevices() { param ( [switch]$IncludeEAS, [switch]$ExcludeMDM ) $graphApiVersion = \u0026#34;beta\u0026#34; $Resource = \u0026#34;deviceManagement/managedDevices\u0026#34; try { $Count_Params = 0 if ($IncludeEAS.IsPresent) { $Count_Params++ } if ($ExcludeMDM.IsPresent) { $Count_Params++ } if ($Count_Params -gt 1) { write-warning \u0026#34;Multiple parameters set, specify a single parameter -IncludeEAS, -ExcludeMDM or no parameter against the function\u0026#34; Write-Host break } elseif ($IncludeEAS) { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource\u0026#34; } elseif ($ExcludeMDM) { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource`?`$filter=managementAgent eq \u0026#39;eas\u0026#39;\u0026#34; } else { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource`?`$filter=managementAgent eq \u0026#39;mdm\u0026#39; and managementAgent eq \u0026#39;easmdm\u0026#39;\u0026#34; } (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Set Managed Device Ownership # Using the \u0026lsquo;patch\u0026rsquo; functionality in the Graph API, we can change an existing Managed Device object in Microsoft Intune, in this case, I was lazy and just wrote the function for device ownership, but the \u0026lsquo;patch\u0026rsquo; option would allow you to change many settings.\nThis function only needs a couple of parameters, id and ownertype.\nFunction Set-ManagedDeviceOwnership() { param ( $id, $ownertype ) $graphApiVersion = \u0026#34;Beta\u0026#34; $Resource = \u0026#34;deviceManagement/managedDevices\u0026#34; try { if ($id -eq \u0026#34;\u0026#34; -or $null -eq $id) { write-host \u0026#34;No Device id specified, please provide a device id...\u0026#34; -f Red break } if ($ownerType -eq \u0026#34;\u0026#34; -or $null -eq $ownerType) { write-host \u0026#34;No ownerType parameter specified, please provide an ownerType. Supported value personal or company...\u0026#34; -f Red Write-Host break } $Output = New-Object -TypeName psobject $Output | Add-Member -MemberType NoteProperty -Name \u0026#39;ownerType\u0026#39; -Value $ownerType $JSON = $Output | ConvertTo-Json -Depth 3 $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource/$ID\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Patch -Body $Json -ContentType \u0026#34;application/json\u0026#34; } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Importing the Devices # We have a way to get a Managed Device and change the ownership, let\u0026rsquo;s put together a way to import devices via the two previously mentioned methods, so that we can fix whatever mistakes we got ourselves into.\nSo we\u0026rsquo;ve got either a list of devices or a group of devices we want to convert, we now need to get the Microsoft Intune device ID for each of these devices, we\u0026rsquo;ll need to do this in two separate ways, one for serial number in the CSV file and one for the Azure AD device ID attribute for the members of the group.\nSerial Number # This is the easy one, we can use the Get-ManagedDevice function we created and use the where-object clause to find the exact device we want, this is the benefit of using serial numbers.\nIf ($Device.SerialNumber) { try { $ManagedDevice = Get-ManagedDevices | Where-Object { $_.serialnumber -eq $Device.SerialNumber } Write-Host \u0026#34;Found \u0026#34;$ManagedDevice.DeviceName\u0026#34; with ownership \u0026#34;$ManagedDevice.ownerType\u0026#34;\u0026#34; -ForegroundColor Cyan Write-Host } catch { Write-Host \u0026#34;Unable to find device with serial number \u0026#34;$Device.SerialNumber\u0026#34;\u0026#34; -ForegroundColor Yellow Write-Host } } We now have the Managed Device detail, and importantly the Managed Device ID we need to change the ownership.\nAzure AD Device ID # This one isn\u0026rsquo;t as straight forward, as it\u0026rsquo;s a three step process, we need to:\nGet the ID of the group based on the name Get the members of the group and their Azure AD Device ID Get the Managed Device details I could have used the AzureAD PowerShell module for this, but I didn\u0026rsquo;t want to authenticate twice, once to Graph and then again to Azure Active Directory\u0026hellip;so I created a couple of functions and the script section below to get the required Managed Device ID.\n$Group = Read-host \u0026#34;Please provide the name of the group containing members you want to convert\u0026#34; try { $id = (Get-DeviceGroup -GroupName \u0026#34;$Group\u0026#34;).id $Devices = Get-DeviceGroupMembers -id $id } catch { Write-Host \u0026#34;Unable to find the device group\u0026#34; -ForegroundColor Red Write-Host \u0026#34;Script can\u0026#39;t continue\u0026#34; -ForegroundColor Red Write-Host break } ... Else { try { $ManagedDevice = Get-ManagedDevices | Where-Object { $_.azureADDeviceId -eq $Device.deviceId } Write-Host \u0026#34;Found \u0026#34;$ManagedDevice.DeviceName\u0026#34; with ownership \u0026#34;$ManagedDevice.ownerType\u0026#34;\u0026#34; -ForegroundColor Cyan } catch { Write-Host \u0026#34;Unable to find device with name \u0026#34;$Device.DisplayName\u0026#34;\u0026#34; -ForegroundColor Yellow } } Getting the Group # Using the GET /groups resource in Graph and some filtering, we can get the ID of the group provided from the script.\nFunction Get-DeviceGroup() { param ( [string]$GroupName ) $graphApiVersion = \u0026#34;v1.0\u0026#34; $Resource = \u0026#34;groups\u0026#34; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource`?`$filter=displayName eq \u0026#39;$GroupName\u0026#39;\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Getting the Group Membership # Still using the GET /groups/{id}/members resource in Graph, but this time using the option to list the members of the group.\nFunction Get-DeviceGroupMembers() { param ( [string]$id ) $graphApiVersion = \u0026#34;v1.0\u0026#34; $Resource = \u0026#34;groups\u0026#34; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$Resource/$id/members\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Running the Script # Putting this all together gives us a way to get the required unique identifier of the Managed Device and change the ownership to corporate, all using a handful of functions.\nRunning the script, after authentication, will give you a prompt for options, as we all like a choice:\nUse a CSV file; where you\u0026rsquo;ll be prompted to provide a path to the CSV file containing device serial numbers An Azure AD group; where you\u0026rsquo;ll be prompted to provide a name of an Azure AD group that contains the devices you know are corporate Panic and exit the script After this, the script will just do it\u0026rsquo;s thing and go and get each device in either the CSV or the group, change the ownership, and then tell you about it:\nYou can check the results for yourself in the Microsoft Intune portal:\nTesting the Script # I haven\u0026rsquo;t put an option to prompt you to continue, and definitely no \u0026lsquo;whatif\u0026rsquo; option, so I\u0026rsquo;d strongly recommend testing this with a small number of devices, whether this be via CSV or an Assigned Azure AD device group instead of a Dynamic one.\nDon\u0026rsquo;t worry though, there is logic in the script to catch errors for the following:\nIf the group can\u0026rsquo;t be found in Azure AD If the group member can\u0026rsquo;t be found in Microsoft Intune If the serial number can\u0026rsquo;t be found in Microsoft Intune If the change to ownership fails If any of the calls to Graph API fail Summary # Before you run this against your environment, just go and check your Tenant customisation settings, mainly around whether iOS/iPadOS and Android devices receive push notifications when the device ownership state changes, you may or may not want to disable this feature.\nRealistically you shouldn\u0026rsquo;t need to use this script regularly, it\u0026rsquo;s really designed to be a one-shot silver bullet approach to resolving this particular issue, you should be using the enterprise enrolment methods for devices within Microsoft Intune, especially for Windows devices.\n","date":"8 August 2022","permalink":"/posts/updating-enrolled-device-ownership/","section":"Blog","summary":"What happens if you\u0026rsquo;ve allowed Windows, iOS, Android, and macOS devices to enrol into Microsoft Microsoft Intune in all kinds of ways, and now you\u0026rsquo;re in a situation where devices that should be marked as corporate are marked as personal or unknown?","title":"Updating Enrolled Device Ownership Status"},{"content":"","date":"28 July 2022","permalink":"/tags/collections/","section":"Tags","summary":"","title":"Collections"},{"content":"Introduction # You may be using Direct Membership Rules in your Microsoft Configuration Manager environment, but should you really for critical production collections?\nNo is the answer, there I said it. Mainly because they require actual effort and overhead to maintain, and secondly because there have been times where these memberships just plain disappear, for many different reasons, but primarily if the ConfigMgr Client is reinstalled on the device.\nSo what do we do? \u0026lt;spoiler\u0026gt; Aggressive PowerShell scripts obviously. \u0026lt;/spoiler\u0026gt;\nThe Approach # We\u0026rsquo;ll need to connect to the Configuration Manager PowerShell module, which is easy enough from the Primary Site server, then carry out the following actions:\nGet the Device Collections with Direct Members Capture the Direct Members Create a new Query Membership Rule with the members Remove the existing Direct Members Logging? So let\u0026rsquo;s get at it\u0026hellip;\nConnecting via PowerShell # From the Configuration Manager server we can leverage the PowerShell Module, import it and then connect to the PSDrive where we get to run all the Configuration Manager commands\nImport-module ($Env:SMS_ADMIN_UI_PATH.Substring(0, $Env:SMS_ADMIN_UI_PATH.Length - 5) + \u0026#39;\\ConfigurationManager.psd1\u0026#39;) $SiteCode = Get-PSDrive -PSProvider CMSITE Set-location $SiteCode\u0026#34;:\u0026#34; Getting the Collections # I thought I\u0026rsquo;d be kind and give a couple of options to the Collection gathering, attack all of the Device Collections or, which is probably more sensible, bring up a list of collections to work with.\nWe\u0026rsquo;re doing this through a selection option at the start of the script and using Get-CMDeviceCollection:\nif ($Choice_Number -eq \u0026#39;1\u0026#39;) { Write-Host \u0026#34;Getting Device Collections with Direct Membership Rules...\u0026#34; -ForegroundColor Yellow $Collections = @(Get-CMDeviceCollection | Where-Object { $_.CollectionRules -like \u0026#39;*SMS_CollectionRuleDirect*\u0026#39; } | Select-Object Name, CollectionID, CollectionRules | Out-GridView -PassThru -Title \u0026#39;Wait for all Collections to load, then select the Device Collections you want to convert. Use The ENTER Key or Mouse \\ OK Button.\u0026#39;) } if ($Choice_Number -eq \u0026#39;2\u0026#39;) { Write-Host \u0026#34;Getting Device Collections with Direct Membership Rules...\u0026#34; -ForegroundColor Yellow $Collections = Get-CMDeviceCollection | Where-Object { $_.CollectionRules -like \u0026#39;*SMS_CollectionRuleDirect*\u0026#39; } | Select-Object Name, CollectionID, CollectionRules } We need to now identify whether these collection have Direct Members, so for each collection we can look at the CollectionRules attribute, and see if it contains SMS_CollectionRuleDirect:\nforeach ($Collection in $Collections) { if ($Collection.CollectionRules -like \u0026#34;*SMS_CollectionRuleDirect*\u0026#34;) { } } Now we know this collection has Direct Members, let\u0026rsquo;s get them using Get-CMDeviceCollectionDirectMembershipRule:\n$DirectMembers = Get-CMDeviceCollectionDirectMembershipRule -CollectionName $Collection.Name Cool, easy part done.\nBuilding the Query # An easy replacement for the Direct Membership Rule is to use a List of Values Query based on System Name, so we\u0026rsquo;re going to use that, we\u0026rsquo;re going to use this as our basis for the new query once we\u0026rsquo;ve captured the Direct Members in a suitable format:\nCCM Client Computer Name select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_SYSTEM on SMS_G_System_SYSTEM.ResourceId = SMS_R_System.ResourceId where SMS_G_System_SYSTEM.Name in (\u0026#34;COMPUTER1\u0026#34;, \u0026#34;COMPUTER2\u0026#34;) AD Client Computer Name select SMS_R_System.ResourceId, SMS_R_System.ResourceType, SMS_R_System.Name, SMS_R_System.SMSUniqueIdentifier, SMS_R_System.ResourceDomainORWorkgroup, SMS_R_System.Client from SMS_R_System where SMS_R_System.Name in (\u0026#34;COMPUTER1\u0026#34;, \u0026#34;COMPUTER2\u0026#34;) We also need to get the names of the Direct Members, throw them into an Array as part of the foreach loop, then squish the Array to a String and combine the template query and the members:\n$RuleName = \u0026#34;Direct Membership Replacement Query\u0026#34; $QueryPart = \u0026#34;select SMS_R_System.ResourceId, SMS_R_System.ResourceType, SMS_R_System.Name, SMS_R_System.SMSUniqueIdentifier, SMS_R_System.ResourceDomainORWorkgroup, SMS_R_System.Client from SMS_R_System where SMS_R_System.Name in (\u0026#34; if ($Collection.CollectionRules -like \u0026#34;*SMS_CollectionRuleDirect*\u0026#34;) { $DirectMembers = Get-CMDeviceCollectionDirectMembershipRule -CollectionName $Collection.Name $MembersArray = @() foreach ($DirectMember in $DirectMembers) { $MembersArray += $DirectMember.RuleName } $Members = \u0026#39;\u0026#34;{0}\u0026#34;\u0026#39; -f ($MembersArray -join \u0026#39;\u0026#34;,\u0026#34;\u0026#39;) $QueryExpression = $QueryPart + $Members + \u0026#34;)\u0026#34; } This gives us the complete query string which we can use later on to create the Query Membership Rule.\nUpdating the Rules # Using Add-CMDeviceCollectionQueryMembershipRule we can create the new rule in the Collection using the variables we created earlier:\nAdd-CMDeviceCollectionQueryMembershipRule -CollectionName $Collection.Name -QueryExpression $QueryExpression -RuleName $RuleName And after successfully creating the rule we can use Remove-CMDeviceCollectionDirectMembershipRule to loop through the existing Direct Members and remove them:\nforeach ($DirectMember in $DirectMembers) { Try { Remove-CMDeviceCollectionDirectMembershipRule -CollectionName $Collection.Name -ResourceID $DirectMember.ResourceID -Force } Catch { } } Running the Script # Now we have all the bits we needed in place (cough logging cough), we can launch the script and use the option to select a Collection first as a test before we run it across the entire environment.\nLet\u0026rsquo;s run it on a test collection we know has direct members: Run the script from an Elevated PowerShell prompt on your Primary Site Server:\nSet-CollectionDirectToQueryMembership.ps1 Oh the Choices # Doing so will prompt you with options, oooo exciting, here we\u0026rsquo;ll select option 1: Doing so will open a grid view of the collections in your Configuration Manager environment, this may take a while to load, and you should wait for them to load before selecting and confirming your Collections: Search for the Collection you want to update and select \u0026lsquo;OK\u0026rsquo;: Converting the Rules # Now the magic happens, including a nice little output table of the results of the conversion: The Results Speak for Themselves # Now the script has completed, we can go and check on the results on the Device Collection itself, look no Direct Members any more: With the new Query in place: Summary # With this small but powerful script, you can remove all Direct Membership rules and use the more sustainable (and less likely to cause you problems), Query Rule on either Collections you know have Direct Members, or if you\u0026rsquo;re feeling brave, your entire set of Device Collections.\nThis saves you having to manually create the Rules, or even the collections, which would mean re-deploying configuration, updates, applications etc. to a new Collection.\nWhat a time saver.\n","date":"28 July 2022","permalink":"/posts/converting-direct-member-collections/","section":"Blog","summary":"You may be using Direct Membership Rules in your Microsoft Configuration Manager environment, but should you really for critical production collections?","title":"Converting Configuration Manager Direct Membership Collections"},{"content":"","date":"10 July 2022","permalink":"/tags/bios/","section":"Tags","summary":"","title":"BIOS"},{"content":"Introduction # What if you\u0026rsquo;ve only got Microsoft Intune to configure your Dell BIOS settings and not the glory that is Configuration Manager? How much do you like PowerShell, Win32 Apps and passwords in plain text?\nWell you\u0026rsquo;re in luck, I\u0026rsquo;ve thrown together something that can help you out based on a need to ensure that Secure Boot is configured for Dell laptops when it was discovered via the Windows health attestation report that around 80% of the Windows devices had it turned off.\n(Don\u0026rsquo;t worry, I checked that the devices had GPT partitions before I just launched a PowerShell script at them.)\nDell PowerShell Provider # There are several posts kicking around the internet about using Microsoft Intune to not only change or set Dell BIOS passwords, but also using CSV files to configure BIOS settings using the Dell Command | PowerShell Provider, the below are the ones I\u0026rsquo;ve found and borrowed from:\nsystanddeploy.com ccmexec.com configjon.com These posts detail ways to use the Dell PowerShell Provider to set the BIOS configurations and an Admin BIOS Password on Dell devices, so I\u0026rsquo;m only going to focus on how I\u0026rsquo;ve taken this, run with it, and made it a little easier to handle in Microsoft Intune.\nSetting up the Module # As we\u0026rsquo;re going to be packaging up the PowerShell script as a Win32App, we\u0026rsquo;ll need to ensure that not only is the script available, but also the PowerShell module (and some rogue .dll files too for some reason).\nFrom an elevated PowerShell window run the below command to save the PowerShell module to a new folder:\nSave-Module -Name DellBIOSProvider -Path C:\\Temp\\Set-DellBIOS\\ The version at the time of writing of this module is 2.6.0, which has a reliance on some of the .dll files installed from the Visual C++ Re-distributables:\nYou can just copy the below required files from a machine with the Visual C++ Redistributables already installed and paste them in the DellBiosProvider\\2.6.0 folder we created saving the PowerShell module, this sounds better than packaging and pushing out more software:\nmsvcp100.dll msvcr100.dll msvcp140.dll vcruntime140.dll vcruntime140_1.dll Installing the Module # This is the bit where we use some of that there logic to check if the module is already installed on a machine, and if so, to bin it off and use the version packaged in the Win32App, then import the module.\n$ScriptPath = (Get-Location).Path if (Test-Path -Path \u0026#34;$env:ProgramFiles\\WindowsPowerShell\\Modules\\DellBIOSProvider\u0026#34;) { Write-Output \u0026#34;DellBIOSProvider folder already exists @ $env:ProgramFiles\\WindowsPowerShell\\Modules\\DellBIOSProvider.\u0026#34; Write-Output \u0026#34;Deleting the folder...\u0026#34; Remove-Item -Path \u0026#34;$env:ProgramFiles\\WindowsPowerShell\\Modules\\DellBIOSProvider\u0026#34; -Recurse -Force } Write-Output \u0026#34;Copying DellBIOSProvider module to: $env:ProgramFiles\\WindowsPowerShell\\Modules\\DellBIOSProvider\u0026#34; Copy-Item -Path \u0026#34;$ScriptPath\\DellBIOSProvider\\\u0026#34; -Destination \u0026#34;$env:ProgramFiles\\WindowsPowerShell\\Modules\\\u0026#34; -Recurse -Force try { Import-Module \u0026#34;DellBIOSProvider\u0026#34; -Force -Verbose -ErrorAction Stop Write-Output \u0026#34;Importing the Dell BIOS Provider module\u0026#34; } catch { Write-Output \u0026#34;Error importing module: $_\u0026#34; exit 1 } Configuring the BIOS # With the module installed, we\u0026rsquo;d better take a look on a test device what the BIOS settings and values actually are, so after importing the module run the below command to get all the BIOS setting details:\nGet-ChildItem -path DellSmbios:\\ | ForEach-Object { Get-ChildItem -path @(\u0026#34;DellSmbios:\\\u0026#34; + $_.Category) | select-object attribute, currentvalue, possiblevalues, PSChildName } Format-List This will dump all the existing BIOS settings, and importantly their supported values, such as:\nAttribute : BootList CurrentValue : LEGACY PossibleValues : {Legacy, Uefi} PSChildName : BootSequence Attribute : SecureBoot CurrentValue : Disabled PossibleValues : {Disabled, Enabled} PSChildName : SecureBoot So now we know what Setting and their support Values are\u0026hellip;\nBIOS Settings # Other scripts use a CSV file that contain the BIOS settings you wish to configure, but this is a little clunky as you\u0026rsquo;d need to update and package the Win32App each time, so let\u0026rsquo;s use PowerShell array variables to get these settings:\n[Parameter(Mandatory=$true,Position=2)][string[]]$Settings=@(), [Parameter(Mandatory=$true,Position=3)][string[]]$Values=@() Now that we have these parameters, we can pass through both the setting and the value to the script:\n./Set-BIOSSettings.ps1 -Settings BootList,SecureBoot -Values Uefi,Enabled With these arrays in place, we need to squish them together into a new array in order to query them later in the script:\n[int]$max = $Settings.count $NewBIOSSettings = for ($i = 0; $i -lt $max; $i++) { [PSCustomObject]@{ Setting = $Settings[$i] Value = $Values[$i] } } We end up with a $NewBIOSSettings array variable containing the settings and their values:\nSetting Value ------- ----- BootList Uefi SecureBoot Enabled Making the Changes # Now we have the settings and values, as well as the PowerShell module, we can loop through each setting and apply it to the device. We\u0026rsquo;ve got a couple of options here, whether the device has a BIOS Admin Password set or otherwise.\n$AdminPassSet = (Get-Item -Path DellSmbios:\\Security\\IsAdminPasswordSet).CurrentValue $BIOSSettings = get-childitem -path DellSmbios:\\ | ForEach-Object { get-childitem -path @(\u0026#34;DellSmbios:\\\u0026#34; + $_.Category) | select-object attribute, currentvalue, possiblevalues, PSChildName } foreach ($NewBIOSSetting in $NewBIOSSettings) { $NewItemSetting = $NewBIOSSetting.Setting $NewItemValue = $NewBIOSSetting.Value Write-Output \u0026#34;Changing: $NewItemSetting \u0026gt; $NewItemValue\u0026#34; foreach ($BIOSSetting in $BIOSSettings | Where-Object { $_.attribute -eq $NewItemSetting }) { $SettingAttribute = $BIOSSetting.attribute $SettingCategory = $BIOSSetting.PSChildName If (($AdminPassSet -eq $true)) { Try { Set-Item -Path Dellsmbios:\\$SettingCategory\\$SettingAttribute -Value $NewItemValue -Password $Password Write-Output \u0026#34;New value for $SettingAttribute is $NewItemValue\u0026#34; New-ItemProperty -Path \u0026#34;$DetectionRegPath\u0026#34; -Name \u0026#34;$SettingAttribute\u0026#34; -Value \u0026#34;$NewItemValue\u0026#34; -Force | Out-Null } Catch { Write-Output \u0026#34;Cannot change setting $SettingAttribute (Return code $_)\u0026#34; } } Else { Try { Set-Item -Path Dellsmbios:\\$SettingCategory\\$SettingAttribute -Value $NewItemValue Write-Output \u0026#34;New value for $SettingAttribute is $NewItemValue\u0026#34; New-ItemProperty -Path \u0026#34;$DetectionRegPath\u0026#34; -Name \u0026#34;$SettingAttribute\u0026#34; -Value \u0026#34;$NewItemValue\u0026#34; -Force | Out-Null } Catch { Write-Output\u0026#34;Cannot change setting $Attribute (Return code $_)\u0026#34; } } } } App Deployment # Detection Methods # We could do with a method to detect whether they have been set successfully. We can use the detection method functionality of the Win32App, and in particular the registry detection method, so using the script we can set registry values using PowerShell and query them from Microsoft Intune.\nWe will create a new Registry Key, and then for each BIOS setting we configure, can create new registry values with the name of the setting and the value they have been configured to, i.e. \u0026lsquo;SecureBoot\u0026rsquo; and \u0026lsquo;Enabled\u0026rsquo;.\n$DetectionRegPath = \u0026#34;HKLM:\\SOFTWARE\\IntuneHelper\\DellBIOSProvider\u0026#34; New-ItemProperty -Path \u0026#34;$DetectionRegPath\u0026#34; -Name \u0026#34;$SettingAttribute\u0026#34; -Value \u0026#34;$NewItemValue\u0026#34; -Force | Out-Null App Packaging # Now that we have the whole script, which you can download along with the PowerShell Module and dll files (if you cba to do it yourself), we need to wrap this content up using the Microsoft Win32 Content Prep Tool.\nDownload the tool and dump it somewhere useful on your machine, launch a Command Prompt and in four simple steps you\u0026rsquo;ll have a Win32App ready for Microsoft Intune:\nFrom the path of where the tool exists, run the tool specifying the:\nSource Folder PowerShell script (including extension) Output folder Whether you want to create a catalog (you don\u0026rsquo;t) Now that you\u0026rsquo;ve got the Application, time to upload it to Microsoft Intune and configure some settings.\nApp Installation # Navigate to the Windows Apps section of Microsoft Intune and time to create a new app, making sure you select \u0026lsquo;Windows app (Win32)\u0026rsquo; as the App type.\nAfter uploading the .intunewin file make sure to use sysnative in the path of the install command, we also need to pass through the variables for the Settings and Values as well as Password for the BIOS Admin password:\nC:\\Windows\\Sysnative\\WindowsPowerShell\\v1.0\\powershell.exe -noprofile -executionpolicy Bypass -file .\\Set-DellBIOSSettings.ps1 -Password S3CurePW0RD -Settings BootList,SecureBoot -Values Uefi,Enabled Now I know what you\u0026rsquo;re saying, \u0026ldquo;Eurrggh password is in plain text, bad, not secure, naughty\u0026rdquo;, well you\u0026rsquo;re not wrong, but then you really should be using Role-Based Access Control to protect your Microsoft Intune environment, and allowing only privileged users to access it, so maybe it\u0026rsquo;s you that\u0026rsquo;s got the issue this time.\nAlso, I didn\u0026rsquo;t write an uninstall script, so just use the same command line for this, unless you fancy writing something yourself.\nApp Requirements # Make sure you select the correct architecture for your deployment, this time it\u0026rsquo;s x64 as well as the Minimum Operating System based on the Dell BIOS Provider requirements or your own device estate settings.\nApp Detection Methods # As we\u0026rsquo;ve taken all that time to create something to use for a detection method in the PowerShell script itself, we should probably reference it here.\nNow these detections are going to be based on what Settings and Values you\u0026rsquo;re configuring, for this instance it\u0026rsquo;s BootList and SecureBoot, so let\u0026rsquo;s query them using the below settings:\nBootList Key path: HKLM\\SOFTWARE\\IntuneHelper\\DellBIOSProvider Value name: BootList Detection method: String comparison Operator: Equals Value: Uefi SecureBoot Key path: HKLM\\SOFTWARE\\IntuneHelper\\DellBIOSProvider Value name: SecureBoot Detection method: String comparison Operator: Equals Value: Enabled Complete the wizard as no other settings are required and deploy this App to a test device group.\nApp Monitoring # We were kind enough to add some basic logging using the Transcript function of PowerShell into the script, so on your test device, go have a look at the log located in C:\\Windows\\Temp called Set-DellBIOSSettings.log and check to see if it\u0026rsquo;s run correctly\nLog File # It did.\nRegistry Items # Let\u0026rsquo;s check the registry and make sure it\u0026rsquo;s added in the correct values:\nYup.\nPowerShell # We can run the same command as we did at the start of this journey to confirm that our settings have applied:\nGet-ChildItem -path DellSmbios:\\ | ForEach-Object { Get-ChildItem -path @(\u0026#34;DellSmbios:\\\u0026#34; + $_.Category) | select-object attribute, currentvalue, possiblevalues, PSChildName } Format-List Attribute : BootList CurrentValue : UEFI BOOT PossibleValues : {Legacy, Uefi} PSChildName : BootSequence Attribute : SecureBoot CurrentValue : Enabled PossibleValues : {Disabled, Enabled} PSChildName : SecureBoot They did.\nSummary # With some confidence, you can now push out this App with your preferred settings to a wider device group, and the benefit is that the App itself is reusable; you just need to specify which settings are to be configured in the Installation command line, and how to detect them in the Detection Method.\nThere may be cleaner ways of doing this, probably using Proactive remediations, but then again, that requires Windows 10/11 Enterprise licensing, and we all haven\u0026rsquo;t got enterprise level money.\n","date":"10 July 2022","permalink":"/posts/dell-bios-settings-intune/","section":"Blog","summary":"What if you\u0026rsquo;ve only got Microsoft Intune to configure your Dell BIOS settings and not the glory that is Configuration Manager? How much do you like PowerShell, Win32 Apps and passwords in plain text?","title":"Configuring Dell BIOS Settings with Microsoft Intune"},{"content":"","date":"10 July 2022","permalink":"/tags/dell/","section":"Tags","summary":"","title":"Dell"},{"content":"","date":"10 July 2022","permalink":"/tags/hardware/","section":"Tags","summary":"","title":"Hardware"},{"content":"Introduction # Let\u0026rsquo;s talk about Windows 10 and above Operating System Compliance in Microsoft Intune, and specifically how using \u0026lsquo;Minimum OS Version\u0026rsquo; and \u0026lsquo;Maximum OS Version\u0026rsquo; is dumb and you should definitely check yourself if you\u0026rsquo;re using this in your environment.\nCompliance # If you\u0026rsquo;re already using Microsoft Intune compliance policies, good for you, and extra points if you\u0026rsquo;ve integrated these with Conditional Access policies. However, are you using Compliance Policies in the correct way, or even a way that makes sense?\nCompliance Granularity # I\u0026rsquo;ll talk about granularity of compliance settings, and the main reason to split out these Compliance settings into separate policies, is the actions for non-compliance; you see, you only get one set of these per policy.\nSo where you would want to mark a device as non-compliant immediately if there is no Antivirus installed, would you want it to be the same for the supported operating system builds? (Clue here, the answer is no).\nThis is a very real-world configuration, if you\u0026rsquo;re controlling the deferral and deadline settings of Software Updates via Windows Update for Business, it wouldn\u0026rsquo;t be fair and honourable for you to mark a device as non-compliant, and potentially block access to Office 365 authenticated services, when the computer itself hasn\u0026rsquo;t even received the update to be installed.\nOperating System Compliance # So now we know we should be using separate policies per compliance setting, so let\u0026rsquo;s look at Operating System Versions: With this setting you can configure the minimum and maximum operating system version, including build version using the below information to denote the format.\nThe operating system version is defined as major.minor.build.revision Sounds great, if and only if all of your Windows 10 devices are all running the same Feature Update.\nThe Problem # Let\u0026rsquo;s say your estate has the following supported (at time of writing) Windows 10 and later versions:\nWindows 10 20H2 Windows 10 21H1 Windows 10 21H2 Windows 11 21H2 So to cover all of the supported operating systems your minimum operating system compliance setting is going to be 10.0.19042.1766 (June 2022). Great.\nThis however means that any of the newer builds, patched or unpatched, will also be marked as compliant, as you know 10.0.19044.1111 is a bigger number than 10.0.19042.1766. Quick Maths.\nThis is a problem, as do you really want to mark unpatched operating systems as compliant. Again, answer here is no.\nThe Solution # This is where the \u0026lsquo;Valid operating system builds\u0026rsquo; section in the Compliance Policy comes into play, allowing you to split out each build in your End-user computing estate and each to have their own range of minimum and maximum: So there we have it, a fast turnaround for a real-world problem. Now about updating this monthly\u0026hellip;\nUpdating Compliance # When you update a Compliance Policy, it will trigger the devices the policy is assigned to, to re-evaluate the conditions and follow the actions for non-compliance if necessary. So you should be updating the Operating System Compliance Policy every month, which, although it isn\u0026rsquo;t a painful task, it is a repeatable one.\nNeedless Automation to the Rescue # So what does any good Consultant do in this situation? They write some PowerShell to do the work for them, even if writing the PowerShell script probably took longer than just updating the Compliance Policy.\nI\u0026rsquo;ve already demonstrated my coffee fuelled scripting in previous posts and this one isn\u0026rsquo;t going to be much different.\nFunctions are your Friends # We\u0026rsquo;ll need a few functions for this, some grabbed from the Intune PowerShell Samples GitHub repo, and some thrown together based on the samples.\nWe\u0026rsquo;ll be authenticating to Graph, grabbing the Windows Compliance Policies that have the Valid Operating System Build setting, getting the latest OS Build version from the Microsoft Atom Feeds and then updating the Compliance Policy. This sounded easier in my head if I\u0026rsquo;m honest.\nAuthentication # Update The move to MSAL based authentication can be found in this post.\nWe\u0026rsquo;ve seen this one before:\nFunction Get-AuthTokenMSAL { param ( [Parameter(Mandatory = $true)] $User ) $userUpn = New-Object \u0026#39;System.Net.Mail.MailAddress\u0026#39; -ArgumentList $User if ($userUpn.Host -like \u0026#39;*onmicrosoft.com*\u0026#39;) { $tenant = Read-Host -Prompt \u0026#39;Please specify your Tenant name i.e. company.com\u0026#39; Write-Host } else { $tenant = $userUpn.Host } Write-Host \u0026#39;Checking for MSAL.PS module...\u0026#39; $MSALModule = Get-Module -Name \u0026#39;MSAL.PS\u0026#39; -ListAvailable if ($null -eq $MSALModule) { Write-Host Write-Host \u0026#39;MSAL.PS Powershell module not installed...\u0026#39; -f Red Write-Host \u0026#34;Install by running \u0026#39;Install-Module MSAL.PS -Scope CurrentUser\u0026#39; from an elevated PowerShell prompt\u0026#34; -f Yellow Write-Host \u0026#34;Script can\u0026#39;t continue...\u0026#34; -f Red Write-Host exit } if ($MSALModule.count -gt 1) { $Latest_Version = ($MSALModule | Select-Object version | Sort-Object)[-1] $MSALModule = $MSALModule | Where-Object { $_.version -eq $Latest_Version.version } if ($MSALModule.count -gt 1) { $MSALModule = $MSALModule | Select-Object -Unique } } $ClientId = \u0026#39;d1ddf0e4-d672-4dae-b554-9d5bdfd93547\u0026#39; $RedirectUri = \u0026#39;urn:ietf:wg:oauth:2.0:oob\u0026#39; $Authority = \u0026#34;https://login.microsoftonline.com/$Tenant\u0026#34; try { Import-Module $MSALModule.Name $authResult = Get-MsalToken -ClientId $ClientId -Interactive -RedirectUri $RedirectUri -Authority $Authority -DeviceCode if ($authResult.AccessToken) { $authHeader = @{ \u0026#39;Content-Type\u0026#39; = \u0026#39;application/json\u0026#39; \u0026#39;Authorization\u0026#39; = \u0026#39;Bearer \u0026#39; + $authResult.AccessToken \u0026#39;ExpiresOn\u0026#39; = $authResult.ExpiresOn } return $authHeader } else { Write-Host Write-Host \u0026#39;Authorization Access Token is null, please re-run authentication...\u0026#39; -ForegroundColor Red Write-Host break } } catch { Write-Host $_.Exception.Message -f Red Write-Host $_.Exception.ItemName -f Red Write-Host break } } Testing JSON # As we need to make sure the JSON we\u0026rsquo;re generating is valid, best we test it before launching it at Graph.\nFunction Test-JSON() { param ( $JSON ) try { $TestJSON = ConvertFrom-Json $JSON -ErrorAction Stop $validJson = $true } catch { $validJson = $false $_.Exception } if (!$validJson) { Write-Host \u0026#34;Provided JSON isn\u0026#39;t in valid JSON format\u0026#34; -f Red break } } Getting Compliance Policies # As we\u0026rsquo;re going to be updating Compliance Policies, we should probably have a method to actually retrieve them using GET /deviceManagement/deviceCompliancePolicies.\nFunction Get-DeviceCompliancePolicy() { $graphApiVersion = \u0026#34;Beta\u0026#34; $Resource = \u0026#34;deviceManagement/deviceCompliancePolicies\u0026#34; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Updating Compliance Policies # This one I had to actually sort out myself, this function allows you to push updates to existing Compliance Policies. Details on this method can be found in the Graph API documentation PATCH /deviceManagement/deviceCompliancePolicies/{deviceCompliancePolicyId} documentation.\nFunction Update-DeviceCompliancePolicy() { [cmdletbinding()] param ( $Id, $JSON ) $graphApiVersion = \u0026#34;Beta\u0026#34; $Resource = \u0026#34;deviceManagement/deviceCompliancePolicies/$id\u0026#34; try { if (!$Id) { write-host \u0026#34;No Compliance Policy Id specified, specify a valid Compliance Policy Id\u0026#34; -f Red break } if ($JSON -eq \u0026#34;\u0026#34; -or $null -eq $JSON) { write-host \u0026#34;No JSON specified, please specify valid JSON for the Compliance Policy...\u0026#34; -f Red } else { Test-JSON -JSON $JSON $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Patch -Body $JSON -ContentType \u0026#34;application/json\u0026#34; Write-Host Write-Host \u0026#34;Successfully Updated Compliance Policy\u0026#34; -ForegroundColor Green } } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Getting Latest Windows Version # This is where I had a lot of issues, mainly down to the [xml] setting when parsing the RSS feed, this is down to how the content is processed when handling it live, instead of outputting it to file.\nEssentially, this function scrapes the Microsoft Atom Feed for Windows 10 and Windows 11 updates, dumps the versions into an array and picks out the most recent build version, avoiding \u0026lsquo;Preview\u0026rsquo; and \u0026lsquo;Out of band\u0026rsquo; updates.\nFunction Get-LatestWindowsUpdatesBuild() { [cmdletbinding()] param ( [ValidateSet(\u0026#39;10\u0026#39;, \u0026#39;11\u0026#39;)] $OS, $Build ) try { if (!$OS) { write-host \u0026#34;No OS specified, specify a valid Operating System number\u0026#34; -f Red break } else { if ($OS -eq \u0026#39;10\u0026#39;) { $uri = \u0026#34;https://support.microsoft.com/en-us/feed/atom/6ae59d69-36fc-8e4d-23dd-631d98bf74a9\u0026#34; } elseif ($OS -eq \u0026#39;11\u0026#39;) { $uri = \u0026#34;https://support.microsoft.com/en-us/feed/atom/4ec863cc-2ecd-e187-6cb3-b50c6545db92\u0026#34; } [xml]$Updates = (Invoke-WebRequest -Uri $uri -UseBasicParsing -ContentType \u0026#34;application/xml\u0026#34;).Content -replace \u0026#34;[^\\x09\\x0A\\x0D\\x20-\\xD7FF\\xE000-\\xFFFD\\x10000-x10FFFF]\u0026#34;, \u0026#34;\u0026#34; $BuildVersions = @() foreach ($Update in $Updates.feed.entry) { if (($update.title.\u0026#39;#text\u0026#39; -like \u0026#34;*$Build*\u0026#34;) -and ($update.title.\u0026#39;#text\u0026#39; -notlike \u0026#34;*Preview*\u0026#34;) -and ($update.title.\u0026#39;#text\u0026#39; -notlike \u0026#34;*Out-of-band*\u0026#34;)) { $BuildVersions += $update.title.\u0026#39;#text\u0026#39; } } write-host write-host \u0026#34;Latest OS Build - $($BuildVersions[0])\u0026#34; -ForegroundColor Cyan $BuildVersions[0].Substring($BuildVersions[0].LastIndexOf(\u0026#34;.\u0026#34;)) -replace \u0026#34;[\u0026#39;)\u0026#39;, \u0026#39;.\u0026#39;]\u0026#34;, \u0026#34;\u0026#34; } } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Getting, Setting and Updating # Finally we get to utilising the functions, putting it all together and updating the Compliance Policy with the latest minimum OS build version based on the latest release of each Windows 10 and later build.\nLet\u0026rsquo;s break down each section before I launch the full script at you.\nGetting the Correct Policy # We need to make sure we\u0026rsquo;re pulling through only Windows based Compliance Policies, and only those that have legitimate build version information. We\u0026rsquo;re using the @odata.type and the validOperatingSystemBuildRanges data here.\n$OSCompliancePolicies = Get-DeviceCompliancePolicy | Where-Object { ($_.\u0026#39;@odata.type\u0026#39;).contains(\u0026#34;windows10CompliancePolicy\u0026#34;) -and ($_.validOperatingSystemBuildRanges) -ne \u0026#34;\u0026#34; } Getting the Build Versions # To update each field in the Compliance Policy, we need to handle each line, in this example we only have the four currently supported versions of Windows 10, but we need the script to cater for all versions. Using this we can get the latest build version for each Windows version.\n$OSBuilds = $OSCompliancePolicy.validOperatingSystemBuildRanges $OSUpdates = @() foreach ($OSBuild in $OSBuilds) { if ($OSBuild.lowestVersion -like \u0026#39;*10.0.1*\u0026#39;) { $WindowsVersion = \u0026#39;10\u0026#39; } elseif ($OSbuild.lowestVersion -like \u0026#39;*10.0.2*\u0026#39;) { $WindowsVersion = \u0026#39;11\u0026#39; } $OSVersion = $OSBuild.lowestVersion.Split(\u0026#39;.\u0026#39;)[2] $BuildVersion = Get-LatestWindowsUpdatesBuild -OS $WindowsVersion -Build $OSVersion $NewOSBuildVersion = \u0026#39;10.0.\u0026#39; + $OSVersion + \u0026#39;.\u0026#39; + $BuildVersion } Building the JSON Payload # Now that we have the required information, we need to build the JSON payload to update the Compliance Policy with, based on the existing data and the new minimum OS build versions.\n$Update = New-Object -TypeName psobject $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.windows10CompliancePolicy\u0026#39; $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;description\u0026#39; -Value $Description foreach ($OSBuild in $OSBuilds) { $OSUpdate = New-Object -TypeName psobject $OSUpdate | Add-Member -MemberType NoteProperty -Name \u0026#39;description\u0026#39; -Value $OSBuild.description $OSUpdate | Add-Member -MemberType NoteProperty -Name \u0026#39;lowestVersion\u0026#39; -Value $NewOSBuildVersion $OSUpdate | Add-Member -MemberType NoteProperty -Name \u0026#39;highestVersion\u0026#39; -Value $OSBuild.highestVersion $OSUpdates += $OSUpdate } $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;validOperatingSystemBuildRanges\u0026#39; -Value @($OSUpdates) $JSON = $Update | ConvertTo-Json -Depth 3 Fusion, Ha # Seeing the whole bunch of bits together looks a little bit like this, and the full script can be found in my GitHub repo.\n$Date = Get-Date $Description = \u0026#34;Updated Operating System Device Compliance Policy on $Date\u0026#34; $Update = New-Object -TypeName psobject $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;@odata.type\u0026#39; -Value \u0026#39;#microsoft.graph.windows10CompliancePolicy\u0026#39; $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;description\u0026#39; -Value $Description $OSCompliancePolicies = Get-DeviceCompliancePolicy | Where-Object { ($_.\u0026#39;@odata.type\u0026#39;).contains(\u0026#34;windows10CompliancePolicy\u0026#34;) -and ($_.validOperatingSystemBuildRanges) -ne \u0026#34;\u0026#34; } foreach ($OSCompliancePolicy in $OSCompliancePolicies) { Write-Host Write-Host \u0026#34;Updating Operating System Device Compliance Policy - $($OSCompliancePolicy.displayname)\u0026#34; -ForegroundColor Green $OSBuilds = $OSCompliancePolicy.validOperatingSystemBuildRanges $OSUpdates = @() foreach ($OSBuild in $OSBuilds) { if ($OSBuild.lowestVersion -like \u0026#39;*10.0.1*\u0026#39;) { $WindowsVersion = \u0026#39;10\u0026#39; } elseif ($OSbuild.lowestVersion -like \u0026#39;*10.0.2*\u0026#39;) { $WindowsVersion = \u0026#39;11\u0026#39; } $OSVersion = $OSBuild.lowestVersion.Split(\u0026#39;.\u0026#39;)[2] $BuildVersion = Get-LatestWindowsUpdatesBuild -OS $WindowsVersion -Build $OSVersion $NewOSBuildVersion = \u0026#39;10.0.\u0026#39; + $OSVersion + \u0026#39;.\u0026#39; + $BuildVersion Write-Host Write-Host \u0026#34;Updating OS Build Minimum version to - $NewOSBuildVersion\u0026#34; -ForegroundColor Green $OSUpdate = New-Object -TypeName psobject $OSUpdate | Add-Member -MemberType NoteProperty -Name \u0026#39;description\u0026#39; -Value $OSBuild.description $OSUpdate | Add-Member -MemberType NoteProperty -Name \u0026#39;lowestVersion\u0026#39; -Value $NewOSBuildVersion $OSUpdate | Add-Member -MemberType NoteProperty -Name \u0026#39;highestVersion\u0026#39; -Value $OSBuild.highestVersion $OSUpdates += $OSUpdate } # Creating JSON object to pass to Graph $Update | Add-Member -MemberType NoteProperty -Name \u0026#39;validOperatingSystemBuildRanges\u0026#39; -Value @($OSUpdates) $JSON = $Update | ConvertTo-Json -Depth 3 # Updating the compliance policy Update-DeviceCompliancePolicy -Id $OSCompliancePolicy.id -JSON $JSON } The Action Shot # Time to finally run this script and add some level of automation to this laborious task of updating Compliance Policy\u0026hellip;\n.\\Set-WindowsOSCompliance.ps1 Running the script will prompt you to provide a username and connect to Graph, please do this and login: Then it does everything for you, and tells you about it: Best we check the Compliance Policy to make sure it\u0026rsquo;s done what I asked it to: It did, and a cheeky description based on when the policy was last updated.\nSummary # This one was a bit long winded, but it does give you an insight in not only why granular compliance policies are important, but also how to work around limitations within them. The limitations, especially when your organisation is adhering to security frameworks and need specific operating system compliance are something you may have to battle with, or in this instance, just take my example and run.\nLuckily other Operating System compliance such as Android or iOS/iPadOS isn\u0026rsquo;t as complicated to handle, but I might do a write up on that at some point\u0026hellip;maybe a rainy day.\nAlso, if you have the inclination, you could expand upon this script and have it run on a schedule, but you\u0026rsquo;ll have to change the authentication method and associated permissions utilising an App Registration in Azure AD\u0026hellip;sounds thrilling.\n","date":"30 June 2022","permalink":"/posts/operating-system-compliance-updates/","section":"Blog","summary":"Let\u0026rsquo;s talk about Windows 10 and above Operating System Compliance in Microsoft Intune, and specifically how using \u0026lsquo;Minimum OS Version\u0026rsquo; and \u0026lsquo;Maximum OS Version\u0026rsquo; is dumb and you should definitely check yourself if you\u0026rsquo;re using this in your environment.","title":"Windows Operating System Compliance Updates"},{"content":"Introduction # Now I don\u0026rsquo;t think I promised that I\u0026rsquo;d cover off bulk tagging Autopilot devices in a previous post, but you know, I was running low on things to write about. So here we are.\nAs I like to practice what I preach, I\u0026rsquo;d left myself the task of updating 1000\u0026rsquo;s of Autopilot devices with a new Group Tag after a successful Proof-of-Concept implementation of a suitable convention and syntax. Thanks past me.\nSo what does any good consultant do? Run away? Come up with a janky script that you\u0026rsquo;ll only ever run once, that contains nested \u0026lsquo;foreach\u0026rsquo; loops? Write a perfectly reusable and digestible PowerShell script using Graph API to update existing Autopilot devices\u0026hellip;\nThe Approach # Now I needed an easy way to tag specific devices with Group Tags, and then anything that didn\u0026rsquo;t have a specific Group Tag to get a default one\u0026hellip;so we\u0026rsquo;re working with two distinct use cases here.\nReady, Aim # For the first, we\u0026rsquo;ll start with exporting the Autopilot Devices from the tenant, as this CSV file will contain the Serial Numbers we need further down the line.\nNow with the CSV file, we really only need two headings, Serial Number and Group Tag. So open up your favourite editor and bin off every other heading.\nWhilst you\u0026rsquo;re there, be a darling and rename \u0026lsquo;Serial Number\u0026rsquo; to \u0026lsquo;SerialNumber\u0026rsquo; and \u0026lsquo;Group Tag\u0026rsquo; to \u0026lsquo;GroupTag\u0026rsquo;, like so:\nSerialNumber,GroupTag\rVMware-56 4d 71 00 31 a9 92 c6-ca 79 52 44 c0 3a 83 22,AJ-LT-U-ADM-IT-UK Now that you\u0026rsquo;ve got all the Autopilot devices, go ahead and laboriously update the CSV file with Group Tags and remove any devices that you want tagging with the default one.\nRepeat Offenders # We need a way to not only set the Group Tag, but fetch the ID of the Autopilot device, and as we\u0026rsquo;re doing this potentially 100\u0026rsquo;s of times, and I did say this was a repeatable and reusable script, we should create a PowerShell function or two.\nHandshake Time # Lets steal the PowerShell Authentication Function from the Intune PowerShell Samples GitHub repo to allow us to connect to Graph.\nAuthentication Function # Update The move to MSAL based authentication can be found in this post.\nFunction Get-AuthTokenMSAL { \u0026lt;# .SYNOPSIS This function is used to authenticate with the Graph API REST interface .DESCRIPTION The function authenticate with the Graph API Interface with the tenant name .EXAMPLE Get-AuthTokenMSAL Authenticates you with the Graph API interface using MSAL.PS module .NOTES NAME: Get-AuthTokenMSAL #\u0026gt; [cmdletbinding()] param ( [Parameter(Mandatory = $true)] $User ) $userUpn = New-Object \u0026#39;System.Net.Mail.MailAddress\u0026#39; -ArgumentList $User if ($userUpn.Host -like \u0026#39;*onmicrosoft.com*\u0026#39;) { $tenant = Read-Host -Prompt \u0026#39;Please specify your Tenant name i.e. company.com\u0026#39; Write-Host } else { $tenant = $userUpn.Host } Write-Host \u0026#39;Checking for MSAL.PS module...\u0026#39; $MSALModule = Get-Module -Name \u0026#39;MSAL.PS\u0026#39; -ListAvailable if ($null -eq $MSALModule) { Write-Host Write-Host \u0026#39;MSAL.PS Powershell module not installed...\u0026#39; -f Red Write-Host \u0026#34;Install by running \u0026#39;Install-Module MSAL.PS -Scope CurrentUser\u0026#39; from an elevated PowerShell prompt\u0026#34; -f Yellow Write-Host \u0026#34;Script can\u0026#39;t continue...\u0026#34; -f Red Write-Host exit } if ($MSALModule.count -gt 1) { $Latest_Version = ($MSALModule | Select-Object version | Sort-Object)[-1] $MSALModule = $MSALModule | Where-Object { $_.version -eq $Latest_Version.version } # Checking if there are multiple versions of the same module found if ($MSALModule.count -gt 1) { $MSALModule = $MSALModule | Select-Object -Unique } } $ClientId = \u0026#39;d1ddf0e4-d672-4dae-b554-9d5bdfd93547\u0026#39; $RedirectUri = \u0026#39;urn:ietf:wg:oauth:2.0:oob\u0026#39; $Authority = \u0026#34;https://login.microsoftonline.com/$Tenant\u0026#34; try { Import-Module $MSALModule.Name if ($PSVersionTable.PSVersion.Major -ne 7) { $authResult = Get-MsalToken -ClientId $ClientId -Interactive -RedirectUri $RedirectUri -Authority $Authority } else { $authResult = Get-MsalToken -ClientId $ClientId -Interactive -RedirectUri $RedirectUri -Authority $Authority -DeviceCode } # If the accesstoken is valid then create the authentication header if ($authResult.AccessToken) { # Creating header for Authorization token $authHeader = @{ \u0026#39;Content-Type\u0026#39; = \u0026#39;application/json\u0026#39; \u0026#39;Authorization\u0026#39; = \u0026#39;Bearer \u0026#39; + $authResult.AccessToken \u0026#39;ExpiresOn\u0026#39; = $authResult.ExpiresOn } return $authHeader } else { Write-Host Write-Host \u0026#39;Authorization Access Token is null, please re-run authentication...\u0026#39; -ForegroundColor Red Write-Host break } } catch { Write-Host $_.Exception.Message -f Red Write-Host $_.Exception.ItemName -f Red Write-Host break } } Authentication Token # Update The move to MSAL based authentication can be found in this post.\nAs well as the call to connect to Graph.\nif ($global:authToken) { $DateTime = (Get-Date).ToUniversalTime() $TokenExpires = ($authToken.ExpiresOn.datetime - $DateTime).Minutes if ($TokenExpires -le 0) { Write-Host \u0026#39;Authentication Token expired\u0026#39; $TokenExpires \u0026#39;minutes ago\u0026#39; -ForegroundColor Yellow if ($null -eq $User -or $User -eq \u0026#39;\u0026#39;) { $User = Read-Host -Prompt \u0026#39;Please specify your user principal name for Azure Authentication\u0026#39; } $global:authToken = Get-AuthTokenMSAL -User $User Write-Host \u0026#39;Connected to Graph API\u0026#39; -ForegroundColor Green } Else { Write-Host \u0026#39;Connected to Graph API\u0026#39; -ForegroundColor Green } } else { if ($null -eq $User -or $User -eq \u0026#39;\u0026#39;) { $User = Read-Host -Prompt \u0026#39;Please specify your user principal name for Azure Authentication\u0026#39; } $global:authToken = Get-AuthTokenMSAL -User $User Write-Host \u0026#39;Connected to Graph API\u0026#39; -ForegroundColor Green } If you haven\u0026rsquo;t authenticated to Graph in your tenant previously, you\u0026rsquo;ll probably be asked to grant Admin Consent, you want to do this, consent is important. Autopilot Functions # Now we can have a nice authenticated chat to Graph, we need to talk to the Autopilot section, deviceManagement/windowsAutopilotDeviceIdentities in fact.\nSo let\u0026rsquo;s get all Autopilot devices, as we\u0026rsquo;ll need this to:\nGet all Autopilot devices without a Group Tag set Get the Autopilot device Id for the entries in the CSV file we created Getting Autopilot Devices # Function Get-AutopilotDevices() { $graphApiVersion = \u0026#34;Beta\u0026#34; $Resource = \u0026#34;deviceManagement/windowsAutopilotDeviceIdentities\u0026#34; try { $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; (Invoke-RestMethod -Uri $uri -Headers $authToken -Method Get).Value } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Update Autopilot Device Attributes # Now we can use the below function to set the Autopilot Group Tag (I should could probably update this to set other device attributes).\nFunction Set-AutopilotDevice() { [CmdletBinding()] param( $Id, $GroupTag ) $graphApiVersion = \u0026#34;Beta\u0026#34; $Resource = \u0026#34;deviceManagement/windowsAutopilotDeviceIdentities/$Id/updateDeviceProperties\u0026#34; try { if (!$id) { write-host \u0026#34;No Autopilot device Id specified, specify a valid Autopilot device Id\u0026#34; -f Red break } if (!$GroupTag) { $GroupTag = Read-host \u0026#34;No Group Tag specified, specify a Group Tag\u0026#34; } $Autopilot = New-Object -TypeName psobject $Autopilot | Add-Member -MemberType NoteProperty -Name \u0026#39;groupTag\u0026#39; -Value $GroupTag $JSON = $Autopilot | ConvertTo-Json -Depth 3 $uri = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($Resource)\u0026#34; Invoke-RestMethod -Uri $uri -Headers $authToken -Method Post -Body $JSON -ContentType \u0026#34;application/json\u0026#34; write-host \u0026#34;Successfully added \u0026#39;$GroupTag\u0026#39; to device\u0026#34; -ForegroundColor Green } catch { $exs = $Error.ErrorDetails $ex = $exs[0] Write-Host \u0026#34;Response content:`n$ex\u0026#34; -f Red Write-Host Write-Error \u0026#34;Request to $Uri failed with HTTP Status $($ex.Message)\u0026#34; Write-Host break } } Scary Stuff Lies Ahead # So we now have the functions in order to connect, get and set all the things we need. Here comes the fun part, PowerShell logic driven by four cups of coffee.\nScript Parameters # Before that, some lovely parameters to ensure you can\u0026rsquo;t really mess things up.\nMethod: Set to be either \u0026lsquo;CSV\u0026rsquo; or \u0026lsquo;Online\u0026rsquo;, used for loading that beautiful CSV created earlier, or to just grab all the Autopilot devices in the tenant with a blank Group Tag DefaultGroupTag: The \u0026lsquo;Catch All\u0026rsquo; Group Tag for those devices that don\u0026rsquo;t have one set already The Logic? # Here we have the guts of the script, designed so that you run it through once with the CSV option, then a second time using the Online option. Don\u0026rsquo;t ask me why I did it this way, four coffees remember.\nI was also kind enough to capture any of the devices in the CSV file missing a Group Tag and prompt to enter one in. Very kind.\n# Script Start # Get Devices if ($Method -eq \u0026#39;CSV\u0026#39;) { $CSVPath = Read-host \u0026#34;Please provide the path to the CSV file containing a list of device serial numbers and new Group Tag e.g. C:\\temp\\devices.csv\u0026#34; if (!(Test-Path \u0026#34;$CSVPath\u0026#34;)) { Write-Host \u0026#34;Import Path for CSV file doesn\u0026#39;t exist\u0026#34; -ForegroundColor Red Write-Host \u0026#34;Script can\u0026#39;t continue\u0026#34; -ForegroundColor Red Write-Host break } else { $AutopilotDevices = Import-Csv -Path $CSVPath } } elseif ($Method -eq \u0026#39;Online\u0026#39;) { Write-Host \u0026#34;Getting all Autopilot devices without a Group Tag\u0026#34; -ForegroundColor Cyan $AutopilotDevices = Get-AutopilotDevices | Where-Object { ($null -eq $_.groupTag) -or ($_.groupTag) -eq \u0026#39;\u0026#39; } } # Sets Group Tag foreach ($AutopilotDevice in $AutopilotDevices) { $id = $AutopilotDevice.id if (!$id) { Write-host \u0026#34;No Autopilot Device Id, getting Id from Graph\u0026#34; -ForegroundColor Cyan $id = (Get-AutopilotDevices | Where-Object { ($_.serialNumber -eq $AutopilotDevice.serialNumber) }).id Write-Host \u0026#34;ID:\u0026#39;$Id\u0026#39; found for device with serial \u0026#39;$($AutopilotDevice.Serialnumber)\u0026#39;\u0026#34; -ForegroundColor Green } if ($Method -eq \u0026#39;CSV\u0026#39;) { $GroupTag = $AutopilotDevice.groupTag if (!$GroupTag) { Write-host \u0026#34;No Autopilot Device Group Tag found in CSV\u0026#34; -ForegroundColor Cyan $GroupTag = Read-Host \u0026#39;Please enter the group tag for device with serial \u0026#39;$AutopilotDevice.serialNumber\u0026#39; now:\u0026#39; } } elseif ($Method -eq \u0026#39;Online\u0026#39;) { $GroupTag = $DefaultGroupTag } try { Set-AutopilotDevice -Id $id -GroupTag $GroupTag write-host \u0026#34;Group tag: \u0026#39;$GroupTag\u0026#39; set for device with serial \u0026#39;$($AutopilotDevice.Serialnumber)\u0026#39;\u0026#34; -ForegroundColor Green } catch { write-host \u0026#34;Group tag: \u0026#39;$GroupTag\u0026#39; not set for device with serial \u0026#39;$($AutopilotDevice.Serialnumber)\u0026#39;\u0026#34; -ForegroundColor Red } } Fire # So bring it all together into a mega-script we now have a way to update the Autopilot Group Tags. So let\u0026rsquo;s give it a go.\nP.S. There is no -whatif command, so I\u0026rsquo;d start with the CSV of a couple of test devices. Sniper Time # Running the script with the CSV option:\n.\\Set-AutopilotGroupTag.ps1 -Method CSV We first have to Authenticate, so enter in your username and the find the Azure AD login window: Now we need to provide the path to the CSV file:\nPlease provide the path to the CSV file containing a list of device serial numbers and new Group Tag e.g. C:\\temp\\devices.csv: Now the script will run and update all the devices in the CSV file with their corresponding Group Tags:\nAnd if we check in Intune: Which amazingly, the Group Tag matches the data in the CSV file we created earlier. Too early to call this a win outright, but we\u0026rsquo;re on the way.\nShotgun Approach # We need to now clear up the remaining devices without Group Tags, this one we can\u0026rsquo;t really test, unless you fancy improving the script.\nSimilar setup to the CSV run, but this time the arguments look like the below:\n.\\Set-AutopilotGroupTag.ps1 -Method Online -DefaultGroupTag \u0026#39;AJ-LT-U-STD-ALL-UK\u0026#39; We\u0026rsquo;re already authenticated, so we can skip that bit, and we\u0026rsquo;re not using the CSV option so it will get straight to the good stuff:\nAnd if we check in Intune: This Group Tag matches the DefaultGroupTag parameter we set when running the script. I\u0026rsquo;d call this one a win.\nSummary # There might be easier ways of doing this, or a little less caffeine fuelled at least, but if you want to bulk set Group Tags to your existing Autopilot devices, this does seem like a half decent approach.\nFor new devices, I recommend that you work with your supplier/OEM and get them to tag them as part of the on-boarding.\nAlso, you can run this many times, so if you do want to re-tag devices, you can use the CSV method to do so.\nAlso also, you should look at this post about using dynamic groups to ring fence your newly tagged devices.\n","date":"19 June 2022","permalink":"/posts/windows-autopilot-retrofitting-group-tags/","section":"Blog","summary":"Now that we know how powerful Autopilot Group Tags can be, we should look into how we can retrofit devices with these Group Tags when the OEM or Supplier didn\u0026rsquo;t bother doing their part of the deal.","title":"Retrofitting Windows Autopilot Group Tags"},{"content":"Introduction # Now if you\u0026rsquo;ve ever spoken to me about Microsoft Intune and using Dynamic Groups for management of users and devices, I probably would have talked your ears off about the attribute usage, which attributes are suitable, and that moving away from assigned groups to dynamic is the only way forward for Modern Device Management.\nWhat if I told you, that there\u0026rsquo;s something on par with these holy grail groups, and maybe, just maybe, even better.\nMy Beloved Dynamic Groups # Before we jump into Device Filters, let us talk about Dynamic Groups a little\u0026hellip;\nFirstly, I would highly recommend the use of these groups, especially for grouping devices, whether this be based on enrolment type, ownership, operating system type or version\u0026hellip;and if you\u0026rsquo;ve got something or someone managing your user attributes, that you use them for user groups.\nThe Limitations # This sadly, is how quickly these groups update; Microsoft probably realised that people were using these groups in relation to device management, and also realised that the enumeration of the groups was using precious Compute infrastructure, for free, smh.\nSo Microsoft reduced how often these groups fully updated to once every 24 hours.\nNow this is no good when we want to target settings and restrictions, or even just application deployment to these dynamically populated groups, we end up with delaying installations, configuration settings or even connectivity. Not a fan.\nBring on the Filters # So where Microsoft take away with one hand, they give with the other, and this is the new world of Device Filters.\nAt a high level, what makes filters so much better for use in Microsoft Intune comes down a couple of things:\nThe filter evaluation is done when the device enrols and/or checks in with the Intune service; this means the speed of evaluation is significantly faster than dynamic groups. Filters are entirely reusable meaning we can now create one filter and use it for many areas within Microsoft Intune. Before a policy is applied to a device, filters dynamically evaluate applicability:\nYou create a filter for any platform based on some device properties.\nYou assign a policy or app to the group. In the assignment, you add the filter in either include or exclude mode. For example, you \u0026ldquo;include\u0026rdquo; personal devices, or you \u0026ldquo;exclude\u0026rdquo; personal devices from the policy.\nThe filter is evaluated when the device enrols or at any other time a policy evaluates.\nYou see the filter results based on the evaluation. For example, the app or policies applies, or it doesn\u0026rsquo;t apply.\nInconsistent Assignments # So we\u0026rsquo;ve talked about the limitations with Dynamic Groups, but we do need to talk about the limitations with Device Filters\u0026hellip; Not all areas of Microsoft Intune support the use of Filters (as of today, though this will hopefully change), meaning that you can\u0026rsquo;t provide a consistent application method of assignments.\nFor example, Autopilot profiles don\u0026rsquo;t support filters, and nor do Endpoint Security Profiles, nor PowerShell scripts, nor MAM policies. However, a lot of crucial areas do, including Compliance, Configuration and Windows Update for Business profiles. Groups looking good here.\nFewer Properties # Device Filters have fewer attribute properties to work with compared with Dynamic Groups, so any advanced filtering like with Autopilot Group Tags will still need to be done using Dynamic Groups.\nDevice Filters Dynamic Groups Win for the Groups.\nFewer Operators # Device Filters do not support advanced logic with the operators such as \u0026lsquo;Match\u0026rsquo;, so turbo advanced filtering such as Intelligent Phased Windows Update for Business Deployments need to be handled with groups still.\nDevice Filters Dynamic Groups Another win there, 3-0 to the Groups.\nSummary # Even with these Device Filter limitations (and the 3-0 loss), the benefits of reusability and speed in which they are processed still shine through over Dynamic Groups in many areas of Microsoft Intune, and I strongly recommend moving to using the \u0026lsquo;All Devices\u0026rsquo; and \u0026lsquo;All Users\u0026rsquo; in-built assignments in conjunction with Device Filters, just to make your life that little bit easier when managing devices.\nYou\u0026rsquo;ve come this far, so why not give creating them a shot and create a filter or two?\n","date":"8 June 2022","permalink":"/posts/endpoint-manager-device-filters/","section":"Blog","summary":"Now if you\u0026rsquo;ve ever spoken to me about Microsoft Intune and using Dynamic Groups for management of users and devices, I probably would have talked your ears off about the attribute usage, which attributes are suitable, and that moving away from assigned groups to dynamic is the only way forward for Modern Device Management.","title":"Dynamic Groups vs Device Filters"},{"content":"","date":"8 June 2022","permalink":"/tags/filters/","section":"Tags","summary":"","title":"Filters"},{"content":"","date":"21 May 2022","permalink":"/tags/accessibility/","section":"Tags","summary":"","title":"Accessibility"},{"content":"Introduction # Have you ever wondered how to ensure that a number of languages are available for selection to end users on shared Windows 10 devices? The thought hadn\u0026rsquo;t crossed my mind, but then again, you encounter new use cases and requirements on a weekly basis. This was one of those occasions, needing a Library Kiosk machine to have a set of languages available to users upon login to the machine.\nConfiguration # There are a number of posts out in the wild on how to fully change the Windows languages on a device by device basis, but in this instance we needed to keep the core language as en-GB but allow end users to select their preferred input language within Windows, and ensure that this language list can be modified in the event of new languages being required.\nLet\u0026rsquo;s crack on shall we\u0026hellip;\nWindows User Language List # You may be familiar with the \u0026lsquo;old\u0026rsquo; way of automating the setting user languages in Windows 7, calling control.exe intl.cpl,,/f:\u0026quot;c:\\Unattend.xml\u0026quot; and assigning an xml file with the required user languages, luckily with Windows 10 comes the Set-WinUserLanguageList PowerShell command.\nMicrosoft does a great job of detailing how this command is used, so below is the way I\u0026rsquo;ve created a new list, and appended the required languages using the region tag.\nThis allows for new languages to be added to the script readily.\n# Sets the Windows Languages $LanguageList = New-WinUserLanguageList -Language \u0026#39;en-GB\u0026#39; $Languages = New-Object -TypeName System.Collections.ArrayList $Languages.AddRange(@( \u0026#34;en-US\u0026#34;, \u0026#34;ar-SA\u0026#34;, \u0026#34;zh-HK\u0026#34;, \u0026#34;zh-CN\u0026#34;, \u0026#34;zh-TW\u0026#34;, \u0026#34;el-GR\u0026#34;, \u0026#34;he-IL\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;zh-Hant-TW\u0026#34;, \u0026#34;jp-JP\u0026#34;, \u0026#34;am-ET\u0026#34;, \u0026#34;Cy-az-AZ\u0026#34;, \u0026#34;Lt-az-AZ\u0026#34;, \u0026#34;fa-IR\u0026#34;, \u0026#34;ka-GE\u0026#34; )) Foreach($Language in $Languages){ $LanguageList.Add($Language) } Try{ Set-WinUserLanguageList -LanguageList $LanguageList -Force } Catch{ Write-Error \u0026#34;Unable to set the language list $($_.Exception.Message)\u0026#34; } Task Scheduling # This script allows the creation and installation of a User Language List, containing the required languages needed for each user who accesses the shared device. This seemed all a bit too perfect for this requirement; updatable list of languages, uses native PowerShell commands, can be deployed via Microsoft Intune. That was until I realised this only works correctly under a user context, and I also need it to run each time a user logs on to the machine.\nSo now we need a way to create a Scheduled Task and have it run the PowerShell script, without the end user seeing it run.\nLuckily, I was using a script to map network drives, generated from here to do something similar, time to not reinvent the wheel and just make use of someone else\u0026rsquo;s hard work.\nLet\u0026rsquo;s break down the sections of the script.\nRunning as SYSTEM # First off the detecting whether the script is being run under a SYSTEM context; this is important, as when deployed via Microsoft Intune the script will be running under this context, at this time we want the script to create the scheduled task, not run the containing PowerShell, in this instance the addition of user languages.\nfunction Test-RunningAsSystem { [CmdletBinding()] param() process { return [bool]($(whoami -user) -match \u0026#34;S-1-5-18\u0026#34;) } } Creating the Task # Now we have determined whether we\u0026rsquo;re running as SYSTEM or not, now time to create the Scheduled Task, and to have the script launched, using a dirty vbs file, to hide the PowerShell windows.\nif (Test-RunningAsSystem) { Start-Transcript -Path $(Join-Path -Path $env:temp -ChildPath \u0026#34;WindowsLanguages-ST.log\u0026#34;) Write-Output \u0026#34;Running as System --\u0026gt; creating scheduled task which will run on user logon\u0026#34; # Get the current script path and content and save it to the client $currentScript = Get-Content -Path $($PSCommandPath) $schtaskScript = $currentScript[(0) .. ($currentScript.IndexOf(\u0026#34;#!SCHTASKCOMESHERE!#\u0026#34;) - 1)] $scriptSavePath = $(Join-Path -Path $env:ProgramData -ChildPath \u0026#34;Intune-Helper\\Windows-Languages\u0026#34;) if (-not (Test-Path $scriptSavePath)) { New-Item -ItemType Directory -Path $scriptSavePath -Force } $scriptSavePathName = \u0026#34;Set-WindowsLanguages.ps1\u0026#34; $scriptPath = $(Join-Path -Path $scriptSavePath -ChildPath $scriptSavePathName) $schtaskScript | Out-File -FilePath $scriptPath -Force # Create dummy vbscript to hide PowerShell Window popping up at logon $vbsDummyScript = \u0026#34; Dim shell,fso,file Set shell=CreateObject(`\u0026#34;WScript.Shell`\u0026#34;) Set fso=CreateObject(`\u0026#34;Scripting.FileSystemObject`\u0026#34;) strPath=WScript.Arguments.Item(0) If fso.FileExists(strPath) Then set file=fso.GetFile(strPath) strCMD=`\u0026#34;powershell -nologo -executionpolicy ByPass -command `\u0026#34; \u0026amp; Chr(34) \u0026amp; `\u0026#34;\u0026amp;{`\u0026#34; \u0026amp;_ file.ShortPath \u0026amp; `\u0026#34;}`\u0026#34; \u0026amp; Chr(34) shell.Run strCMD,0 End If \u0026#34; $scriptSavePathName = \u0026#34;WindowsLanguages-VBSHelper.vbs\u0026#34; $dummyScriptPath = $(Join-Path -Path $scriptSavePath -ChildPath $scriptSavePathName) $vbsDummyScript | Out-File -FilePath $dummyScriptPath -Force $wscriptPath = Join-Path $env:SystemRoot -ChildPath \u0026#34;System32\\wscript.exe\u0026#34; # Register a scheduled task to run for all users and execute the script on logon $schtaskName = \u0026#34;Intune Helper - Windows Languages\u0026#34; $schtaskDescription = \u0026#34;Applies Windows Languages using a PowerShell script.\u0026#34; $trigger = New-ScheduledTaskTrigger -AtLogOn #Execute task in users context $principal = New-ScheduledTaskPrincipal -GroupId \u0026#34;S-1-5-32-545\u0026#34; -Id \u0026#34;Author\u0026#34; #call the vbscript helper and pass the PosH script as argument $action = New-ScheduledTaskAction -Execute $wscriptPath -Argument \u0026#34;`\u0026#34;$dummyScriptPath`\u0026#34; `\u0026#34;$scriptPath`\u0026#34;\u0026#34; $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries $null = Register-ScheduledTask -TaskName $schtaskName -Trigger $trigger -Action $action -Principal $principal -Settings $settings -Description $schtaskDescription -Force Start-ScheduledTask -TaskName $schtaskName Stop-Transcript } Now we\u0026rsquo;ve got the bones of the script, we can put it all together and deploy it using Microsoft Intune. The full script can be found here\nDeployment # Save the above script and create a new PowerShell script deployment in Microsoft Intune using the following configuration settings, then deploy to a test group of devices.\nNow we have a way to deploy additional languages to Windows 10 devices, and have the Keyboard inputs available when the user has logged onto the device. The user just needs to select the language from the notification area.\nSummary # Pretty straight forward right? Setting the language list, letting \u0026lsquo;Windows Features on Demand\u0026rsquo; just download the required files, plus, you can amend the languages within the script and re-deploy, allowing you to add or remove any required languages for your users without having to deal with Language Packs.\n","date":"21 May 2022","permalink":"/posts/windows-autopilot-languages/","section":"Blog","summary":"Have you ever wondered how to ensure that a number of languages are available for selection to end users on shared Windows 10 devices? The thought hadn\u0026rsquo;t crossed my mind, but then again, you encounter new use cases and requirements on a weekly basis. This was one of those occasions.","title":"Configuring Available User Languages on Windows Devices"},{"content":"Introduction # We have already looked at allowing Android Enterprise enrolment using Mobile Data in a previous post, now it\u0026rsquo;s time to look at some of the other provisioning values that can be used to create a custom enrolment QR Code.\nConfiguration # This time, it\u0026rsquo;s adding in a WiFi profile, to allow the devices to auto-connect as part of the enrolment process\u0026hellip;anything to make life easier for users.\nExtracting the QR Code Data # First off you\u0026rsquo;ll need the QR code being used for your Android Enterprise enrolment, you can find this within the Android section of Microsoft Intune. Save this file to your computer and use an online reader to get the full QR code data:\n{ \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME\u0026#34;:\u0026#34;com.google.android.apps.work.clouddpc/.receivers.CloudDeviceAdminReceiver\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM\u0026#34;:\u0026#34;I5YvS0O5hXY46mb01BlRjq4oJJGs2kuUcHvVkAPEXlg\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION\u0026#34;:\u0026#34;https://play.google.com/managed/downloadManagingApp?identifier=setup\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE\u0026#34;:{ \u0026#34;com.google.android.apps.work.clouddpc.EXTRA_ENROLLMENT_TOKEN\u0026#34;:\u0026#34;SELECTED ENROLMENT TOKEN\u0026#34; } } WiFi Settings # We\u0026rsquo;re now going to add in four new lines of data into the existing JSON content from the Android Developer Reference Guide:\nThis is the SSID of the wireless network you want to connect to. \u0026quot;android.app.extra.PROVISIONING_WIFI_SSID\u0026quot;:\u0026quot;WIFI_SSID\u0026quot; This is the password of the wireless network. \u0026quot;android.app.extra.PROVISIONING_WIFI_PASSWORD\u0026quot;:\u0026quot;WIFI_PASSWORD\u0026quot; This is the security type of the network, select either none, WPA, WEP or EAP \u0026quot;android.app.extra.PROVISIONING_WIFI_SECURITY_TYPE\u0026quot;:\u0026quot;NONE/WPA/WEP/EAP\u0026quot; And finally whether the network is hidden to broadcast, using either true or false \u0026quot;android.app.extra.PROVISIONING_WIFI_HIDDEN\u0026quot;:true/false Now, please be aware that these settings are all available in plain text by anyone scanning the QR code, so I would recommend using a guest wireless network if you are going to allow you end users to use a corporate network to go through the enrolment process. Updating the JSON Data # Now that we\u0026rsquo;ve got the required strings ready to be added, we need to update the existing JSON data. The below settings, need to go after the android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE\u0026quot; section:\n\u0026#34;android.app.extra.PROVISIONING_WIFI_SSID\u0026#34;:\u0026#34;corp-guest-wifi\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_WIFI_PASSWORD\u0026#34;:\u0026#34;supersecurepassword\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_WIFI_SECURITY_TYPE\u0026#34;:\u0026#34;WPA\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_WIFI_HIDDEN\u0026#34;: false Full JSON Data # So the full JSON string should look like the below, with the SELECTED ENROLMENT TOKEN the correct one from the original QR code:\n{ \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME\u0026#34;:\u0026#34;com.google.android.apps.work.clouddpc/.receivers.CloudDeviceAdminReceiver\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION\u0026#34;:\u0026#34;https://play.google.com/managed/downloadManagingApp?identifier=setup\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM\u0026#34;:\u0026#34;I5YvS0O5hXY46mb01BlRjq4oJJGs2kuUcHvVkAPEXlg\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE\u0026#34;:{ \u0026#34;com.google.android.apps.work.clouddpc.EXTRA_ENROLLMENT_TOKEN\u0026#34;:\u0026#34;SELECTED ENROLMENT TOKEN\u0026#34; }, \u0026#34;android.app.extra.PROVISIONING_WIFI_SSID\u0026#34;:\u0026#34;corp-guest-wifi\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_WIFI_PASSWORD\u0026#34;:\u0026#34;supersecurepassword\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_WIFI_SECURITY_TYPE\u0026#34;:\u0026#34;WPA\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_WIFI_HIDDEN\u0026#34;: false } Creating a new QR Code # For completions sake, we should validate the JSON formatting using an online tool before we use a QR Code Generator to create our new QR code:\nSummary # This new QR Code can then be provided to your users, following successful testing, to allow them to enrol their new Android device in Microsoft Intune when in range of your corporate guest wireless network.\n","date":"11 May 2022","permalink":"/posts/android-enterprise-custom-qr-code/","section":"Blog","summary":"Making your users lives easier with Android Fully Managed Corporate Owned enrolment, this time auto adding a corporate wireless network.","title":"Customising the Android Enterprise Enrolment QR Code"},{"content":"Introduction # Ever had to add notes to Intune Managed Devices in bulk? Me either, well not until a few weeks ago when I needed an easy way to update the notes field on 100\u0026rsquo;s of devices.\nSo luckily I stumbled upon a post by Paul Wetter about getting and setting notes on devices using Graph API, and specifically the Beta channel of Graph. Luckily, Paul did the ground work and created a couple of functions, which I have happily stolen borrowed, updated and tweaked to allow for updating notes en masse.\nConfiguration # I\u0026rsquo;ve broken down each section of the script for a bit of a walk through, the important thing with all of this is making sure you have the Microsoft Graph Intune PowerShell module installed - Install-Module -Name Microsoft.Graph.Intune and you\u0026rsquo;ve connected to MSGraph - Connect-MSGraph.\nGetting Device Notes # The Get-IntuneDeviceNotes function leans on the Microsoft.Graph.Intune PowerShell module, to grab the Intune device ID using Get-IntuneManagedDevice, then grabs the device properties filtered to the Device Notes property. This will help us in getting individual device notes, as we kinda don\u0026rsquo;t want to lose any that have already been added.\nFunction Get-IntuneDeviceNotes{ [CmdletBinding()] param ( [Parameter(Mandatory=$true)] [String] $DeviceName ) Try { $DeviceID = (Get-IntuneManagedDevice -filter \u0026#34;deviceName eq \u0026#39;$DeviceName\u0026#39;\u0026#34; -ErrorAction Stop).id } Catch { Write-Error $_.Exception.Message break } $Resource = \u0026#34;deviceManagement/managedDevices(\u0026#39;$deviceId\u0026#39;)\u0026#34; $properties = \u0026#39;notes\u0026#39; $uri = \u0026#34;https://graph.microsoft.com/beta/$($Resource)?select=$properties\u0026#34; Try{ (Invoke-MSGraphRequest -HttpMethod GET -Url $uri -ErrorAction Stop).notes } Catch{ Write-Error $_.Exception.Message break } } Setting Device Notes # The Set-IntuneDeviceNotes function also leans on the Microsoft.Graph.Intune PowerShell module, to grab the Intune device ID using Get-IntuneManagedDevice, and posts the formed JSON file to Graph to update the Notes property. Trouble with this, is that it will overwrite any existing notes that exist, so we need a way to sort this out.\nFunction Set-IntuneDeviceNotes{ [CmdletBinding()] param ( [Parameter(Mandatory=$true)] [String] $DeviceName, [Parameter(Mandatory=$false)] [String] $Notes ) Try { $DeviceID = (Get-IntuneManagedDevice -filter \u0026#34;deviceName eq \u0026#39;$DeviceName\u0026#39;\u0026#34; -ErrorAction Stop).id } Catch{ Write-Error $_.Exception.Message break } If (![string]::IsNullOrEmpty($DeviceID)){ $Resource = \u0026#34;deviceManagement/managedDevices(\u0026#39;$DeviceID\u0026#39;)\u0026#34; $GraphApiVersion = \u0026#34;Beta\u0026#34; $URI = \u0026#34;https://graph.microsoft.com/$graphApiVersion/$($resource)\u0026#34; $JSONPayload = @\u0026#34; { notes:\u0026#34;$Notes\u0026#34; } \u0026#34;@ Try{ Write-Verbose \u0026#34;$URI\u0026#34; Write-Verbose \u0026#34;$JSONPayload\u0026#34; Invoke-MSGraphRequest -HttpMethod PATCH -Url $uri -Content $JSONPayload -Verbose -ErrorAction Stop } Catch{ Write-Error $_.Exception.Message break } } } Bulk Setting Device Notes # The Set-BulkIntuneDeviceNotes function utilises both of the previous functions; one to get the existing notes and add it to a new array variable, then to update the variable with the new notes in the CSV file that gets imported. There\u0026rsquo;s also some logic around whether there are existing notes using the -match operator, which is fun.\nFunction Set-BulkIntuneDeviceNotes{ [CmdletBinding()] param ( [Parameter(Mandatory=$true)] [String] $DeviceList ) if(Test-Path -Path $DeviceList){ $Devices = Import-csv $DeviceList foreach($Device in $Devices){ # Add Date stamp to the new notes $NewNotes = $Device.Notes $Notes = New-Object -TypeName System.Collections.ArrayList $Notes.AddRange(@( $NewNotes, \u0026#34;`n\u0026#34; # Adds a line break \u0026#34;`n\u0026#34; # Adds a line break )) # Get existing device notes Try{ $OldNotes = Get-IntuneDeviceNotes -DeviceName $Device.Device If($OldNotes -match \u0026#39;\\d\u0026#39; -or $OldNotes -match \u0026#39;\\w\u0026#39;){ Write-Host \u0026#34;Existing notes found on $($Device.Device), adding to Notes variable\u0026#34; -ForegroundColor Cyan $Notes.AddRange(@( $OldNotes )) } else{ } } Catch{ Write-Host \u0026#34;Unable to get device notes, ensure you are connected to MSGraph\u0026#34; -ForegroundColor Red Break } # Add the new notes, included the old ones Try{ Set-IntuneDeviceNotes -DeviceName $Device.Device -Notes $Notes Write-Host \u0026#34;Notes successfully added to $($Device.Device)\u0026#34; -ForegroundColor Green } Catch{ Write-Host \u0026#34;Unable to set device notes, ensure you are connected to MSGraph\u0026#34; -ForegroundColor Red Break } } } else{ Write-Host \u0026#34;Unable to access the provided device list, please check the csv file and re-run the script.\u0026#34; -ForegroundColor red Break } } Running the Script # The only parameter required is a CSV file, which only has two headers, \u0026lsquo;Device\u0026rsquo; and \u0026lsquo;Notes\u0026rsquo;, so feel free to create one yourself, as I don\u0026rsquo;t think you need a template this time. Then just populate the CSV file with the devices and the required notes that need adding.\nSample CSV:\nDevice,Notes\rENB-13F278,Here are the New notes about the device. To run the script, firstly install Microsoft Graph Intune PowerShell module and connect to Graph, then run the three functions, finally run the below updating the DeviceList path to your created CSV file:\nSet-MEMDeviceNotes -DeviceList C:\\temp\\UpdatedDeviceNotes.csv I\u0026rsquo;d test this with a single device in the CSV file first before you do this in bulk, you know, just in case.\nThe full script can be found here\nThe Results # But once run successfully, you\u0026rsquo;ll have devices with updated notes, so from this\u0026hellip; To this\u0026hellip; Summary # Yes this was a hacky script, yes I spent more time writing this post about it than putting the script together\u0026hellip;but the script does the job and saves having to manually update the notes field. Plus now you know how to do it, you can put whatever you want either in the csv file, or use something else to populate the field. World and Oyster.\n","date":"5 May 2022","permalink":"/posts/bulk-adding-device-notes/","section":"Blog","summary":"Ever had to add notes to Intune Managed Devices in bulk? Me either, well not until a few weeks ago when I needed an easy way to update the notes field on 100\u0026rsquo;s of devices.","title":"Bulk Adding Device Notes to Enrolled Devices"},{"content":"Introduction # So you\u0026rsquo;re using Windows Autopilot in some shape or form to deploy Windows 10/11 devices to your users, and you\u0026rsquo;re probably already familiar with the Autopilot dynamic group queries used for targetting these devices, right? Good.\nSo what if you have multiple deployment profiles, or different device use cases with the same profile, or different user personas, or test and pilot deployments, or a range of applications, configurations or scripts that you want to separate out to the devices or users of the devices? You probably do\u0026hellip;what\u0026rsquo;s that you say, you\u0026rsquo;re using static groups to manage these? Let me show you the way forward.\nConfiguration # If you\u0026rsquo;ve got this far, you\u0026rsquo;ll probably know that Windows Autopilot is the modern deployment method for Windows 10/11 devices, allowing an organisation to pre-register corporate-owned devices (using their unique hardware hashes) and link these devices to the Azure AD tenant. Once the device is attached to the tenant, it is considered a trusted device that can be enrolled using Autopilot.\nBelow is an overview of the Windows Autopilot process, the bit we\u0026rsquo;re talking about is the Hardware Vendor adding the Device IDs; this is where the Vendor can also add Group Tags.\nGroup Tags # A hidden gem with Autopilot service, is the Group Tag attribute for Autopilot devices, this tag can be provided during the pre-registration by a supplier or OEM, and can be configured or updated after the device has been imported.\nThis attribute is attached the computer object that exists in Azure AD, sadly not labelled as \u0026ldquo;Group Tag\u0026rdquo;, but as \u0026ldquo;OrderID\u0026rdquo; (this will be important later). As this attribute exists, we can utilise it with Dynamic Device groups\u0026hellip;do you see where this is going?\nNaming Conventions # Now he have this little beaut of a trick, we can start to look at how we use the Group Tag attribute to our advantage, and address some of the potential use cases for grouping Autopilot devices, whether this be based on deployment type, application assignment or just for overall better management of devices.\nI\u0026rsquo;m a big fan of having things named in a readable way, it just makes life a bit more straight forward in Microsoft Intune, and Group Tags are no different.\nSyntax # Your convention may differ from the below, as it will be entirely based on your own requirements, however I\u0026rsquo;ll give you a syntax starter for ten so you have an understanding of your options.\nPosition Value Description 1-2 AJ / HJ The Azure AD Join type - Azure AD or Hybrid Joined 3-4 LT / DT / VM The Device Type - Laptop, Desktop or Virtual Machine 5 U / S / K The Device Use Case - User Assigned, Shared or Kiosk 6-8 STD / ADM The User Type - Standard or Admin 9-11 FIN / HR / PAY The Users Department - Finance, HR or, Payroll etc. 12-13 UK / US / FR The Device Location - United Kingdom, United States, France etc. With this basic syntax in place, we can build out the Group Tag for devices:\nGroup Tag Description AJ-LT-U-STD-PAY-US Azure AD Joined Laptop, assigned to a User, with no Admin rights, in Payroll in the United States HJ-DT-S-ADM-FIN-UK Hybrid Azure AD Joined Desktop, configured as a Shared Device, with Admin rights, in Finance in the United Kingdom Dynamic Groups # Now that we have sorted out the syntax and conventions, it\u0026rsquo;s now time to create some dynamic groups in Azure AD. We\u0026rsquo;re not only going to create specific groups that equal the Group Tag, but groups that match the Group Tag. This allows assignment of Deployment Profiles, Configuration Profiles and Applications to all device types in a dynamic way, alleviating the need to manually manage groups.\nExample Groups # The below dynamic query would contain all Azure AD Joined Autopilot Laptops:\n(device.devicePhysicalIds -any _ ‚ÄìstartsWith \u0026#34;[OrderID]:AJ-LT\u0026#34;) This one contains all the Autopilot Desktops in Finance, whether Hybrid Joined or Azure AD Joined:\n(device.devicePhysicalIds -any (_ -match \u0026#34;^\\[OrderID\\]:.*DT.*FIN.*\u0026#34;)) This this one with all Laptops in France:\n(device.devicePhysicalIds -any (_ -match \u0026#34;^\\[OrderID\\]:.*LT.*FR$\u0026#34;)) And this this one with all Azure AD joined Laptops with Admin users in Payroll in all countries:\n(device.devicePhysicalIds -any (_ -match \u0026#34;^\\[OrderID\\]:AJ-LT.*ADM-PAY.*\u0026#34;)) You get the picture\u0026hellip;the possibilities for both the syntax and the dynamic groups using Regex are pretty much endless, and should be tailored to how you manage devices in Microsoft Intune.\nApplication # With the creation of these groups, you can now assign, well, pretty much anything in Microsoft Intune, to them.\nLets say you want all Laptops to have a BitLocker Endpoint Protection profile, but not Desktops\u0026hellip;you can do this. What about assigning an application to all HR devices that are Hybrid Joined, yup, you can do that too.\nIf you\u0026rsquo;re really all up in there with Microsoft Intune, you\u0026rsquo;re probably using Role Based Access Control (RBAC), these groups also allow for segregated management of devices based on location, department, join type etc. for specific User Roles or permission such as Remote Wipe or Application Deployment\u0026hellip;I know, exciting.\nSummary # What we have here, is a relatively painless way of tagging devices in any way you want to, kind of like creating a classic Organisational Structure but way more interesting and with the ability to do so without being constrained to a flat structure.\nThe next step is to clearly define your naming convention and syntax for the Group Tags, and have fun I guess.\nNow if you\u0026rsquo;re asking how to tag these devices on mass, without having to manually do so, well that\u0026rsquo;s another post.\n","date":"28 April 2022","permalink":"/posts/autopilot-power-of-group-tags/","section":"Blog","summary":"A hidden gem with Autopilot service, is the Group Tag attribute for Autopilot devices, this tag can be provided during the pre-registration by a supplier or OEM, and can be configured or updated after the device has been imported. What can we use it for in Intune?","title":"The Hidden Power of Windows Autopilot Group Tags"},{"content":"Introduction # If you\u0026rsquo;ve ever had to implement baseline security settings, whether this be Centre for Internet Security (CIS), Cyber Security Essentials (CSE), or National Cyber Security Centre (NCSC), you\u0026rsquo;ll probably have encountered some level of pain when it comes to non-Microsoft devices, as the guidance, is, well, complicated.\nNCSC do provide documented guides for macOS along with a GitHub repo containing a script and a list of recommended security settings, but what do these look like in Microsoft Intune? And what if you need to make changes? What about if you have exceptions?\nCustom Configuration Template # I\u0026rsquo;m not going to detail all of these NCSC settings in this post, otherwise I\u0026rsquo;ll do myself out of a job, but I can help with the security settings don\u0026rsquo;t exist natively within the macOS Device Restriction template.\nAll the below security settings utilise the Custom configuration template for macOS\u0026hellip;straight from the horses mouth:\n\u0026ldquo;The custom configuration template allows IT admins to assign settings that aren\u0026rsquo;t built into Intune yet. For macOS devices, you can import a .mobileconfig file that you created using Profile Manager or a different tool.\u0026rdquo;\nSounds perfect right? Details on how to create these profiles are below, but for now, let\u0026rsquo;s look at the NCSC settings and their associated mobileconfig files.\nAutomatic Updates # Now the NCSC guidelines advise that Operating System and Software updates should be applied automatically, with no deferral of when they are available or installed.\nFrom the NCSC documentation:\nSettings Status Comments Defer macOS Updates No n/a Defer app Updates No n/a This one is pretty definite in what it wants.\nSadly, there isn\u0026rsquo;t an option in Microsoft Intune to enforce this setting, but we can achieve this using a custom profile and generated mobileconfig file.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;PayloadUUID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;3C307E14-8CDD-4EB8-A696-AC967397CE40\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadType\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Configuration\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadOrganization\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;ennbee.uk\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadIdentifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;0250B0DD-84C3-4DA4-91B3-6FA7824F54CD\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDisplayName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NCSC Automatic Software Update Settings\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Configures the macOS software update settings to enable all automatic update options.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadVersion\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;1\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;PayloadEnabled\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;PayloadRemovalDisallowed\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;PayloadScope\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;System\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadContent\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;PayloadUUID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;A1936EA9-62CC-407B-94B0-1AD14BD513BE\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadType\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.apple.SoftwareUpdate\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadOrganization\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;ennbee.uk\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadIdentifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.apple.SoftwareUpdate.A1936EA9-62CC-407B-94B0-1AD14BD513BE\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDisplayName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NCSC Automatic Software Update Settings\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Configures the macOS software update settings to enable all automatic update options.\u0026lt;string/\u0026gt; \u0026lt;key\u0026gt;PayloadVersion\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;1\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;PayloadEnabled\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;ConfigDataInstall\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;CriticalUpdateInstall\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;AutomaticCheckEnabled\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;restrict-software-update-require-admin-to-install\u0026lt;/key\u0026gt; \u0026lt;false/\u0026gt; \u0026lt;key\u0026gt;AutomaticDownload\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;AutomaticallyInstallAppUpdates\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;AutomaticallyInstallMacOSUpdates\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;CatalogURL\u0026lt;/key\u0026gt; \u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;AllowPreReleaseInstallation\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; Fast User Switching and Automatic Logon # Apparently Fast User Switching is a bad thing, as is automatically logging in, so they want this disabled too.\nFrom the NCSC documentation:\nSettings Status Comments Enable Fast User Switching No n/a Disable automatic login Yes n/a I wish they would stick with either \u0026lsquo;Enable\u0026rsquo; or \u0026lsquo;Disable\u0026rsquo;, the mixture is headache inducing. However, mobileconfig file to the rescue.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;PayloadContent\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;PayloadContent\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;com.apple.loginwindow\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Forced\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;mcx_preference_settings\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;DisableFDEAutoLogin\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;key\u0026gt;PayloadDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDisplayName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NCSC Disable Fast User Switching and Autologon\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadEnabled\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;PayloadIdentifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;7243A790-723E-4433-ABA4-629C1A99264C\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadType\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.apple.ManagedClient.preferences\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadUUID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;7243A790-723E-4433-ABA4-629C1A99264C\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadVersion\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;1\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;PayloadDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDisplayName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NCSC Disable Fast User Switching and Autologon\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadEnabled\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;PayloadIdentifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;AF624C73-095F-4C69-89FB-A0A771D1225E\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadRemovalDisallowed\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;PayloadScope\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;System\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadType\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Configuration\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadUUID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;AF624C73-095F-4C69-89FB-A0A771D1225E\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadVersion\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;1\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; Hiding System Preferences # This one makes more sense, as you don\u0026rsquo;t want users meddling with certain System Preferences such as, iCloud, Sharing, Startup Disk and Security.\nFrom the NCSC documentation:\nSettings Status Comments Restrict items in System Preferences Yes (disable selected items) iCloud Profiles Security \u0026amp; Privacy Startup Disk Sharing (enables remote management) Siri Xsan - If not in use FibreChannel - if not in use Now you could flat out disable them, but remember, NCSC is a guideline, so we\u0026rsquo;re just going to hide them instead\u0026hellip;\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;PayloadContent\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;PayloadType\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.apple.systempreferences\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadVersion\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;1\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;PayloadIdentifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.apple.systempreferences.12D5D87D-F18F-4807-84A8-1E77FBF0EA4B\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadUUID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;12D5D87D-F18F-4807-84A8-1E77FBF0EA4B\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDisplayName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.apple.systempreferences\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NCSC Hide System Preferences;iCloud, Security, Startup Disk and Sharing\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadOrganization\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;ennbee.uk\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadEnabled\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;HiddenPreferencePanes\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;com.apple.preferences.icloud\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;com.apple.preference.security\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;com.apple.preference.startupdisk\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;com.apple.preferences.sharing\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;PayloadDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NCSC Hide System Preferences;iCloud, Security, Startup Disk and Sharing\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDisplayName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NCSC Hide System Preferences\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadIdentifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.apple.systempreferences\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadOrganization\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;ennbee.uk\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadUUID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;BE218051-ED0B-4555-ADFB-86AA3072BB35\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadRemovalDisallowed\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;PayloadType\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Configuration\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadVersion\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;1\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;PayloadScope\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;User\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; Time Servers # Not so sure on this one, must be down to ensuring that the system time is correct for validation of certificates\u0026hellip;maybe.\nFrom the NCSC documentation:\nSettings Status Comments Time Server Specify time server by device location Organisations should refer to their MDM documentation for instructions on setting this up See what I mean about it being complicated, thanks NCSC.\nAnyway, here\u0026rsquo;s the mobileconfig file setting the time servers to be time.euro.apple.com if you\u0026rsquo;re in Europe obviously.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;PayloadContent\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;PayloadContent\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;com.apple.MCX\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Forced\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;mcx_preference_settings\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;timeServer\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;time.euro.apple.com\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;key\u0026gt;PayloadDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Configures Time Servers\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDisplayName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NCSC Automatic Time Servers\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadEnabled\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;PayloadIdentifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;4B63BB1E-0D4D-4DD2-BF93-4AAB46523179\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadOrganization\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;ennbee.uk\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadType\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.apple.ManagedClient.preferences\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadUUID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;4B63BB1E-0D4D-4DD2-BF93-4AAB46523179\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadVersion\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;1\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;PayloadDescription\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Configures Time Servers\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadDisplayName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NCSC Automatic Time Servers\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadEnabled\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;PayloadIdentifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;EE4E0945-5074-4EF1-A375-2B9688644D8F\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadOrganization\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;ennbee.uk\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadRemovalDisallowed\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;PayloadScope\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;System\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadType\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Configuration\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadUUID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;EE4E0945-5074-4EF1-A375-2B9688644D8F\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;PayloadVersion\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;1\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; Creating Custom Configuration Profiles # Now that we have the required mobileconfig files, and that you\u0026rsquo;ve saved them with that file extension (it\u0026rsquo;s basically glorified XML to be honest), we can look at creating these Custom Configuration Profiles:\nBrowse to the macOS Configuration page and select \u0026lsquo;Create profile\u0026rsquo; Under \u0026lsquo;Profile type\u0026rsquo; select \u0026lsquo;Templates\u0026rsquo;, then select \u0026lsquo;Custom\u0026rsquo; and then select \u0026lsquo;Create\u0026rsquo; Give the Custom profile a suitable name and select \u0026lsquo;Next\u0026rsquo; Give the Custom configuration profile name a suitable name, ensure the Deployment channel is \u0026lsquo;Device channel\u0026rsquo; and upload the mobileconfig file. Select \u0026lsquo;Next\u0026rsquo; and assign the profile to the required Device Group. Repeat for all the mobileconfig files created. Summary # This was a bit of a whirlwind tour of Custom Configuration Profiles for macOS, and there is a huge amount that can be controlled, managed, and dictated using them. If you have a macOS device, you can use Apple Configuration 2 to create these files, if you don\u0026rsquo;t, then have fun with the Apple Developer Device Management Guide, like I did\u0026hellip;\n","date":"21 April 2022","permalink":"/posts/ncsc-macos-settings/","section":"Blog","summary":"If you\u0026rsquo;ve ever had to implement baseline security settings, whether this be Centre for Internet Security, Cyber Essentials, or National Cyber Security Centre, you\u0026rsquo;ll probably have encountered some level of pain when it comes to non-Microsoft devices, as the guidance, is, well, complicated. Here we unpick these settings for macOS devices.","title":"macOS National Cyber Security Centre Security Settings in Intune"},{"content":"","date":"21 April 2022","permalink":"/tags/mobileconfig/","section":"Tags","summary":"","title":"mobileconfig"},{"content":"Introduction # With the change to Android 10+ requiring a wireless network to go through the Fully Managed device enrolment, you may be asking, \u0026ldquo;Well what if my users don\u0026rsquo;t have access to a wireless network?\u0026rdquo;, don\u0026rsquo;t fret, with a bit of effort you can regenerate a new QR code that allows the use of Mobile Data.\nConfiguration # The below sections detail the steps to generate a new QR code for enrolment, allowing the use of Mobile Data.\nGet the QR Code Data # Use QR Reader on an existing phone or using an online reader to get the full QR code data:\n{ \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME\u0026#34;:\u0026#34;com.google.android.apps.work.clouddpc/.receivers.CloudDeviceAdminReceiver\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM\u0026#34;:\u0026#34;I5YvS0O5hXY46mb01BlRjq4oJJGs2kuUcHvVkAPEXlg\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION\u0026#34;:\u0026#34;https://play.google.com/managed/downloadManagingApp?identifier=setup\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE\u0026#34;:{ \u0026#34;com.google.android.apps.work.clouddpc.EXTRA_ENROLLMENT_TOKEN\u0026#34;:\u0026#34;TOKENVALUE\u0026#34; } } Updating the JSON Content # Add in the below code snippet before the android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE section:\n\u0026#34;android.app.extra.PROVISIONING_USE_MOBILE_DATA\u0026#34;:true, So the full JSON string should look like the below, with the TOKENVALUE obviously the correct one:\n{ \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME\u0026#34;:\u0026#34;com.google.android.apps.work.clouddpc/.receivers.CloudDeviceAdminReceiver\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM\u0026#34;:\u0026#34;I5YvS0O5hXY46mb01BlRjq4oJJGs2kuUcHvVkAPEXlg\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION\u0026#34;:\u0026#34;https://play.google.com/managed/downloadManagingApp?identifier=setup\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_USE_MOBILE_DATA\u0026#34;:true, \u0026#34;android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE\u0026#34;:{ \u0026#34;com.google.android.apps.work.clouddpc.EXTRA_ENROLLMENT_TOKEN\u0026#34;:\u0026#34;TOKENVALUE\u0026#34; } } Summary # Copy the string and paste it into an online QR code generator to generate the new QR code. This can then be provided to your users, pending testing, to allow them to enrol their new Android device in Microsoft Intune, whether connected to wireless or mobile data.\n","date":"21 March 2022","permalink":"/posts/android-enterprise-enrolment-mobile-data/","section":"Blog","summary":"What happens when your Android Fully Managed Corporate Owned users get a new Android 11 device and they can\u0026rsquo;t enrol to Intune using mobile data, well there\u0026rsquo;s a fix for that.","title":"Enrolling Android Enterprise devices Using Mobile Data"},{"content":"Introduction # You\u0026rsquo;ve probably hit the limitation with Windows Autopilot Hybrid Azure AD Join deployments and the device name templates being less than flexible, restricting to only a prefix and, well, that\u0026rsquo;s it.\nYou\u0026rsquo;ve also probably been asked whether you can configure the device name to match an asset tag or another unique bit of information, well this script, adapted from an existing one by Michael Niehaus can help.\nConfiguration # The below sections detail the steps carried out to modify the script to work without the need for an Azure web application, and can be deployed locally to rename devices.\nAdding the Variables # The post linked above details the steps required to ensure that the computer object itself has the ability to initiate the rename, and the below script has been changed to use existing device information, such as serial, instead of a web service:\nOn-premises domain variable Computer name prefix variable Wait time before restart This means that it can be deployed to existing environments without the need to deploy, or pay for, an Azure Web App.\nThe first section details the parameters that can used and updated.\n#Sets the variables for the customer $domain = \u0026#34;onprem.local\u0026#34; #local domain $ComputerPrefix = \u0026#34;PRE-\u0026#34; #Prefix $waittime = \u0026#34;60\u0026#34; #sets the restart wait time in minutes Getting the Device Name # This next section pulls back the serial number and ensures that the computer name is less than 15 characters.\n#Get serial and removes commas $Serial = Get-WmiObject Win32_bios | Select-Object -ExpandProperty SerialNumber $newName = $ComputerPrefix + $Serial $newName = $newName.Replace(\u0026#34; \u0026#34;,\u0026#34;\u0026#34;) #Removes spaces #shortens name if ($newName.Length -ge 15) { $newName = $newName.substring(0, 15) } The Waiting Game # Using New-TimeSpan we can convert the $waittime variable into whatever time format we need, and as we\u0026rsquo;re using the shutdown command, we need seconds:\n$waitinseconds = (New-TimeSpan -Minutes $waittime).Seconds Write-Host \u0026#34;Initiating a restart in $waitime minutes\u0026#34; \u0026amp; shutdown.exe /g /t $waitinseconds /f /c \u0026#34;Restarting the computer in $wait minutes due to a computer name change. Please save your work.\u0026#34; The Whole Thing # The full script can be found here, I would strongly advise testing this prior to pushing it out via Microsoft Intune.\nDeployment # Save the above script and create a new PowerShell script deployment in Microsoft Intune using the following configuration settings, then deploy to a test group of devices.\nBingo! another battle won.\n","date":"20 March 2022","permalink":"/posts/hybrid-join-computer-rename/","section":"Blog","summary":"You\u0026rsquo;ve probably hit the limitation with Windows Autopilot Hybrid Azure AD Join deployments and the device name templates being less than flexible, restricting to only a prefix and, well, that\u0026rsquo;s it.","title":"Renaming Windows Autopilot Hybrid Joined Devices"},{"content":"","date":"17 March 2022","permalink":"/tags/bitlocker/","section":"Tags","summary":"","title":"BitLocker"},{"content":"Introduction # You may have enabled and configure BitLocker for silent encryption on your Windows 10 Autopilot joined devices, but have you had the headache of devices that don\u0026rsquo;t have a Windows Recovery Environment (WinRE) configured? Yep? Me too\u0026hellip;\nWhat you\u0026rsquo;ll see in either the Bitlocker-API event log, or within the Encryption Readiness reporting in Microsoft Intune the following, glorious error:\nThe OS volume is unprotected | Windows Recovery Environment (WinRE) isn't configured\nConfiguration # So how do we go about enabling WinRE if it exists, setup BitLocker encryption, and grab the BitLocker recovery key and ping it to Azure AD?\nHere\u0026rsquo;s how\u0026hellip;\nUpdating the Script # This Microsoft script has been adapted to check for the WinRE configuration before it continues and attempts to enable BitLocker, the $HotToTrot variable is used to denote whether to continue or not.\nThe below is the added section to check and enable, or attempt to enable, WinRE:\n$HotToTrot =\u0026#34;false\u0026#34; #Checks Windows Recovery Environment and enables if disabled if($WinREStatus -like \u0026#39;*Windows RE status: Enabled*\u0026#39;){ $HotToTrot = \u0026#34;True\u0026#34; Write-Verbose -Message \u0026#34;WinRE Partition Enabled and good to enable BitLocker $HotToTrot\u0026#34; } Else{ Try{ $WinREEnable = reagentc.exe /enable if($WinREEnable -like \u0026#39;*Operation Successful*\u0026#39;){ $HotToTrot = \u0026#34;True\u0026#34; Write-Verbose -Message \u0026#34;WinRE Partition Enabled and good to enable BitLocker, HotToTrot set to $HotToTrot\u0026#34; } Else{ $HotToTrot =\u0026#34;false\u0026#34; Write-Verbose -Message \u0026#34;Unable to enabled WinRE, HotToTrot set to $HotToTrot\u0026#34; } } Catch{ $HotToTrot =\u0026#34;false\u0026#34; Write-Verbose -Message \u0026#34;Unable to enabled WinRE\u0026#34; } } if($HotToTrot -eq \u0026#39;True\u0026#39;) Fixing the Script # The script has logic in place to escrow the recovery key to Azure AD, using either the BackupToAAD-BitLockerKeyProtector commandlet or, if this isn\u0026rsquo;t available, using a call to GraphAPI. The below sections needed to be updated due to where the Azure AD Join information is now stored in the registry:\n# Check if we can use BackupToAAD-BitLockerKeyProtector commandlet if (Get-Command -Name \u0026#34;BackupToAAD-BitLockerKeyProtector\u0026#34; -ErrorAction \u0026#34;SilentlyContinue\u0026#34;) { # BackupToAAD-BitLockerKeyProtector commandlet exists Write-Verbose -Message \u0026#34;Saving Key to AAD using BackupToAAD-BitLockerKeyProtector\u0026#34; $BLV = Get-BitLockerVolume -MountPoint $OSDrive | Select-Object * If ($Null -ne $BLV.KeyProtector) { BackupToAAD-BitLockerKeyProtector -MountPoint $OSDrive -KeyProtectorId $BLV.KeyProtector[1].KeyProtectorId } Else { Write-Error \u0026#34;\u0026#39;Get-BitLockerVolume\u0026#39; failed to retrieve drive encryption details for $OSDrive\u0026#34; } } else { # BackupToAAD-BitLockerKeyProtector commandlet not available, using other mechanism Write-Verbose -Message \u0026#34;BackupToAAD-BitLockerKeyProtector not available\u0026#34; Write-Verbose -Message \u0026#34;Saving Key to AAD using Enterprise Registration API\u0026#34; # Get the AAD Machine Certificate $cert = Get-ChildItem -Path \u0026#34;Cert:\\LocalMachine\\My\\\u0026#34; | Where-Object { $_.Issuer -match \u0026#34;CN=MS-Organization-Access\u0026#34; } # Obtain the AAD Device ID from the certificate $id = $cert.Subject.Replace(\u0026#34;CN=\u0026#34;, \u0026#34;\u0026#34;) # Obtain the Tenant ID from the certificate thumbprint $tenantid = ($cert.Thumbprint).Replace(\u0026#34;-\u0026#34;,\u0026#34;\u0026#34;) # Get the tenant name from the registry $tenant = (Get-ItemProperty -Path \u0026#34;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\CloudDomainJoin\\JoinInfo\\$($tenantid)\u0026#34;).UserEmail.Split(\u0026#39;@\u0026#39;)[1] # Create the URL to post the data to based on the tenant and device information $url = \u0026#34;https://enterpriseregistration.windows.net/manage/$tenant/device/$($id)?api-version=1.0\u0026#34; # Generate the body to send to AAD containing the recovery information Write-Verbose -Message \u0026#34;Saving key protector to AAD for self-service recovery by manually posting it to:\u0026#34; Write-Verbose -Message \u0026#34;`t$url\u0026#34; # Get the BitLocker key information from WMI (Get-BitLockerVolume -MountPoint $OSDrive).KeyProtector | Where-Object { $_.KeyProtectorType -eq \u0026#39;RecoveryPassword\u0026#39; } | ForEach-Object { $key = $_ $body = \u0026#34;{\u0026#34;\u0026#34;key\u0026#34;\u0026#34;:\u0026#34;\u0026#34;$($key.RecoveryPassword)\u0026#34;\u0026#34;,\u0026#34;\u0026#34;kid\u0026#34;\u0026#34;:\u0026#34;\u0026#34;$($key.KeyProtectorId.replace(\u0026#39;{\u0026#39;,\u0026#39;\u0026#39;).Replace(\u0026#39;}\u0026#39;,\u0026#39;\u0026#39;))\u0026#34;\u0026#34;,\u0026#34;\u0026#34;vol\u0026#34;\u0026#34;:\u0026#34;\u0026#34;OSV\u0026#34;\u0026#34;}\u0026#34; Write-Verbose -Message \u0026#34;KeyProtectorId : $($key.KeyProtectorId) key: $($key.RecoveryPassword)\u0026#34; # Post the data to the URL and sign it with the AAD Machine Certificate $req = Invoke-WebRequest -Uri $url -Body $body -UseBasicParsing -Method \u0026#34;Post\u0026#34; -UseDefaultCredentials -Certificate $cert $req.RawContent Write-Verbose -Message \u0026#34; -- Key save web request sent to AAD - Self-Service Recovery should work\u0026#34; } } Putting it All Together # The full script can be found here, I would strongly advise testing this prior to pushing it out via Microsoft Intune.\nScript Deployment # Save the above script and create a new PowerShell script deployment in Microsoft Intune using the following configuration settings, then deploy to a test group of devices.\nBingo! One battle won, onto the next.\n","date":"17 March 2022","permalink":"/posts/enable-bitlocker-and-winre/","section":"Blog","summary":"You may have enabled and configure BitLocker for silent encryption on your Windows 10 Autopilot joined devices, but have you had the headache of devices that don\u0026rsquo;t have a Windows Recovery Environment (WinRE) configured? Yep? Me too\u0026hellip;","title":"Enabling BitLocker and WinRE on failed Windows Devices"},{"content":"","date":"17 March 2022","permalink":"/tags/encryption/","section":"Tags","summary":"","title":"Encryption"},{"content":"Introduction # I\u0026rsquo;m Nick Benton, an end-user computing specialist with over a decade of experience in consulting, architecture, design, and implementation of modern device management, and enterprise mobility solutions. I\u0026rsquo;m currently the Principal Consultant for Device Management at Phoenix Software Ltd who are the Microsoft Partner of the Year for Modern Endpoint Management 2023, where my main focus is assisting customers in their road to a modern workplace using Microsoft Intune, with a focus on migration, security and zero touch deployments.\nI hold the certifications for Microsoft 365 Enterprise Administrator and Modern Desktop Administrator, which I should do as I work with the products on a daily basis.\nDisclaimer # The views expressed anywhere on this site are strictly mine and not the opinions and views of my employer or any vendor mentioned. All information is provided \u0026ldquo;as is\u0026rdquo; with no warranties, and should be tested prior to any implementation, and I hold no liability for the outcome of the information provided.\nTestimonials # Nick was very knowledgeable, helpful and dedicated to the project. - Practical Action\nLast week it was a script for app deployments and assignments, this week Nick spent some of his own time, writing up a script to support a customer mobile migration to save Phoenix and the customer a considerable amount of time on each migration batch. Not only did Nick write it up, test and share it, but Nick was also kind enough to take me through the process of the steps. ‚Äî Phoenix Software\nFantastic delivery as per usual\u0026hellip;Customer was very complimentary of the help, guidance and depth of knowledge Nick has provided and taken the time to share with them. ‚Äî National House Building Council\nWe are really pleased with the service Nick offered and wanted to express our sincere thanks, for all the work he completed for us\u0026hellip;nothing was too much trouble, he communicated with us all the time and was so reliable and a please to work with. ‚Äî Epping Forest District Council\nThank you very much for the Low-level Design Document, all in all an excellent document with very well collated requirements. ‚Äî The Royal Household\nI just wanted to pass on my thanks for the work on AutoPilot that Nick Benton did with us. Nick‚Äôs expertise and passion for the subject area really shone through, and so the work he delivered is absolutely top quality. Not only that, he was great at explaining to me exactly what he was doing, why he was doing it, and how everything works and links together so I‚Äôm in a really good position to manage this going forward. I learned a lot! ‚Äî West Yorkshire Fire\nThank you Nick\u0026hellip;Possibly the most helpful training session we\u0026rsquo;ve had since your last one! ‚Äî Cambridge Enterprise\nI wanted to express my heartfelt thanks for the excellent work completed by Nick. I found him very knowledgeable, professional and overall a great guy to work alongside with. He delivered high quality work even whilst working around (and highlighting) a number of issues related to our network setup \u0026hellip;. Its always nice to watch someone good at their work, who shows good emotional intelligence and wants the best for all. ‚Äî Epping Forest District Council\nI‚Äôd like to pass my very positive feedback on all the engagement team members to date, but note in particular the positive feedback I‚Äôve had from my team members on the time / session pieces spent with Nick Benton, who has really shone in his instant understanding of any aspect the team has put to him. My team are keen to get him on time retainer to have an MOT from Nick every 6 months or so, so positive their time with him. ‚Äî SEEMiS Group LLP\nWe were all very impressed with Nick‚Äôs knowledge and professionalism during the course of the implementation and are very pleased with the outcomes. ‚Äî Torbay Council\nExcellent work from Nick. Clear comms every day and solutions provided where the project differed from initial expectations. Very helpful approach and happy to teach me parts of the process. Wouldn‚Äôt hesitate to use such services again. ‚Äî University of Gloucestershire\nNick Benton is bloody fantastic! I haven‚Äôt learned so much useful information since I left school, and that was a very very long time ago. He has a really nice manner, and is a brilliant trainer! Thank you for organising this. Far more useful than I could possibly put into words. ‚Äî Cambridge Enterprise\nJust some feedback to share from my side as well, Nick was absolutely fantastic on that call we had on Friday! Really good engagement with every member of the team that was on the call and handled every question brilliantly! It was clear he really knew his stuff and I‚Äôm sure that level of expertise will have positioned us well for further works with this customer on this project. ‚Äî Phoenix Software\n","date":"1 January 0001","permalink":"/about/","section":"MEM v ENNBEE: Battles with Modern Device Management","summary":"Introduction # I\u0026rsquo;m Nick Benton, an end-user computing specialist with over a decade of experience in consulting, architecture, design, and implementation of modern device management, and enterprise mobility solutions.","title":"About"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"Introduction # This site collects usage data using Google Analytics 4 using cookies, giving us insight into the number of people that visit our website. All data is anonymised and we do not sell nor share any data with third parties.\nA cookie is a small file, typically of letters and numbers, downloaded on to a device when the user accesses our website. A cookie is stored on your hard drive.\nAbout Cookies # A cookie is a small file of letters and numbers that we store on your browser or the hard drive of your computer if you agree. Cookies contain information that is transferred to your computer\u0026rsquo;s hard drive. Our website uses cookies to distinguish you from other users of our website. This helps us to provide you with a good experience when you browse our website and allows us to improve our website.\nBy continuing to browse the website, you are agreeing to our use of cookies. We may use the following cookies:\nAnalytical/performance cookies. They allow us to recognise and count the number of visitors and to see how visitors move around our website when they are using it. This helps us to improve the way our website works, for example, by ensuring that users are finding what they are looking for easily. Analytics Providers # Please note that we use Google Analytics, which places cookies on your computer, to help the website analyse how visitors use the website. The information generated by the cookie about your use of the website (including a randomisation of your IP address) will be transmitted to and stored by Google for the purpose of evaluating your use of the website, compiling reports on website activity for website operators and providing to us other services relating to website activity and internet usage. You can prevent Google‚Äôs collection and use of data by downloading and installing the browser plug-in available under google.com/dlpage/gaoptout. Please visit google.com/intl/en/policies/privacy/ for further information on how Google uses your data.\nRejecting Cookies # You block cookies by activating the setting on your browser that allows you to refuse the setting of all or some cookies or by choosing to deny Cookies when prompted, then no information will be collected whatsoever.\n","date":"1 January 0001","permalink":"/privacy/","section":"MEM v ENNBEE: Battles with Modern Device Management","summary":"Introduction # This site collects usage data using Google Analytics 4 using cookies, giving us insight into the number of people that visit our website.","title":"Privacy"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]